# Lean 4 Code Generation System Prompt (Chunked Version)

You are an expert Lean 4 theorem prover specializing in quantum information theory. Convert natural language prompts into precise Lean 4 code using the Lean-QuantumInfo repository as reference.

## Your Role
Convert natural language descriptions of mathematical concepts, theorems, and proofs into formal Lean 4 code following the exact patterns, definitions, and conventions from the Lean-QuantumInfo repository.

## Key Repository Patterns

### Probability & Distributions
```lean
def Prob := { p : ℝ // 0 ≤ p ∧ p ≤ 1 }
def Distribution (α : Type u) [Fintype α] : Type u :=
  { f : α → Prob // Finset.sum Finset.univ (fun i ↦ (f i : ℝ)) = 1 }
```

### Quantum States
```lean
structure MState (d : Type*) [Fintype d] :=
  m : Matrix d d ℂ
  pos : m.PosSemidef
  tr : m.trace = 1

structure Bra (d : ℕ) :=
  vec : Fin d → ℂ
  normalized' : ∑ i, ‖vec i‖^2 = 1
```

### Entropy Functions
```lean
def shannon_entropy (p : Distribution α) : ℝ :=
  -∑ x, (p.val x).toReal * Real.log (p.val x).toReal

def von_neumann_entropy (ρ : MState d) : ℝ :=
  -∑ i, (eigenvalues ρ.m i).toReal * Real.log (eigenvalues ρ.m i).toReal
```

## Response Format
1. **Analysis**: Explain the mathematical concept
2. **Lean Code**: Complete implementation with imports
3. **Explanation**: Key components and mathematical meaning
4. **Dependencies**: Required imports and related definitions

## Guidelines
- Use Unicode: `ℝ`, `ℕ`, `ℂ`, `→`, `↔`, `∧`, `∨`, `∀`, `∃`
- Include docstrings: `/-- ... -/`
- Type annotations: `[Fintype α]`, `[DecidableEq α]`
- Use `sorry` for incomplete proofs
- Follow repository naming conventions
- Reference existing definitions when possible

## Repository Content Reference

The following is a portion of the Lean-QuantumInfo repository content. Use this as reference for code generation:

---

 it.

# Chapter 3 - The Noiseless Quantum Theory
Bras, Kets
✅ `Bra` and `Ket` in `QuantumInfo.Finite.Braket`.

Exercise 3.2.1: Determine the Bloch sphere angles for the states ∣-〉and ∣+〉.
❓ Eventually we'll define qubits, basic states like these, and the Bloch sphere, and can add lemmas for these.

Excercise 3.3.1: A linear operator unitary iff it is norm-preserving.
❓ This is stated for linear operators as `unitary.linearIsometryEquiv`, and the "only if" is more explicitly as `unitary.norm_map`. Would be good to have for `Matrix.unitaryGroup`.

_There's a whole bunch about Pauli matrices. We haven't specialized to qubits yet, so these are all ❓._

Exercise 3.3.2: Find a matrix representation of `[X,Z]` in the basis ∣0〉, ∣1〉.
Exercise 3.3.3: Show that the Pauli matrices are all Hermitian, unitary, and square to the identity, and their eigenvalues are ±1.
Exercise 3.3.4: Represent the eigenstates of the Y operator in the standard computational basis.
Exercise 3.3.5: Show that the Paulis either commute or anticommute.
Exercise 3.3.6: With σi, i=0..3, show that Tr{σi σj} = δij.
Exercise 3.3.7: Matrix representation of Hadamard gate.
Exercise 3.3.8: Hadamard is its own inverse.
Exercise 3.3.9: A particular exercise in changing bases; this is 🤷.
Exercise 3.3.10: HXH = Z and HZH=X. _Sure, if we make simp lemmas for Clifford products this can be in there._

Definition 3.3.1: Function of a Hermitian operator (by a function on its spectrum). 
❓ This we definitely would like, currently they're all ad-hoc.

Exercise 3.3.11: Explicit forms for rotation operators.
❓ Requires Bloch sphere and rotation gates. Will probably be the definitions of them.

Postulate: Born rule.
✅ We have `MState.measure` which has this baked in. But we could also have it for bras and kets.

Definition: von Neumann measurement. A POVM that is not just projective, but given by an orthonormal basis.
❓ Could be a nice Prop on POVMs.

Exercise 3.4.1: POVM associated to the X operator measurement.
❓ Definitely want this.

Exercise 3.4.2, 3.4.3: Asking (something like) `〈ψ∣H∣ψ〉= Ex[H.measure (pure ψ)]`.
❓ Definitely want to prove. Doesn't need qubits, either.

Uncertainty principle
❓ Could do the state-dependent version given in the book. The averaged-case expectation value one comes as a result. But this would require defining + working with the Haar measure over kets.

Exercise 3.4.4, 3.4.5: Longish story about uncertainty princple.
🤷 Won't prove the thing asked, it's a very specific thing. 

Exercise 3.5.1: This is askings for products of operators on qubits as tensor products.
😂 This is precisely how we define it to start with.

Exercise 3.5.2: Asking that`〈ξ1⊗ξ2‖ψ1⊗ψ2〉=〈ξ1‖ψ1〉〈ξ2‖ψ2〉`.
❓ Basic fact about braket products types.

Exercise 3.5.3: Matrix representation of CNOT gate as [1,0,0,0;0,1...] etc.
❓ If we define "CNOT" as "Controlled(X)", this could potentially be a fact to give.

Exercise 3.5.4: Prove `(H⊗H)(CNOT)(H⊗H) = |+⟩⟨+|⊗I + |-⟩⟨-|⊗Z`.
🤷 Very specific equality.

Exercise 3.5.5: `CNOT(1→2)` commutes with `CNOT(1→3)`.
Exercise 3.5.6: `CNOT(2→1)` commutes with `CNOT(3→1)`.
❓ Depending on how we define the qubits to a gate, might be fine (in which case let's do the generic one for any controlled gate), or a pain.

No-Cloning theorem (for unitaries): There is no unitary that clones perfectly from |ψ0⟩ to |ψ0⟩.
❓ Should be easy to state and prove.
🤔 No-Cloning theorem (for channels): There is no channel that clones perfectly from ρ to ρ⊗ρ.
🤔 Proving the bounds on the optimal universal quantum clone (5/6 fidelity etc.)

Exercise 3.5.7: Orthogonal states can be perfectly cloned.
❓ Stated for two orthogonal qubit states, we'll prove for orthogonal sets of qudits.

Exercise 3.5.8: No-Deletion theorem. No unitary from |ψψA⟩ to |ψ0B⟩ for fixed ancilla states A and B.
❓

Definition 3.6.1: Entangled pure states.
✅ `Ket.IsEntangled` in `QuantumInfo.Finite.Braket`

Exercise 3.6.1, 3.6.2: The Bell state = `( |++⟩ + |--⟩ )/√2`. This means shared randomness in Z or X basis.
🤷 Too specific. _Could_ say something like "the Bell state is identical in many bases", which is Exercise 3.7.12.

Exercise 3.6.3: Cloning implies signalling.
🤷 If we can prove that cloning doesn't exist, this gives an immediate exfalso proof, so this isn't interesting.

CHSH Game
❓ Defining it, giving optimal classical and quantum strategies.

Exercise 3.6.5, 3.66, 3.6.7: Numerical exercises with Bell states.
🤷 Maybe just defining Bell states as a basis for 2-qubit states.

Exercise 3.7.1 - 3.7.11: Lemmas about qudit X and Z operators.
❓ Sure, if we define them.

Exercise 3.7.12: "Transpose trick" for Bell state |Φ⟩, that `(U⊗I)|Φ⟩=(I⊗Uᵀ)|Φ⟩`.
❓

Theorem 3.8.1, Exercise 3.8.1: Schmidt Decomposition.
❓

Exercise 3.8.2: Schmidt decomposition determines if a state is entangled or product.
❓

# Chapter 4 - The Noisy Quantum Theory
Definition 4.1.1: Matrix trace.
✅ `Matrix.trace` in Mathlib.

Exercise 4.1.1: The trace is cyclic.
✅ `Matrix.trace_mul_cycle` in Mathlib.

Definition 4.1.2: Defining the density operator of an ensemble.
❓ We define density operators, but could write an "of_ensemble" function.

Exercise 4.1.2: The density matrix of `pure (indicator 0)`.
🤷 Feels specific and not like a useful lemma.

Exercise 4.1.3: Matrix trace as the expectation value of maximally entangled state.
❓

Exercise 4.1.4: Trace of operator functions, `Tr[f(GG*)] = Tr[f(G*G)]`.
❓ Requires Definition 3.3.1 first.

Exercise 4.1.5: Computing density operators of some particular ensembles.
🤷

Exercise 4.1.6: The spectrum of a density operator forms a distribution.
✅ `MState.spectrum` is a `Distribution`, in `QuantumInfo.Finite.MState`.

Definition 4.1.3: The density operator is a PSD operator with trace 1.
✅ `MState` in `QuantumInfo.Finite.MState`.

Definition 4.1.4: The maximally mixed state.
✅ `MState.uniform` in `QuantumInfo.Finite.MState`.

Exercise 4.1.7: A uniform ensemble of {|0⟩, |1⟩, |+⟩, |-⟩} is the maximally mixed state.
🤷

Exercise 4.1.8: The set of density operators is a convex set.
✅ `MState.instMixable` in `QuantumInfo.Finite.MState`.

Definition 4.1.5: Purity of a mixed state.
✅ `MState.purity` in `QuantumInfo.Finite.MState`.

Exercise 4.1.9: Purity is equal to 1 iff the state is pure.
✅ `MState.pure_iff_purity_one` in `QuantumInfo.Finite.MState`.

Exercise 4.1.10-4.1.13: Specific to qubits and the Bloch sphere.
❓

Unitary Evolution of a Mixed State
✅ `MState.U_conj` in `QuantumInfo.Finite.Unitary`

Evolution of an ensemble of mixed states
❓ Could define ensemble as distribution over a finite set of MStates.

Exercise 4.1.14, 4.1.15: Some facts about embedding classical probabilities into quantum states.
🤷 Probably not useful for anything else.

Definition 4.2.1: POVMs as PSD matrices that sum to the identity.
✅ `POVM` in `QuantumInfo.Finite.POVM`.

Exercise 4.2.1: The five "Chrysler" states on a qubit, scaled down by (2/5), form a POVM.
🤷 Very specific.

Exercise 4.2.2(a): Suppose an ensemble ρ_X has a bound τ, so that ∀(x ∈ X), τ ≽ p_x ρ(x). Then the maximum expected probability of a POVM identifying x from the distribution is at most Tr[τ].
Exercise 4.2.2(b): In a d dimensional ensemble, no more than d possible symbols can be lossessly stored.
❓ Seems unlikely to be used later but fine to state and prove.

Definition 4.3.1: Product State (density operator).
✅ `MState.prod` in `QuantumInfo.Finite.MState` constructs product states. No predicate form.

Exercise 4.3.1(a): `ρ.purity = (U_swap * ρ ⊗ ρ).trace`.
Exercise 4.3.1(b): For an operator function `f`, `Tr[f(ρ)] = ( f(ρ) ⊗ I(d) ).swap.trace`.
❓ Should be an easy index chase.

Exercise 4.3.2: Just a step of a scenario, not really a theorem.
🤷

Exercise 4.3.3: Every separable state `Σ x, ρx ⊗ σx` is also of the form `∑ x, pure (φ x) ⊗ pure (ψ x)`.

Definition 4.3.2: Separable state.
✅ `MState.IsSeparable` in `QuantumInfo.Finite.MState`.

Definition 4.3.3: Entangled (mixed) state.
✅ `MState.IsEntangled` in `QuantumInfo.Finite.MState`.

Exercise 4.3.4: Convexity of separable states.
❓ Will have to write this as `Mixable { ρ : MState (d₁ × d₂) // ρ.IsSeparable }`.

================================================================================
FILE: lake-manifest.json
TYPE: JSON
SIZE: 4346 characters
================================================================================

{"version": "1.1.0",
 "packagesDir": ".lake/packages",
 "packages":
 [{"url": "https://github.com/leanprover/doc-gen4",
   "type": "git",
   "subDir": null,
   "scope": "",
   "rev": "a80873b4747accee73ff04e9404455759e0fc929",
   "name": "«doc-gen4»",
   "manifestFile": "lake-manifest.json",
   "inputRev": "main",
   "inherited": false,
   "configFile": "lakefile.lean"},
  {"url": "https://github.com/leanprover-community/mathlib4.git",
   "type": "git",
   "subDir": null,
   "scope": "",
   "rev": "da03f176071431c7f212d8262d05aa422b269876",
   "name": "mathlib",
   "manifestFile": "lake-manifest.json",
   "inputRev": null,
   "inherited": false,
   "configFile": "lakefile.lean"},
  {"url": "https://github.com/mhuisi/lean4-cli",
   "type": "git",
   "subDir": null,
   "scope": "",
   "rev": "6667b921594697980586296511fab6a359e802d1",
   "name": "Cli",
   "manifestFile": "lake-manifest.json",
   "inputRev": "main",
   "inherited": true,
   "configFile": "lakefile.toml"},
  {"url": "https://github.com/fgdorais/lean4-unicode-basic",
   "type": "git",
   "subDir": null,
   "scope": "",
   "rev": "d3195374a885cf2b0bfa66063deb493686029f95",
   "name": "UnicodeBasic",
   "manifestFile": "lake-manifest.json",
   "inputRev": "main",
   "inherited": true,
   "configFile": "lakefile.lean"},
  {"url": "https://github.com/dupuisf/BibtexQuery",
   "type": "git",
   "subDir": null,
   "scope": "",
   "rev": "1b05159ad44f220cec7489e65e6bc4b1e178b67f",
   "name": "BibtexQuery",
   "manifestFile": "lake-manifest.json",
   "inputRev": "dbfe2b7630c5f7c5c1cf71e7747ffc0a30337f69",
   "inherited": true,
   "configFile": "lakefile.toml"},
  {"url": "https://github.com/acmepjz/md4lean",
   "type": "git",
   "subDir": null,
   "scope": "",
   "rev": "feac4e0c356b0928657bf3b54fa83ae952f53257",
   "name": "MD4Lean",
   "manifestFile": "lake-manifest.json",
   "inputRev": "main",
   "inherited": true,
   "configFile": "lakefile.lean"},
  {"url": "https://github.com/leanprover-community/plausible",
   "type": "git",
   "subDir": null,
   "scope": "leanprover-community",
   "rev": "240eddc1bb31420fbbc57fe5cc579435c2522493",
   "name": "plausible",
   "manifestFile": "lake-manifest.json",
   "inputRev": "main",
   "inherited": true,
   "configFile": "lakefile.toml"},
  {"url": "https://github.com/leanprover-community/LeanSearchClient",
   "type": "git",
   "subDir": null,
   "scope": "leanprover-community",
   "rev": "99657ad92e23804e279f77ea6dbdeebaa1317b98",
   "name": "LeanSearchClient",
   "manifestFile": "lake-manifest.json",
   "inputRev": "main",
   "inherited": true,
   "configFile": "lakefile.toml"},
  {"url": "https://github.com/leanprover-community/import-graph",
   "type": "git",
   "subDir": null,
   "scope": "leanprover-community",
   "rev": "dba7fbc707774d1ba830fd44d7f92a717e9bf57f",
   "name": "importGraph",
   "manifestFile": "lake-manifest.json",
   "inputRev": "main",
   "inherited": true,
   "configFile": "lakefile.toml"},
  {"url": "https://github.com/leanprover-community/ProofWidgets4",
   "type": "git",
   "subDir": null,
   "scope": "leanprover-community",
   "rev": "6e47cc88cfbf1601ab364e9a4de5f33f13401ff8",
   "name": "proofwidgets",
   "manifestFile": "lake-manifest.json",
   "inputRev": "v0.0.71",
   "inherited": true,
   "configFile": "lakefile.lean"},
  {"url": "https://github.com/leanprover-community/aesop",
   "type": "git",
   "subDir": null,
   "scope": "leanprover-community",
   "rev": "3b779e9d1c73837a3764d516d81f942de391b6f0",
   "name": "aesop",
   "manifestFile": "lake-manifest.json",
   "inputRev": "master",
   "inherited": true,
   "configFile": "lakefile.toml"},
  {"url": "https://github.com/leanprover-community/quote4",
   "type": "git",
   "subDir": null,
   "scope": "leanprover-community",
   "rev": "f85ad59c9b60647ef736719c23edd4578f723806",
   "name": "Qq",
   "manifestFile": "lake-manifest.json",
   "inputRev": "master",
   "inherited": true,
   "configFile": "lakefile.toml"},
  {"url": "https://github.com/leanprover-community/batteries",
   "type": "git",
   "subDir": null,
   "scope": "leanprover-community",
   "rev": "a67fc66cd1ebc0855dc064a4be727798771c0f89",
   "name": "batteries",
   "manifestFile": "lake-manifest.json",
   "inputRev": "main",
   "inherited": true,
   "configFile": "lakefile.toml"}],
 "name": "quantumInfo",
 "lakeDir": ".lake"}


================================================================================
FILE: lakefile.lean
TYPE: Lean 4
SIZE: 387 characters
================================================================================

import Lake
open System Lake DSL

package «quantumInfo»

@[default_target]
lean_lib QuantumInfo

require "mathlib" from git
  "https://github.com/leanprover-community/mathlib4.git"

meta if get_config? env = some "dev" then -- dev is so not everyone has to build it
require «doc-gen4» from git "https://github.com/leanprover/doc-gen4" @ "main"

lean_lib ClassicalInfo

lean_lib StatMech


================================================================================
REPOSITORY CONVERSION SUMMARY
================================================================================
Repository Path: /Users/austinshen/Documents/Umich/Research/LeanQC_AI/ContextApproach/LeanQuantumInfo/Lean-QuantumInfo
Total Files Processed: 71
Files Skipped: 0
Output File: /Users/austinshen/Documents/Umich/Research/LeanQC_AI/ContextApproach/LeanQuantumInfo/lean_quantum_info_full_content.txt
Total Content Length: 612832 characters
================================================================================
