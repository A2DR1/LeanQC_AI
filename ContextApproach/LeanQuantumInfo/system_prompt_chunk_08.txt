# Lean 4 Code Generation System Prompt (Chunked Version)

You are an expert Lean 4 theorem prover specializing in quantum information theory. Convert natural language prompts into precise Lean 4 code using the Lean-QuantumInfo repository as reference.

## Your Role
Convert natural language descriptions of mathematical concepts, theorems, and proofs into formal Lean 4 code following the exact patterns, definitions, and conventions from the Lean-QuantumInfo repository.

## Key Repository Patterns

### Probability & Distributions
```lean
def Prob := { p : â„ // 0 â‰¤ p âˆ§ p â‰¤ 1 }
def Distribution (Î± : Type u) [Fintype Î±] : Type u :=
  { f : Î± â†’ Prob // Finset.sum Finset.univ (fun i â†¦ (f i : â„)) = 1 }
```

### Quantum States
```lean
structure MState (d : Type*) [Fintype d] :=
  m : Matrix d d â„‚
  pos : m.PosSemidef
  tr : m.trace = 1

structure Bra (d : â„•) :=
  vec : Fin d â†’ â„‚
  normalized' : âˆ‘ i, â€–vec iâ€–^2 = 1
```

### Entropy Functions
```lean
def shannon_entropy (p : Distribution Î±) : â„ :=
  -âˆ‘ x, (p.val x).toReal * Real.log (p.val x).toReal

def von_neumann_entropy (Ï : MState d) : â„ :=
  -âˆ‘ i, (eigenvalues Ï.m i).toReal * Real.log (eigenvalues Ï.m i).toReal
```

## Response Format
1. **Analysis**: Explain the mathematical concept
2. **Lean Code**: Complete implementation with imports
3. **Explanation**: Key components and mathematical meaning
4. **Dependencies**: Required imports and related definitions

## Guidelines
- Use Unicode: `â„`, `â„•`, `â„‚`, `â†’`, `â†”`, `âˆ§`, `âˆ¨`, `âˆ€`, `âˆƒ`
- Include docstrings: `/-- ... -/`
- Type annotations: `[Fintype Î±]`, `[DecidableEq Î±]`
- Use `sorry` for incomplete proofs
- Follow repository naming conventions
- Reference existing definitions when possible

## Repository Content Reference

The following is a portion of the Lean-QuantumInfo repository content. Use this as reference for code generation:

---

otherwise we can't "shrink"
    --it by applying Lemma 7. Taking the full-rank state of dimension `H i` and taking all powers of it, works.
    set Ïƒâ‚ : (n : â„•) â†’ IsFree (i := i ^ n) := fun n â†¦
      âŸ¨(free_fullRank i).choose âŠ—^S[n], IsFree.npow (free_fullRank i).choose_spec.2 nâŸ© with hÏƒâ‚
    have hÏƒâ‚_top : R2 Ï Ïƒâ‚ â‰  âŠ¤ := by
      rw [R2, â† Filter.liminf_nat_add _ 1]
      simp [Ïƒâ‚, mul_comm _ (qRelativeEnt _ _)]
      conv =>
        enter [1,1,1,n]
        rw [ENNReal.mul_div_cancel_right (by positivity) (by finiteness)]
      simp [qRelativeEnt_ne_top (free_fullRank i).choose_spec.1]
    clear hÏƒâ‚
    --Repeat the Lemma7 improvement process to drive the gap down
    let Ïƒâ‚– : â„• â†’ (n : â„•) â†’ IsFree (i := i ^ n) := fun k â†¦
      (Lemma7_improver Ï hÎµ hÎµ')^[k] Ïƒâ‚

    --The gap between R_{1,Îµ} and R2 for `Ïƒâ‚– k` goes to 0 as `k â†’ âˆ`.
    have hÏƒâ‚–_gap : Filter.atTop.Tendsto (fun k â†¦ R2 Ï (Ïƒâ‚– k) - R1 Ï Îµ) (ğ“ 0) := by
      suffices h : âˆ€ (k : â„•), R2 Ï (Ïƒâ‚– k) - R1 Ï Îµ â‰¤ â†‘(1 - Îµ')^k * (R2 Ï Ïƒâ‚ - R1 Ï Îµ) by
        refine tendsto_nhds_bot_mono' ?_ h
        conv =>
          enter [3, 1]
          equals 0 * (R2 Ï Ïƒâ‚ - R1 Ï Îµ) => simp
        apply ENNReal.Tendsto.mul_const
        Â· simp only [ENNReal.tendsto_pow_atTop_nhds_zero_iff]
          --This should just be `simp` or `bound` at this point. TODO.
          simp [Prob.toNNReal, â† NNReal.coe_lt_coe, hÎµ'.1]
        Â· right; exact ENNReal.sub_ne_top hÏƒâ‚_top
      suffices h : âˆ€ (m k : â„•), R2 Ï (Ïƒâ‚– (m + k)) - R1 Ï Îµ â‰¤ (1 - Îµ')^k * (R2 Ï (Ïƒâ‚– m) - R1 Ï Îµ) by
        convert h 0; simp
      intro m k; induction k generalizing m
      Â· simp [Ïƒâ‚–]
      rename_i k ih
      have Ïƒâ‚–_succ (n) : Ïƒâ‚– (n + 1) = Lemma7_improver Ï hÎµ hÎµ' (Ïƒâ‚– n) :=
        Function.iterate_succ_apply' ..
      rw [â† add_assoc, Ïƒâ‚–_succ, pow_succ]
      grw [Lemma7_gap Ï hÎµ hÎµ' (Ïƒâ‚– (m + k)), ih m]
      ring_nf
      rfl

    replace hÏƒâ‚–_gap : Filter.atTop.liminf (fun k â†¦ R2 Ï (Ïƒâ‚– k)) â‰¤ R1 Ï Îµ := by
      rw [ENNReal.tendsto_sub_const_nhds_zero_iff] at hÏƒâ‚–_gap
      grw [Filter.liminf_le_limsup, hÏƒâ‚–_gap]

    rw [R1] at hÏƒâ‚–_gap
    grw [â† hÏƒâ‚–_gap]; clear hÏƒâ‚–_gap

    have hReg := RelativeEntResource.tendsto_ennreal Ï
    replace hReg := hReg.liminf_eq
    rw [â† hReg]; clear hReg

    unfold R2
    /- The idea is now that: the LHS is the liminf over all n, of the minimum free Ïƒ of dimension n;
      the RHS is the liminf over a particular subsequence, given by Ïƒâ‚–, which is free. But then
      the math is complicated a bit by the fact that the RHS is a _double_ liminf. This is what H&Y
      deal with by talking about the sequences `Ïƒ_{n_k, âˆ—} = Ïƒ_{n_k, k}` (below Eq (26)). We don't
      actually construct such a subsequence here, we just unfold the bounds repeatedly.
    -/
    refine Filter.le_liminf_of_le (by isBoundedDefault) ?_
    apply Filter.Eventually.of_forall fun _ â†¦ ?_
    refine Filter.liminf_le_liminf ?_
    apply Filter.Eventually.of_forall fun _ â†¦ ?_
    gcongr
    rw [iInf_subtype']
    exact iInf_le _ _

  Â· --the "strong converse" part
    conv =>
      enter [1, 1, n, 1, 1]
      rw [â† OptimalHypothesisRate.Lemma3 Îµ IsCompact_IsFree free_convex]

    --Let Ïƒâ‚˜ be the state minimizing ğƒ(ÏâŠ—^mâ€–Ïƒâ‚˜) over free states. This is guaranteed to exist since
    -- (1) the divergence is continuous and (2) the set of free states is compact.
    have Ïƒâ‚˜_exists (m : â„•) := IsCompact_IsFree.exists_isMinOn_lowerSemicontinuousOn
      Set.Nonempty.of_subtype (f := fun Ïƒ â†¦ ğƒ(ÏâŠ—^S[m]â€–Ïƒ)) (by fun_prop)

    have hÏƒâ‚˜1 (m) := (Ïƒâ‚˜_exists m).choose_spec.left
    have hÏƒâ‚˜2 (m) := (Ïƒâ‚˜_exists m).choose_spec.right
    generalize Ïƒâ‚˜_def : (fun m â†¦ (Ïƒâ‚˜_exists m).choose) = Ïƒâ‚˜
    simp_rw [congrFun Ïƒâ‚˜_def] at hÏƒâ‚˜1 hÏƒâ‚˜2
    clear Ïƒâ‚˜_def Ïƒâ‚˜_exists

    --Let Ïƒâ‚ be the full-rank free state
    have âŸ¨Ïƒâ‚, hÏƒâ‚_pos, hÏƒâ‚_freeâŸ© := FreeStateTheory.free_fullRank i

    --`h` is Eq (14)
    have h (m : â„•) (hm : m â‰¥ 1) := Lemma6 hm Ï Ïƒâ‚ (Ïƒâ‚˜ m) hÏƒâ‚_pos hÎµ.2

    --Update `h` to Eq (15)
    have hâ‚‚ (m : â„•) : (fun n â†¦ â€”log Î²_ Îµ(ÏâŠ—^S[n]â€–IsFree) / n) â‰¤á¶ [Filter.atTop]
        (fun n â†¦ â€”log Î²_ Îµ(ÏâŠ—^S[n]â€–{(Lemma6_Ïƒn m Ïƒâ‚ (Ïƒâ‚˜ m)) n}) / n) := by
      rw [Filter.EventuallyLE]
      apply Filter.Eventually.of_forall
      intro n
      gcongr
      apply OptimalHypothesisRate.negLog_le_singleton
      apply Lemma6_Ïƒn_IsFree hÏƒâ‚_free hÏƒâ‚˜1
    replace h (m) (hm) := (Filter.limsup_le_limsup (hâ‚‚ m)).trans (h m hm)
    clear hâ‚‚

    --Update `h` to Eq (16)
    conv at h =>
      enter [m, hm, 2, 1]
      exact (IsMinOn.iInf_eq (hÏƒâ‚˜1 m) (hÏƒâ‚˜2 m)).symm

    apply tendsto_le_of_eventuallyLE tendsto_const_nhds (RelativeEntResource.tendsto_ennreal Ï)
    rw [Filter.EventuallyLE, Filter.eventually_atTop]
    use 1
    convert h using 7
    Â· exact OptimalHypothesisRate.Lemma3 Îµ IsCompact_IsFree free_convex
    Â· symm
      apply iInf_subtype''

/-- Theorem 4, which is also called the Generalized quantum Stein's lemma in Hayashi & Yamasaki.
What they state as an equality of limits, which don't exist per se in Mathlib, we state as the existence
of a number (which happens to be `RegularizedRelativeEntResource`) to which both sides converge.
-/
theorem limit_hypotesting_eq_limit_rel_entropy (Ï : MState (H i)) (Îµ : Prob) (hÎµ : 0 < Îµ âˆ§ Îµ < 1) :
    âˆƒ d : â„â‰¥0,
      Filter.atTop.Tendsto (fun n â†¦ â€”log Î²_ Îµ(ÏâŠ—^S[n]â€–IsFree) / n) (ğ“ d)
      âˆ§
      Filter.atTop.Tendsto (fun n â†¦ (â¨… Ïƒ âˆˆ IsFree, ğƒ(ÏâŠ—^S[n]â€–Ïƒ)) / n) (ğ“ d)
      := by
  use ğ‘…áµ£âˆ Ï -- Regularized relative entropy of resource (RegularizedRelativeEntResource) as an NNReal
  constructor
  Â· exact GeneralizedQSteinsLemma Ï hÎµ -- Theorem 1 in Hayashi & Yamasaki
  Â· exact RelativeEntResource.tendsto_ennreal Ï -- The regularized relative entropy of resource is not infinity


================================================================================
FILE: QuantumInfo/Finite/Unitary.lean
TYPE: Lean 4
SIZE: 2002 characters
================================================================================

import QuantumInfo.Finite.MState

/-! # Unitary operators on quantum state

This file is intended for lemmas about unitary matrices (`Matrix.unitaryGroup`) and how they apply to
`Bra`s, `Ket`s, and `MState` mixed states.

This is imported by `CPTPMap` to define things like unitary channels, Kraus operators, and
complementary channels, so this file itself does not discuss channels yet.-/

noncomputable section

notation "ğ”[" n "]" => Matrix.unitaryGroup n â„‚

namespace HermitianMat

variable {ğ•œ : Type*} [RCLike ğ•œ] {n : Type*} [Fintype n] [DecidableEq n]
variable (A B : HermitianMat n ğ•œ) (U : Matrix.unitaryGroup n ğ•œ)

@[simp]
theorem trace_conj_unitary : (A.conj U.val).trace = A.trace := by
  simp [Matrix.trace_mul_cycle, HermitianMat.conj, â† Matrix.star_eq_conjTranspose, HermitianMat.trace]

@[simp]
theorem le_conj_unitary : A.conj U.val â‰¤ B.conj U â†” A â‰¤ B := by
  rw [â† sub_nonneg, â† sub_nonneg (b := A), â† sub_conj]
  constructor
  Â· intro h
    simpa [HermitianMat.conj_conj] using HermitianMat.conj_le h (star U).val
  Â· exact fun h â†¦ HermitianMat.conj_le h U.val

end HermitianMat

namespace MState

variable {d dâ‚ dâ‚‚ dâ‚ƒ : Type*}
variable [Fintype d] [Fintype dâ‚] [Fintype dâ‚‚] [Fintype dâ‚ƒ]
variable [DecidableEq d]

/-- Conjugate a state by a unitary matrix (applying the unitary as an evolution). -/
def U_conj (Ï : MState d) (U : ğ”[d]) : MState d where
  M := Ï.M.conj U.val
  tr := by simp
  zero_le := HermitianMat.conj_le Ï.zero_le U.val

/-- You might think this should only be true up to permutation, so that it would read like
`âˆƒ Ïƒ : Equiv.Perm d, (Ï.U_conj U).spectrum = Ï.spectrum.relabel Ïƒ`. But since eigenvalues
of a matrix are always canonically sorted, this is actually an equality.
-/
@[simp]
theorem U_conj_spectrum_eq (Ï : MState d) (U : ğ”[d]) :
    (Ï.U_conj U).spectrum = Ï.spectrum := by
  have (M : HermitianMat d â„‚) (U : ğ”[d]) : (M.conj U).H.eigenvalues = M.H.eigenvalues := by
    --missing simp lemma
    sorry
  simp [MState.spectrum, U_conj, this]

end MState


================================================================================
FILE: QuantumInfo/ForMathlib/ContinuousLinearMap.lean
TYPE: Lean 4
SIZE: 2260 characters
================================================================================

--For the first three lemmas
import Mathlib.Topology.Algebra.Module.LinearMap

--For the third lemma
import Mathlib.Analysis.CStarAlgebra.Classes
import Mathlib.Analysis.InnerProductSpace.Spectrum
import Mathlib.Order.CompletePartialOrder

namespace ContinuousLinearMap

variable {R S : Type*} [Semiring R] [Semiring S] (Ïƒ : R â†’+* S) (M Mâ‚‚ : Type*)
variable [TopologicalSpace M] [AddCommMonoid M] [TopologicalSpace Mâ‚‚] [AddCommMonoid Mâ‚‚]
variable [Module R M] [Module S Mâ‚‚]

--These two theorems might look a bit silly as aliases of `LinearMap.____`, but they don't `simp` on their
@[simp]
theorem range_zero [RingHomSurjective Ïƒ] : LinearMap.range (0 : M â†’SL[Ïƒ] Mâ‚‚) = âŠ¥ :=
  LinearMap.range_zero

@[simp]
theorem ker_zero : LinearMap.ker (0 : M â†’SL[Ïƒ] Mâ‚‚) = âŠ¤ :=
  LinearMap.ker_zero

theorem ker_mk (f : M â†’â‚›â‚—[Ïƒ] Mâ‚‚) (hf : Continuous f.toFun) :
    LinearMap.ker (ContinuousLinearMap.mk f hf) = LinearMap.ker f := by
  rfl

end ContinuousLinearMap

namespace ContinuousLinearMap

variable {n ğ•œ : Type*} [Fintype n] [RCLike ğ•œ]

/-- The support of a Hermitian matrix is the sum of its nonzero eigenspaces. -/
theorem support_eq_sup_eigenspace_nonzero (A : EuclideanSpace ğ•œ n â†’L[ğ•œ] EuclideanSpace ğ•œ n)
    (hA : A.IsSymmetric) : LinearMap.range A = â¨† Î¼ â‰  0, Module.End.eigenspace A Î¼ := by
  apply le_antisymm
  Â· rintro x âŸ¨y, hyâŸ©
    have h_decomp : y âˆˆ â¨† (Î¼ : ğ•œ), Module.End.eigenspace A.toLinearMap Î¼ := by
      have h_orth := hA.orthogonalComplement_iSup_eigenspaces_eq_bot
      rw [Submodule.orthogonal_eq_bot_iff] at h_orth
      rw [h_orth]
      exact Submodule.mem_top;
    rw [Submodule.mem_iSup_iff_exists_finsupp] at h_decomp
    rcases h_decomp with âŸ¨f, hfâ‚, hfâ‚‚âŸ©
    have h_apply_A : A y = âˆ‘ i âˆˆ f.support, A (f i) := by
      rw [â† hfâ‚‚, map_finsuppSum]
      exact rfl
    have h_eigen (i) : A (f i) = (i : ğ•œ) â€¢ f i :=
      Module.End.mem_eigenspace_iff.mp (hfâ‚ i)
    rw [â† hy, h_apply_A, Finset.sum_congr rfl (fun i _ â†¦ h_eigen i)]
    refine Submodule.sum_mem _ fun i _ â†¦ ?_
    by_cases hi0 : i = 0
    Â· simp [hi0]
    Â· apply Submodule.smul_mem
      apply Submodule.mem_iSup_of_mem i
      exact Submodule.mem_iSup_of_mem hi0 (hfâ‚ i)
  Â· simp only [iSup_le_iff]
    intro Î¼ hÎ¼ x hx
    use Î¼â»Â¹ â€¢ x
    simp_all

end ContinuousLinearMap


================================================================================
FILE: QuantumInfo/ForMathlib/ContinuousSup.lean
TYPE: Lean 4
SIZE: 13541 characters
================================================================================

import Mathlib.Analysis.InnerProductSpace.Basic
import Mathlib.Analysis.Normed.Module.FiniteDimension
import Mathlib.Data.Real.StarOrdered
import Mathlib.Analysis.Normed.Operator.BoundedLinearMaps

variable {Î± Î² Î³ : Type*} {S : Set Î²} {f : Î³ â†’ Î² â†’ Î±}
variable [ConditionallyCompleteLinearOrder Î±] [TopologicalSpace Î±] [OrderTopology Î±]
variable [TopologicalSpace Î³]

namespace IsCompact
variable [TopologicalSpace Î²]

theorem sSup_image_eq_sSup_image_closure {f : Î² â†’ Î±}
  (hS : IsCompact (closure S)) (hf : Continuous f) :
    sSup (f '' S) = sSup (f '' closure S) := by
  rcases S.eq_empty_or_nonempty with rfl | h; Â· simp
  refine csSup_eq_of_forall_le_of_forall_lt_exists_gt (by simpa) ?_ ?_
  Â· rintro a âŸ¨w, hw, rflâŸ©
    exact le_csSup (hS.image hf).bddAbove (Set.mem_image_of_mem f <| subset_closure hw)
  Â· intro w hw
    simp only [Set.mem_image, exists_exists_and_eq_and]
    contrapose! hw
    have h_image_closure : f '' closure S âŠ† closure (f '' S) :=
      image_closure_subset_closure_image hf
    have h_closure_image : closure (f '' S) âŠ† Set.Iic w :=
      closure_minimal (Set.image_subset_iff.mpr hw) isClosed_Iic
    exact csSup_le ((h.mono subset_closure).image f) fun y hy â†¦
      (h_image_closure.trans h_closure_image) hy

theorem sInf_image_eq_sInf_image_closure {f : Î² â†’ Î±} (hS : IsCompact (closure S)) (hf : Continuous f) :
    sInf (f '' S) = sInf (f '' closure S) :=
  sSup_image_eq_sSup_image_closure (Î± := Î±áµ’áµˆ) hS hf

/-- A version of `IsCompact.continuous_sSup` with a slightly weaker hypothesis on the set `K`,
that its closure is compact (but the set itself need not be). -/
theorem closure_continuous_sSup (hS : IsCompact (closure S)) (hf : Continuous â†¿f) :
    Continuous fun x â†¦ sSup (f x '' S) := by
  simp_rw [fun x â†¦ sSup_image_eq_sSup_image_closure hS (f := f x) (by fun_prop)]
  exact hS.continuous_sSup hf

/-- A version of `IsCompact.continuous_sInf` with a slightly weaker hypothesis on the set `K`,
that its closure is compact (but the set itself need not be). -/
theorem closure_continuous_sInf (hS : IsCompact (closure S)) (hf : Continuous â†¿f) :
    Continuous fun x â†¦ sInf (f x '' S) :=
  closure_continuous_sSup (Î± := Î±áµ’áµˆ) hS hf

theorem continuous_iSup (hS : IsCompact (closure S)) (hf : Continuous â†¿f) :
    Continuous fun x â†¦ â¨† y : S, f x y := by
  simp_rw [iSup, â† Set.image_eq_range]
  exact hS.closure_continuous_sSup hf

theorem continuous_iInf (hS : IsCompact (closure S)) (hf : Continuous â†¿f) :
    Continuous fun x â†¦ â¨… y : S, f x y :=
  continuous_iSup (Î± := Î±áµ’áµˆ) hS hf

end IsCompact

namespace Bornology.IsBounded
variable [PseudoMetricSpace Î²] [ProperSpace Î²]

/-- Similar to `IsCompact.continuous_sSup`, but taking a bounded set in the bornology instead
of a compact set. -/ --TODO: Can `ProperSpace` be relaxed to `CompleteSpace` here?
theorem continuous_sSup (hS : Bornology.IsBounded S) (hf : Continuous â†¿f) :
    Continuous fun x â†¦ sSup (f x '' S) :=
  hS.isCompact_closure.closure_continuous_sSup hf

/-- Similar to `IsCompact.continuous_sInf`, but taking a bounded set in the bornology instead
of a compact set. -/
theorem continuous_sInf (hS : Bornology.IsBounded S) (hf : Continuous â†¿f) :
    Continuous fun x â†¦ sInf (f x '' S) :=
  hS.isCompact_closure.closure_continuous_sInf hf

theorem continuous_iSup (hS : Bornology.IsBounded S) (hf : Continuous â†¿f) :
    Continuous fun x â†¦ â¨† y : S, f x y := by
  simp_rw [iSup, â† Set.image_eq_range]
  exact hS.isCompact_closure.closure_continuous_sSup <| by fun_prop

theorem continuous_iInf (hS : Bornology.IsBounded S) (hf : Continuous â†¿f) :
    Continuous fun x â†¦ â¨… y : S, f x y :=
  continuous_iSup (Î± := Î±áµ’áµˆ) hS hf

end Bornology.IsBounded

namespace LinearMap

/-- For bilinear maps in suitably well-behaved spaces with `IsModuleTopology`, taking the supremum in one
argument is still `Continuous`, by `Bornology.IsBounded.continuous_iSup`. -/
theorem continuous_iSup {E F ğ•œ : Type*}
  [CommRing ğ•œ] [TopologicalSpace ğ•œ] [IsTopologicalRing ğ•œ] [ConditionallyCompleteLinearOrder ğ•œ] [OrderTopology ğ•œ]
  [AddCommGroup E] [TopologicalSpace E] [Module ğ•œ E] [IsModuleTopology ğ•œ E]
  [AddCommGroup F] [Module ğ•œ F] [PseudoMetricSpace F] [ProperSpace F] [Module.Finite ğ•œ F] [IsModuleTopology ğ•œ F]
  (f : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ) {S : Set F} (hS : Bornology.IsBounded S) :
    Continuous fun x â†¦ â¨† y : S, f x y :=
  hS.continuous_iSup <| by fun_prop

/-- For bilinear maps in suitably well-behaved spaces with `IsModuleTopology`, taking the infimum in one
argument is still `Continuous`, by `Bornology.IsBounded.continuous_iInf`. -/
theorem continuous_iInf {E F ğ•œ : Type*}
  [CommRing ğ•œ] [TopologicalSpace ğ•œ] [IsTopologicalRing ğ•œ] [ConditionallyCompleteLinearOrder ğ•œ] [OrderTopology ğ•œ]
  [AddCommGroup E] [TopologicalSpace E] [Module ğ•œ E] [IsModuleTopology ğ•œ E]
  [AddCommGroup F] [Module ğ•œ F] [PseudoMetricSpace F] [ProperSpace F] [Module.Finite ğ•œ F] [IsModuleTopology ğ•œ F]
  (f : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ) {S : Set F} (hS : Bornology.IsBounded S) :
    Continuous fun x â†¦ â¨… y : S, f x y :=
  hS.continuous_iInf <| by fun_prop

/-- A specialization of `LinearMap.continuous_iSup` to finite dimensional spaces, in place
of requiring a (non-instance) `IsModuleTopology`. -/
theorem continuous_iSup' {E F ğ•œ : Type*}
  [NontriviallyNormedField ğ•œ] [ConditionallyCompleteLinearOrder ğ•œ] [OrderTopology ğ•œ] [CompleteSpace ğ•œ]
  [AddCommGroup E] [TopologicalSpace E] [IsTopologicalAddGroup E] [T2Space E]
  [Module ğ•œ E] [ContinuousSMul ğ•œ E] [FiniteDimensional ğ•œ E]
  [PseudoMetricSpace F] [ProperSpace F] [AddCommGroup F] [IsTopologicalAddGroup F] [T2Space F]
  [Module ğ•œ F] [ContinuousSMul ğ•œ F] [FiniteDimensional ğ•œ F]
  (f : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ) {S : Set F} (hS : Bornology.IsBounded S) :
    Continuous fun x â†¦ â¨† y : S, f x y :=
  let _ : IsModuleTopology ğ•œ E := isModuleTopologyOfFiniteDimensional (ğ•œ := ğ•œ) (E := E)
  let _ : IsModuleTopology ğ•œ F := isModuleTopologyOfFiniteDimensional (ğ•œ := ğ•œ) (E := F)
  f.continuous_iSup hS

/-- A specialization of `LinearMap.continuous_iInf` to finite dimensional spaces, in place
of requiring a (non-instance) `IsModuleTopology`. -/
theorem continuous_iInf' {E F ğ•œ : Type*}
  [NontriviallyNormedField ğ•œ] [ConditionallyCompleteLinearOrder ğ•œ] [OrderTopology ğ•œ] [CompleteSpace ğ•œ]
  [AddCommGroup E] [TopologicalSpace E] [IsTopologicalAddGroup E] [T2Space E]
  [Module ğ•œ E] [ContinuousSMul ğ•œ E] [FiniteDimensional ğ•œ E]
  [PseudoMetricSpace F] [ProperSpace F] [AddCommGroup F] [IsTopologicalAddGroup F] [T2Space F]
  [Module ğ•œ F] [ContinuousSMul ğ•œ F] [FiniteDimensional ğ•œ F]
  (f : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ) {S : Set F} (hS : Bornology.IsBounded S) :
    Continuous fun x â†¦ â¨… y : S, f x y :=
  let _ : IsModuleTopology ğ•œ E := isModuleTopologyOfFiniteDimensional (ğ•œ := ğ•œ) (E := E)
  let _ : IsModuleTopology ğ•œ F := isModuleTopologyOfFiniteDimensional (ğ•œ := ğ•œ) (E := F)
  f.continuous_iInf hS

/-- Alias of `LinearMap.continuous_iSup' ` that takes `LinearMap.BilinForm`. -/
theorem BilinForm.continuous_iSup {ğ•œ E : Type*}
  [RCLike ğ•œ] [ConditionallyCompleteLinearOrder ğ•œ] [OrderTopology ğ•œ]
  [NormedAddCommGroup E] [InnerProductSpace ğ•œ E] [FiniteDimensional ğ•œ E] [ProperSpace E]
  (f : LinearMap.BilinForm ğ•œ E) {S : Set E} (hS : Bornology.IsBounded S) :
    Continuous fun x â†¦ â¨† y : S, f x y :=
  f.continuous_iSup' hS

/-- Alias of `LinearMap.continuous_iInf' ` that takes `LinearMap.BilinForm`. -/
theorem BilinForm.continuous_iInf {ğ•œ E : Type*}
  [RCLike ğ•œ] [ConditionallyCompleteLinearOrder ğ•œ] [OrderTopology ğ•œ]
  [NormedAddCommGroup E] [InnerProductSpace ğ•œ E] [FiniteDimensional ğ•œ E] [ProperSpace E]
  (f : LinearMap.BilinForm ğ•œ E) {S : Set E} (hS : Bornology.IsBounded S) :
    Continuous fun x â†¦ â¨… y : S, f x y :=
  f.continuous_iInf' hS

end LinearMap

namespace ContinuousLinearMap

variable  {ğ•œ ğ•œâ‚‚ : Type*} {E F G : Type*} [NontriviallyNormedField ğ•œ] [Semiring ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œâ‚‚ â†’+* ğ•œ}
 [SeminormedAddCommGroup E] [NormedSpace ğ•œ E] [ProperSpace E]
 [AddCommMonoid F] [TopologicalSpace F] [Module ğ•œâ‚‚ F]
 [SeminormedAddCommGroup G] [NormedSpace ğ•œ G][ConditionallyCompleteLinearOrder G] [OrderTopology G]

/-- A specialization of `Bornology.IsBounded.continuous_iSup_bilinear` to `ContinuousLinearMap`. -/
theorem continuous_iSup
  (f : F â†’SL[Ïƒâ‚â‚‚] E â†’L[ğ•œ] G) {S : Set E} (hS : Bornology.IsBounded S) :
    Continuous fun x â†¦ â¨† y : S, f x y :=
  hS.continuous_iSup <| by fun_prop

theorem continuous_iInf
  (f : F â†’SL[Ïƒâ‚â‚‚] E â†’L[ğ•œ] G) {S : Set E} (hS : Bornology.IsBounded S) :
    Continuous fun x â†¦ â¨… y : S, f x y :=
  hS.continuous_iInf (Î± := G) <| by fun_prop

end ContinuousLinearMap

--This is the theorem we actually needed downstream...
theorem LinearMap.BilinForm.continuous_iSup_fst
  {E : Type*} [NormedAddCommGroup E] [InnerProductSpace â„ E] [FiniteDimensional â„ E]
  (f : LinearMap.BilinForm â„ E) {S : Set E} (hS : Bornology.IsBounded S) :
    Continuous fun x â†¦ â¨† y : S, f y x := by
  exact LinearMap.BilinForm.continuous_iSup f.flip hS
  --Old "direct" proof:
  -- -- Since $f$ is continuous, there exists $C > 0$ such that for all $y \in S$ and $x \in E$, $|f y x| \leq C \|y\| \|x\|$.
  -- obtain âŸ¨C, hC1, hC2âŸ© : âˆƒ C > 0, âˆ€ y âˆˆ S, âˆ€ x : E, |f y x| â‰¤ C * â€–yâ€– * â€–xâ€– := by
  --   -- Since $f$ is continuous, there exists $C > 0$ such that for all $y, x \in E$, $|f y x| \leq C \|y\| \|x\|$ by the boundedness of continuous bilinear maps on finite-dimensional spaces.
  --   have h_cont : âˆƒ C > 0, âˆ€ y x : E, |f y x| â‰¤ C * â€–yâ€– * â€–xâ€– := by
  --     have h_bounded : Continuous (fun p : E Ã— E => f p.1 p.2) := by
  --       have _ := isModuleTopologyOfFiniteDimensional (ğ•œ := â„) (E := E)
  --       fun_prop
  --     obtain âŸ¨C, hCâ‚€, hCâŸ© : âˆƒ C > 0, âˆ€ y x : E, â€–yâ€– â‰¤ 1 â†’ â€–xâ€– â‰¤ 1 â†’ |f y x| â‰¤ C := by
  --       have h_compact : IsCompact {p : E Ã— E | â€–p.1â€– â‰¤ 1 âˆ§ â€–p.2â€– â‰¤ 1} := by
  --         have h_closed_unit_ball : IsCompact {p : E | â€–pâ€– â‰¤ 1} := by
  --           convert ProperSpace.isCompact_closedBall (0 : E) 1
  --           simp [Metric.closedBall, dist_eq_norm]
  --         exact h_closed_unit_ball.prod h_closed_unit_ball;
  --       obtain âŸ¨C, hCâŸ© := h_compact.exists_bound_of_continuousOn h_bounded.continuousOn;
  --       exact âŸ¨C âŠ” 1, zero_lt_one.trans_le (le_max_right _ _), fun y x hy hx â†¦ (hC (y, x) âŸ¨hy, hxâŸ© ).trans (le_max_left _ _)âŸ©;
  --     refine âŸ¨C, hCâ‚€, fun y x â†¦ ?_âŸ©;
  --     rcases eq_or_ne y 0 with rfl | hy; Â· simp
  --     rcases eq_or_ne x 0 with rfl | hx; Â· simp
  --     have := hC (â€–yâ€–â»Â¹ â€¢ y) (â€–xâ€–â»Â¹ â€¢ x) (by simp [hy, norm_smul]) (by simp [hx, norm_smul])
  --     simp only [map_smul, LinearMap.smul_apply, smul_eq_mul] at this
  --     rw [abs_le] at this âŠ¢
  --     rw [â† norm_ne_zero_iff] at hx hy
  --     have : 0 < â€–yâ€– * â€–xâ€– := by positivity
  --     have := inv_mul_cancel_leftâ‚€ hy ((f y) x)
  --     have := inv_mul_cancel_leftâ‚€ hx ((f y) x)
  --     have := mul_inv_cancelâ‚€ hy
  --     constructor <;> nlinarith
  --   exact âŸ¨ h_cont.choose, h_cont.choose_spec.1, fun y hy x â†¦ h_cont.choose_spec.2 y x âŸ©;
  -- -- Since $S$ is bounded, there exists $M > 0$ such that for all $y \in S$, $\|y\| \leq M$.
  -- obtain âŸ¨M, hM1, hM2âŸ© : âˆƒ M > 0, âˆ€ y âˆˆ S, â€–yâ€– â‰¤ M :=
  --   hS.exists_pos_norm_le
  -- rw [Metric.continuous_iff]
  -- intro b Îµ hÎµ
  -- refine âŸ¨Îµ / (C * M + 1), div_pos hÎµ (by positivity), fun a ha â†¦ ?_âŸ©
  -- -- Using the triangle inequality and the continuity of $f$, we get:
  -- have h_triangle (y) (hy : y âˆˆ S) : |f y a - f y b| â‰¤ C * M * â€–a - bâ€– := by
  --   rw [â† map_sub]
  --   apply (hC2 y hy ( a - b )).trans
  --   refine mul_le_mul_of_nonneg_right ?_ (by positivity)
  --   exact mul_le_mul_of_nonneg_left (hM2 y hy) hC1.le
  -- rcases S.eq_empty_or_nonempty with rfl | âŸ¨y, hyâŸ©; Â· simp [*]
  -- simp [dist_eq_norm] at *
  -- -- Applying the triangle inequality to the suprema, we get:
  -- have h_sup_triangle : |(â¨† y : S, f y a) - (â¨† y : S, f y b)| â‰¤ C * M * â€–a - bâ€– := by
  --   rw [abs_sub_le_iff]
  --   constructor
  --   Â· -- Applying the inequality $f y a \leq f y b + C * M * â€–a - bâ€–$ to each term in the supremum, we get:
  --     have h_le (y : S) : f y a â‰¤ f y b + C * M * â€–a - bâ€– := by
  --       linarith [abs_le.mp (h_triangle y y.2)]
  --     rw [sub_le_iff_le_add, add_comm]
  --     convert ciSup_le fun y => le_trans ( h_le y ) _;
  --     Â· exact âŸ¨âŸ¨ y, hy âŸ©âŸ©
  --     Â· refine add_le_add ?_ le_rfl
  --       refine le_csSup ?_ (Set.mem_range_self _)
  --       exact âŸ¨C * M * â€–bâ€–, Set.forall_mem_range.2 fun y => le_of_abs_le ((hC2 _ y.2 _).trans (by gcongr; exact hM2 _ y.2))âŸ©;
  --   Â· rw [sub_le_iff_le_add']
  --     -- Applying the triangle inequality to each term in the supremum, we get:
  --     have h_sup_triangle (y) (hy : y âˆˆ S) : f y b â‰¤ f y a + C * M * â€–a - bâ€– := by
  --       linarith [abs_le.mp (h_triangle y hy)]
  --     convert ciSup_le _
  --     Â· exact âŸ¨âŸ¨y, hyâŸ©âŸ©
  --     Â· intro x
  --       refine (h_sup_triangle x x.2).trans (add_le_add_right ?_ _)
  --       exact le_ciSup (show BddAbove (Set.range fun y : S â†¦ f y a) by
  --         refine âŸ¨C * M * â€–aâ€–, Set.forall_mem_range.2 fun y â†¦ ?_âŸ©
  --         refine le_of_abs_le ((hC2 _ y.2 _).trans ?_)
  --         refine mul_le_mul_of_nonneg_right ?_ (by positivity)
  --         exact mul_le_mul_of_nonneg_left (hM2 _ y.2) hC1.le
  --       ) x;
  -- apply h_sup_triangle.trans_lt
  -- rw [lt_div_iffâ‚€ (by positivity)] at ha
  -- nlinarith [mul_pos hC1 hM1]

theorem LinearMap.BilinForm.continuous_iInf_fst
  {E : Type*} [NormedAddCommGroup E] [InnerProductSpace â„ E] [FiniteDimensional â„ E]
  (f : LinearMap.BilinForm â„ E) {S : Set E} (hS : Bornology.IsBounded S) :
    Continuous fun x â†¦ â¨… y : S, f y x :=
  LinearMap.BilinForm.continuous_iInf f.flip hS


================================================================================
FILE: QuantumInfo/ForMathlib/Filter.lean
TYPE: Lean 4
SIZE: 3077 characters
================================================================================

import Mathlib

import Mathlib.Tactic.Bound

open Topology

--This is a stupid name for a stupid lemma
theorem Filter.Tendsto_inv_nat_mul_div_real (m : â„•)
   : Filter.Tendsto (fun (x : â„•) => ((â†‘x)â»Â¹ * â†‘(x / m) : â„)) Filter.atTop (ğ“ (1 / â†‘m)) := by
  --Thanks aristotle!
  -- This simplifies to $\lim_{x \to \infty} \frac{\lfloor x / m \rfloor}{x} = \frac{1}{m}$ because the floor function grows asymptotically like $x / m$.
  have h_floor : Filter.Tendsto (fun x : â„• => (Nat.floor (x / m : â„) : â„) / x) Filter.atTop (nhds (1 / (m : â„))) := by
    -- We'll use the fact that the floor function is bounded and apply the squeeze theorem.
    have h_floor_bound : âˆ€ x : â„•, x > 0 â†’ (Nat.floor (x / m : â„) : â„) / x â‰¥ (1 / m - 1 / x) âˆ§ (Nat.floor (x / m : â„) : â„) / x â‰¤ 1 / m := by
      cases eq_or_ne m 0
      Â· rename_i h
        intro x a
        subst h
        simp_all only [gt_iff_lt, CharP.cast_eq_zero, div_zero, Nat.floor_zero, zero_div, one_div, zero_sub, ge_iff_le,
          Left.neg_nonpos_iff, inv_nonneg, Nat.cast_nonneg, le_refl, and_self]
      Â· intro x a
        simp_all only [ne_eq, gt_iff_lt, one_div, ge_iff_le, tsub_le_iff_right]
        apply And.intro
        Â· rw [ inv_eq_one_div, div_add', div_le_div_iffâ‚€ ] <;> first | positivity | nlinarith [ Nat.lt_floor_add_one ( ( x : â„ ) / m ), show ( x : â„ ) â‰¥ 1 by exact Nat.one_le_cast.mpr a, mul_div_cancelâ‚€ ( x : â„ ) ( show ( m : â„ ) â‰  0 by positivity ), inv_mul_cancelâ‚€ ( show ( x : â„ ) â‰  0 by positivity ) ] ;
        Â· rw [ div_le_iffâ‚€ ( by positivity ) ];
          simpa [ div_eq_inv_mul ] using Nat.floor_le ( by positivity : 0 â‰¤ ( x : â„ ) / m );
    -- Apply the squeeze theorem to conclude the proof.
    have h_squeeze : Filter.Tendsto (fun x : â„• => (1 / m : â„) - 1 / x) Filter.atTop (nhds (1 / m)) := by
      simpa using tendsto_const_nhds.sub ( _root_.tendsto_inverse_atTop_nhds_zero_nat );
    exact tendsto_of_tendsto_of_tendsto_of_le_of_le' h_squeeze tendsto_const_nhds ( Filter.eventually_atTop.mpr âŸ¨ 1, fun x hx => h_floor_bound x hx |>.1 âŸ© ) ( Filter.eventually_atTop.mpr âŸ¨ 1, fun x hx => h_floor_bound x hx |>.2 âŸ© );
  -- Apply the hypothesis `h_floor` to conclude the proof.
  convert h_floor using 1;
  -- By definition of floor function, we know that âŒŠ(x : â„) / mâŒ‹â‚Š is the greatest integer less than or equal to (x : â„) / m.
  funext x; simp [Nat.floor_div_natCast];
  ring

--Similar to `ENNReal.tendsto_toReal_iff` in `Mathlib/Topology/Instances/ENNReal/Lemmas`, but
-- instead of requiring finiteness for all values, just eventually is needed.
open Filter Topology ENNReal in
theorem ENNReal.tendsto_toReal_iff_of_eventually_ne_top
  {Î¹} {fi : Filter Î¹} {f : Î¹ â†’ â„â‰¥0âˆ} (hf : âˆ€á¶  i in fi, f i â‰  âˆ) {x : â„â‰¥0âˆ}
    (hx : x â‰  âˆ) : Tendsto (fun n => (f n).toReal) fi (ğ“ x.toReal) â†” Tendsto f fi (ğ“ x) := by
  have heâ‚ : f =á¶ [fi] (fun n â†¦ (f n).toNNReal) := by
    rw [EventuallyEq]
    peel hf with h
    simp [h]
  have heâ‚‚ : (fun n â†¦ (f n).toReal) = (fun n â†¦ ((f n).toNNReal : â„â‰¥0âˆ).toReal) :=
    rfl
  rw [Filter.tendsto_congr' heâ‚, heâ‚‚]
  exact tendsto_toReal_iff (by finiteness) hx


================================================================================
FILE: QuantumInfo/ForMathlib/HermitianMat/Basic.lean
TYPE: Lean 4
SIZE: 8661 characters
================================================================================

import QuantumInfo.ForMathlib.Matrix
import QuantumInfo.ForMathlib.IsMaximalSelfAdjoint
import QuantumInfo.ForMathlib.ContinuousLinearMap

import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.Rpow.Basic
import Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus
import Mathlib.Analysis.Matrix

/-- The type of Hermitian matrices, as a `Subtype`. Equivalent to a `Matrix n n Î±` bundled
with the fact that `Matrix.IsHermitian`. -/
abbrev HermitianMat (n : Type*) (Î± : Type*) [AddGroup Î±] [StarAddMonoid Î±] :=
  (selfAdjoint (Matrix n n Î±) : Type (max u_1 u_2))

namespace HermitianMat

variable {Î± : Type*} {m n : Type*}

section addgroup

variable [AddGroup Î±] [StarAddMonoid Î±]

theorem eq_IsHermitian : HermitianMat n Î±  = { m : Matrix n n Î± // m.IsHermitian} := by
  rfl

@[coe, reducible] def toMat : HermitianMat n Î± â†’ Matrix n n Î± :=
  Subtype.val

instance : Coe (HermitianMat n Î±) (Matrix n n Î±) := âŸ¨toMatâŸ©

@[simp]
theorem val_eq_coe (A : HermitianMat n Î±) : A.val = A := by
  rfl

@[simp]
theorem mk_toMat (x : Matrix n n Î±) (h) : HermitianMat.toMat (Subtype.mk x h) = x := by
  rfl

/-- Alias for HermitianMat.property or HermitianMat.2, this gets the fact that the value
  is actually `IsHermitian`.-/
theorem H (A : HermitianMat n Î±) : A.toMat.IsHermitian :=
  A.2

@[ext] protected theorem ext {A B : HermitianMat n Î±} : A.toMat = B.toMat â†’ A = B :=
  Subtype.eq

instance instFun : FunLike (HermitianMat n Î±) n (n â†’ Î±) where
  coe M := (M : Matrix n n Î±)
  coe_injective' _ _ h := HermitianMat.ext h

instance instStar : Star (HermitianMat n Î±) :=
  âŸ¨(Â·)âŸ©

instance instTrivialStar : TrivialStar (HermitianMat n Î±) :=
  âŸ¨(refl Â·)âŸ©

@[simp]
theorem conjTranspose_toMat (A : HermitianMat n Î±) :
    A.toMat.conjTranspose = A :=
  A.H

end addgroup
section commring

variable [CommRing Î±] [StarRing Î±] [DecidableEq n] [Fintype n]

noncomputable instance instInv : Inv (HermitianMat n Î±) :=
  âŸ¨fun x â†¦ âŸ¨xâ»Â¹, Matrix.IsHermitian.inv x.HâŸ©âŸ©

noncomputable instance instZPow : Pow (HermitianMat n Î±) â„¤ :=
  âŸ¨fun x z â†¦ âŸ¨x^z, Matrix.IsHermitian.zpow x.H zâŸ©âŸ©

/-
--There is already a `One` instance when `n` is a `Fintype` (it comes through the fact that we have a
-- (`Ring`) but in principle we shouldn't need that (only DecidableEq!). But, the fact that trying
-- `simp` in `coe_one` below causes a defeq timeout is worrying. So, we keep this commented out, we'll
-- use `Fintype` everywhere we want a `1`.
variable {n : Type*} [DecidableEq n]

instance : One (HermitianMat n Î±) :=
  âŸ¨1, by
    simp [selfAdjoint.mem_iff, â† Matrix.ext_iff, Matrix.one_apply, apply_ite (Î² := Î±), eq_comm]âŸ©

@[simp]
theorem coe_one : (1 : HermitianMat n Î±).toMat = 1 := by
  rfl
-/

end commring
section rclike

variable [RCLike Î±]

@[simp]
theorem im_eq_zero (A : HermitianMat n Î±) (x : n) :
    RCLike.im (A x x) = 0 := by
  simpa [CharZero.eq_neg_self_iff] using congrArg (RCLike.im <| Â· x x) A.H.symm

--Repeat it explicitly for â„‚ so that simp can find it
@[simp]
theorem Complex_im_eq_zero (A : HermitianMat n â„‚) (x : n) :
    (A x x).im = 0 :=
  A.im_eq_zero x

variable [Fintype n] [DecidableEq n]

end rclike

section conj

variable [CommRing Î±] [StarRing Î±] [Fintype n]
variable (A : HermitianMat n Î±)

/-- The Hermitian matrix given by conjugating by a (possibly rectangular) Matrix. If we required `B` to be
square, this would apply to any `Semigroup`+`StarMul` (as proved by `IsSelfAdjoint.conjugate`). But this lets
us conjugate to other sizes too, as is done in e.g. Kraus operators. That is, it's a _heterogeneous_ conjguation.
-/
def conj {m} (B : Matrix m n Î±) : HermitianMat m Î± :=
  âŸ¨B * A.toMat * B.conjTranspose, by
  ext
  simp only [Matrix.star_apply, Matrix.mul_apply, Matrix.conjTranspose_apply, Finset.sum_mul,
    star_sum, star_mul', star_star, show âˆ€ (a b : n), star (A.toMat b a) = A.toMat a b from congrFunâ‚‚ A.property]
  rw [Finset.sum_comm]
  congr! 2
  ringâŸ©

theorem conj_conj {m l} [Fintype m] (B : Matrix m n Î±) (C : Matrix l m Î±) :
    (A.conj B).conj C = A.conj (C * B) := by
  ext1
  simp only [conj, mk_toMat, Matrix.conjTranspose_mul, Matrix.mul_assoc]

variable (B : HermitianMat n Î±)

theorem add_conj {m} (M : Matrix m n Î±) : (A + B).conj M = A.conj M + B.conj M := by
  ext1
  simp [conj, Matrix.mul_add, Matrix.add_mul]

theorem sub_conj {m} (M : Matrix m n Î±) : (A - B).conj M = A.conj M - B.conj M := by
  ext1
  simp [conj, Matrix.mul_sub, Matrix.sub_mul]

@[simp]
theorem conj_one [DecidableEq n] : A.conj (1 : Matrix n n Î±) = A := by
  simp [conj]

end conj

section eigenspace

variable {ğ•œ} [RCLike ğ•œ] [Fintype n] [DecidableEq n] (A : HermitianMat n ğ•œ)

instance [i : Nonempty n] : FaithfulSMul â„ (HermitianMat n ğ•œ) where
  eq_of_smul_eq_smul h := by
    simpa [RCLike.smul_re] using congr(RCLike.re ($(h 1).val i.some i.some))

/-- The continuous linear map associated with a Hermitian matrix. -/
def lin : EuclideanSpace ğ•œ n â†’L[ğ•œ] EuclideanSpace ğ•œ n where
  toLinearMap := A.toMat.toEuclideanLin
  cont := LinearMap.continuous_of_finiteDimensional _

@[simp]
theorem isSymmetric : A.lin.IsSymmetric :=
  Matrix.isHermitian_iff_isSymmetric.mp A.H

@[simp]
theorem lin_zero : (0 : HermitianMat n ğ•œ).lin = 0 := by
  simp [lin]; rfl

@[simp]
theorem lin_one : (1 : HermitianMat n ğ•œ).lin = 1 := by
  simp [lin]; rfl

noncomputable def eigenspace (Î¼ : ğ•œ) : Submodule ğ•œ (EuclideanSpace ğ•œ n) :=
  Module.End.eigenspace A.lin Î¼

/-- The kernel of a Hermitian matrix `A` as a submodule of Euclidean space, defined by
`LinearMap.ker A.toMat.toEuclideanLin`. Equivalently, the zero-eigenspace. -/
def ker : Submodule ğ•œ (EuclideanSpace ğ•œ n) :=
  LinearMap.ker A.lin

/-- The kernel of a Hermitian matrix is its zero eigenspace. -/
theorem ker_eq_eigenspace_zero : A.ker = A.eigenspace 0 := by
  ext
  simp [ker, eigenspace]

@[simp]
theorem ker_zero : (0 : HermitianMat n ğ•œ).ker = âŠ¤ := by
  simp [ker]

@[simp]
theorem ker_one : (1 : HermitianMat n ğ•œ).ker = âŠ¥ := by
  simp [ker]; rfl

/-- The support of a Hermitian matrix `A` as a submodule of Euclidean space, defined by
`LinearMap.range A.toMat.toEuclideanLin`. Equivalently, the sum of all nonzero eigenspaces. -/
def support : Submodule ğ•œ (EuclideanSpace ğ•œ n) :=
  LinearMap.range A.lin

/-- The support of a Hermitian matrix is the sum of its nonzero eigenspaces. -/
theorem support_eq_sup_eigenspace_nonzero : A.support = â¨† Î¼ â‰  0, A.eigenspace Î¼ := by
  exact A.lin.support_eq_sup_eigenspace_nonzero A.isSymmetric

@[simp]
theorem support_zero : (0 : HermitianMat n ğ•œ).support = âŠ¥ := by
  simp [support]

@[simp]
theorem support_one : (1 : HermitianMat n ğ•œ).support = âŠ¤ := by
  simpa [support] using LinearMap.ker_eq_bot_iff_range_eq_top.mp rfl

@[simp]
theorem ker_orthogonal_eq_support : A.kerá—® = A.support := by
  rw [ker, support]
  convert ContinuousLinearMap.orthogonal_ker A.lin
  simp

@[simp]
theorem support_orthogonal_eq_range : A.supportá—® = A.ker := by
  rw [ker, support]
  convert ContinuousLinearMap.orthogonal_range A.lin
  simp

end eigenspace

section diagonal

--TODO: Generalize this more types than â„/â„‚
def diagonal [DecidableEq n] (f : n â†’ â„) : HermitianMat n â„‚ :=
  âŸ¨Matrix.diagonal (f Â·),
    by simp [selfAdjoint.mem_iff, Matrix.star_eq_conjTranspose, Matrix.diagonal_conjTranspose]âŸ©

theorem diagonal_conj_diagonal [Fintype n] [DecidableEq n] (f g : n â†’ â„) :
    (diagonal f).conj (diagonal g) =
    diagonal (fun i â†¦ f i * (g i)^2) := by
  simp [diagonal, conj]
  intro
  ring

end diagonal

section kronecker
open Kronecker

variable [CommRing Î±] [StarRing Î±]

/-- The kronecker product of two HermitianMats, see `Matrix.kroneckerMap`. -/
@[simps]
def kronecker (A : HermitianMat m Î±) (B : HermitianMat n Î±) : HermitianMat (m Ã— n) Î± where
  val := A.toMat âŠ—â‚– B.toMat
  property := Matrix.kroneckerMap_IsHermitian A.H B.H

@[inherit_doc HermitianMat.kronecker]
scoped[HermitianMat] infixl:100 " âŠ—â‚– " => HermitianMat.kronecker

@[simp]
theorem zero_kronecker (A : HermitianMat m Î±) : (0 : HermitianMat n Î±) âŠ—â‚– A = 0 := by
  ext1; simp

@[simp]
theorem kronecker_zero (A : HermitianMat m Î±) : A âŠ—â‚– (0 : HermitianMat n Î±) = 0 := by
  ext1; simp

variable [DecidableEq m] [DecidableEq n] [Fintype m] [Fintype n] in
@[simp]
theorem kronecker_one_one : (1 : HermitianMat m Î±) âŠ—â‚– (1 : HermitianMat n Î±) = 1 := by
  ext1; simp

variable (A B : HermitianMat m Î±) (C : HermitianMat n Î±) in
theorem add_kronecker : (A + B) âŠ—â‚– C = A âŠ—â‚– C + B âŠ—â‚– C := by
  ext1; simp [Matrix.add_kronecker]

variable (A : HermitianMat m Î±) (B C : HermitianMat n Î±) in
theorem kronecker_add : A âŠ—â‚– (B + C) = A âŠ—â‚– B + A âŠ—â‚– C := by
  ext1; simp [Matrix.kronecker_add]

end kronecker


================================================================================
FILE: QuantumInfo/ForMathlib/HermitianMat/CFC.lean
TYPE: Lean 4
SIZE: 21393 characters
================================================================================

import QuantumInfo.ForMathlib.HermitianMat.Inner
import QuantumInfo.ForMathlib.Isometry

import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Continuity
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic
import Mathlib.Analysis.CStarAlgebra.CStarMatrix
import Mathlib.Algebra.Order.Group.Pointwise.CompleteLattice

/-! Matrix operations on HermitianMats with the CFC -/

--PULLOUT
namespace Matrix

open ComplexOrder in
theorem IsHermitian.spectrum_subset_Ici_of_sub {d ğ•œ : Type*} [Fintype d] [DecidableEq d] [RCLike ğ•œ]
  {A x: Matrix d d ğ•œ} (hA : A.IsHermitian) (hl : (x - A).PosSemidef) :
    spectrum â„ x âŠ† Set.Ici (â¨… i, hA.eigenvalues i) := by
  --Thanks Aristotle
  intro Î¼ hÎ¼
  obtain âŸ¨v, hvâ‚, hvâ‚‚âŸ© : âˆƒ v : d â†’ ğ•œ, v â‰  0 âˆ§ x.mulVec v = Î¼ â€¢ v := by
    have h_singular : âˆƒ v : d â†’ ğ•œ, v â‰  0 âˆ§ (Î¼ â€¢ 1 - x).mulVec v = 0 := by
      simp only [spectrum.mem_iff, Matrix.isUnit_iff_isUnit_det, isUnit_iff_ne_zero, ne_eq, Decidable.not_not] at hÎ¼
      convert Matrix.exists_mulVec_eq_zero_iff.mpr hÎ¼;
      simp [Algebra.smul_def]
    refine h_singular.imp fun v h â†¦ âŸ¨h.left, ?_âŸ©
    simp_all [Matrix.sub_mulVec, sub_eq_iff_eq_add, funext_iff, Matrix.mulVec, dotProduct, Matrix.one_apply]
  -- Since $x - A$ is positive semidefinite, for any eigenvalue $\lambda$ of $x$, we have $\lambda \geq \min(\text{eigenvalues of } A)$.
  have h_lower_bound : âˆ€ (v : d â†’ ğ•œ), v â‰  0 â†’ (star v â¬áµ¥ (x.mulVec v)) â‰¥ (â¨… i, (hA.eigenvalues i)) * (star v â¬áµ¥ v) := by
    intro v hv_nonzero
    have h_eigenvalue : (star v â¬áµ¥ (A.mulVec v)) â‰¥ (â¨… i, (hA.eigenvalues i)) * (star v â¬áµ¥ v) := by
      have h_expand : (star v â¬áµ¥ (A.mulVec v)) = âˆ‘ i, (hA.eigenvalues i) * (star (hA.eigenvectorBasis i) â¬áµ¥ v) * (star v â¬áµ¥ (hA.eigenvectorBasis i)) := by
        change (star v â¬áµ¥ (A.mulVec v)) = âˆ‘ i, (hA.eigenvalues i) * (star (hA.eigenvectorBasis i) â¬áµ¥ v) * (star v â¬áµ¥ (hA.eigenvectorBasis i))
        have h_decomp : A = âˆ‘ i, (hA.eigenvalues i) â€¢ (Matrix.of (fun j k => (hA.eigenvectorBasis i j) * (star (hA.eigenvectorBasis i k)))) := by
          convert Matrix.IsHermitian.spectral_theorem hA using 1;
          ext i j
          simp only [RCLike.star_def, Matrix.smul_of, Matrix.sum_apply, Matrix.of_apply,
            Pi.smul_apply, Matrix.diagonal, Function.comp_apply, Matrix.mul_apply,
            Matrix.IsHermitian.eigenvectorUnitary_apply, PiLp.ofLp_apply, mul_ite, mul_zero,
            Finset.sum_ite_eq', Finset.mem_univ, â†“reduceIte, Matrix.star_apply];
          simp [ mul_comm, mul_left_comm, Algebra.smul_def ]
        -- Substitute the decomposition of $A$ into the expression $(star v â¬áµ¥ (A.mulVec v))$.
        have h_subst : (star v â¬áµ¥ (A.mulVec v)) = âˆ‘ i, (hA.eigenvalues i) * (star v â¬áµ¥ (Matrix.mulVec (Matrix.of (fun j k => (hA.eigenvectorBasis i j) * (star (hA.eigenvectorBasis i k)))) v)) := by
          -- Substitute the decomposition of $A$ into the expression $(star v â¬áµ¥ (A.mulVec v))$ and use the linearity of matrix multiplication.
          have h_subst : (star v â¬áµ¥ (A.mulVec v)) = (star v â¬áµ¥ ((âˆ‘ i, (hA.eigenvalues i) â€¢ (Matrix.of (fun j k => (hA.eigenvectorBasis i j) * (star (hA.eigenvectorBasis i k))))).mulVec v)) := by
            rw [ â† h_decomp ];
          -- By the linearity of matrix multiplication and the dot product, we can distribute the sum over the dot product.
          have h_distribute : (star v â¬áµ¥ (âˆ‘ i, (hA.eigenvalues i) â€¢ (Matrix.of (fun j k => (hA.eigenvectorBasis i j) * (star (hA.eigenvectorBasis i k))))).mulVec v) = âˆ‘ i, (star v â¬áµ¥ ((hA.eigenvalues i) â€¢ (Matrix.of (fun j k => (hA.eigenvectorBasis i j) * (star (hA.eigenvectorBasis i k))))).mulVec v) := by
            -- By the linearity of matrix multiplication and the dot product, we can distribute the sum over the dot product. This follows from the fact that matrix multiplication is linear.
            have h_distribute : âˆ€ (M N : Matrix d d ğ•œ) (v : d â†’ ğ•œ), Star.star v â¬áµ¥ (M + N).mulVec v = Star.star v â¬áµ¥ M.mulVec v + Star.star v â¬áµ¥ N.mulVec v := by
              simp [ Matrix.add_mulVec, dotProduct_add ];
            -- By induction on the number of terms in the sum, we can apply the distributive property repeatedly.
            have h_induction : âˆ€ (n : â„•) (M : Fin n â†’ Matrix d d ğ•œ) (v : d â†’ ğ•œ), Star.star v â¬áµ¥ (âˆ‘ i, M i).mulVec v = âˆ‘ i, Star.star v â¬áµ¥ (M i).mulVec v := by
              intro n M v; induction' n with n ih <;> simp [ Fin.sum_univ_succ, * ] ;
            convert h_induction ( Fintype.card d ) ( fun i => Matrix.of ( hA.eigenvalues ( Fintype.equivFin d |>.symm i ) â€¢ fun j k => hA.eigenvectorBasis ( Fintype.equivFin d |>.symm i ) j * starRingEnd ğ•œ ( hA.eigenvectorBasis ( Fintype.equivFin d |>.symm i ) k ) ) ) v using 1;
            Â· rw [ â† Equiv.sum_comp ( Fintype.equivFin d ) ];
              simp [ Fintype.equivFin ];
            Â· rw [ â† Equiv.sum_comp ( Fintype.equivFin d ) ];
              simp [ Fintype.equivFin ];
          convert h_distribute using 1;
          simp only [dotProduct, Pi.star_apply, RCLike.star_def, Matrix.mulVec, Matrix.of_apply,
            Finset.mul_sum _ _ _, Matrix.smul_apply, Algebra.smul_mul_assoc,
            Algebra.mul_smul_comm];
          simp [ Algebra.smul_def ];
        convert h_subst using 2;
        simp only [dotProduct, Pi.star_apply, RCLike.star_def, mul_comm, mul_assoc, Matrix.mulVec,
          Matrix.of_apply, mul_eq_mul_left_iff, map_eq_zero];
        simp [ mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ];
      -- Since $\lambda_i \geq \inf(\text{eigenvalues of } A)$ for all $i$, we can bound each term in the sum.
      have h_bound : âˆ€ i, (hA.eigenvalues i) * (star (hA.eigenvectorBasis i) â¬áµ¥ v) * (star v â¬áµ¥ (hA.eigenvectorBasis i)) â‰¥ (â¨… i, (hA.eigenvalues i)) * (star (hA.eigenvectorBasis i) â¬áµ¥ v) * (star v â¬áµ¥ (hA.eigenvectorBasis i)) := by
        intro i
        have h_eigenvalue_bound : (hA.eigenvalues i) â‰¥ (â¨… i, (hA.eigenvalues i)) :=
          ciInf_le (Set.finite_range _).bddBelow _
        -- Since the product of the inner products is real and non-negative, multiplying both sides of the inequality by this product preserves the inequality.
        have h_nonneg : 0 â‰¤ (star (hA.eigenvectorBasis i) â¬áµ¥ v) * (star v â¬áµ¥ (hA.eigenvectorBasis i)) := by
          -- Since the inner product is conjugate symmetric, we have star v â¬áµ¥ (hA.eigenvectorBasis i) = conjugate(star (hA.eigenvectorBasis i) â¬áµ¥ v).
          have h_conj_symm : star v â¬áµ¥ (hA.eigenvectorBasis i) = star (star (hA.eigenvectorBasis i) â¬áµ¥ v) := by
            simp [ dotProduct, mul_comm];
          rw [ h_conj_symm ];
          exact mul_star_self_nonneg (star (hA.eigenvectorBasis i) â¬áµ¥ v);
        norm_num [ mul_assoc ];
        exact mul_le_mul_of_nonneg_right ( mod_cast h_eigenvalue_bound ) h_nonneg;
      -- Since $\sum_{i} (star (hA.eigenvectorBasis i) â¬áµ¥ v) * (star v â¬áµ¥ (hA.eigenvectorBasis i)) = star v â¬áµ¥ v$, we can factor out $(â¨… i, (hA.eigenvalues i))$ from the sum.
      have h_sum : âˆ‘ i, (star (hA.eigenvectorBasis i) â¬áµ¥ v) * (star v â¬áµ¥ (hA.eigenvectorBasis i)) = star v â¬áµ¥ v := by
        have h_sum : âˆ‘ i, (star (hA.eigenvectorBasis i) â¬áµ¥ v) â€¢ (hA.eigenvectorBasis i) = v := by
          have := hA.eigenvectorBasis.sum_repr v;
          convert this using 1;
          simp only [dotProduct, Pi.star_apply, RCLike.star_def, mul_comm,
            hA.eigenvectorBasis.repr_apply_apply, PiLp.inner_apply, RCLike.inner_apply];
        -- Taking the inner product of both sides of h_sum with star v, we get the desired equality.
        have h_inner : star v â¬áµ¥ (âˆ‘ i, (star (hA.eigenvectorBasis i) â¬áµ¥ v) â€¢ (hA.eigenvectorBasis i)) = star v â¬áµ¥ v := by
          rw [h_sum];
        convert h_inner using 1;
        simp [ dotProduct, Finset.mul_sum _ _ _ ];
        exact Finset.sum_comm.trans ( Finset.sum_congr rfl fun _ _ => Finset.sum_congr rfl fun _ _ => by ring );
      rw [ h_expand ];
      refine' le_trans _ ( Finset.sum_le_sum fun i _ => h_bound i );
      simp only [ mul_assoc];
      rw [ â† Finset.mul_sum _ _ _, h_sum ];
    have := hl.2 v; simp_all [ Matrix.sub_mulVec ] ;
    exact le_trans h_eigenvalue this;
  change (â¨… i, hA.eigenvalues i) â‰¤ Î¼
  have := h_lower_bound v hvâ‚
  simp_all only [ne_eq, star, RCLike.star_def, Matrix.dotProduct_mulVec, ge_iff_le,
    dotProduct_smul];
  simp_all only [dotProduct, mul_comm, RCLike.mul_conj];
  rw [ Algebra.smul_def ] at this;
  -- Since the sum of the squares of the norms of v is positive, we can divide both sides of the inequality by it.
  have h_sum_pos : 0 < âˆ‘ x : d, (â€–v xâ€– : â„) ^ 2 := by
    contrapose! hvâ‚;
    simp_all only [funext_iff, Pi.zero_apply, not_forall, forall_exists_index, Matrix.mulVec, Pi.smul_apply]
    intro i
    rw [â† norm_eq_zero]
    simpa [ sq_nonneg ] using le_antisymm ( le_trans ( Finset.single_le_sum ( fun a _ => sq_nonneg ( â€–v aâ€– ) ) ( Finset.mem_univ i ) ) hvâ‚ ) ( sq_nonneg ( â€–v iâ€– ) )
  norm_cast at this;
  nlinarith

open ComplexOrder in
theorem IsHermitian.spectrum_subset_Iic_of_sub {d ğ•œ : Type*} [Fintype d] [DecidableEq d] [RCLike ğ•œ]
  {A x : Matrix d d ğ•œ} (hA : A.IsHermitian) (hl : (A - x).PosSemidef) :
    spectrum â„ x âŠ† Set.Iic (â¨† i, hA.eigenvalues i) := by
  have h := spectrum_subset_Ici_of_sub hA.neg (x := -x) ?_
  Â· rcases isEmpty_or_nonempty d
    Â· simp
    rw [â† spectrum.neg_eq] at h
    intro Î¼ hÎ¼
    specialize h (Set.neg_mem_neg.mpr hÎ¼)
    rw [â† Set.mem_neg, Set.neg_Ici] at h
    convert h
    rw [iInf, iSup, â† spectrum_real_eq_range_eigenvalues, â† spectrum_real_eq_range_eigenvalues]
    rw [â† spectrum.neg_eq, csInf_neg ?_ (A.finite_real_spectrum.bddAbove), neg_neg]
    exact IsSelfAdjoint.spectrum_nonempty hA
  Â· convert hl using 1
    abel

open ComplexOrder in
theorem IsHermitian.spectrum_subset_of_mem_Icc {d ğ•œ : Type*} [Fintype d] [DecidableEq d] [RCLike ğ•œ]
  {A B x : Matrix d d ğ•œ} (hA : A.IsHermitian) (hB : B.IsHermitian)
  (hl : (x - A).PosSemidef) (hr : (B - x).PosSemidef) :
    spectrum â„ x âŠ† Set.Icc (â¨… i, hA.eigenvalues i) (â¨† i, hB.eigenvalues i) := by
  rw [â† Set.Ici_inter_Iic]
  exact Set.subset_inter (hA.spectrum_subset_Ici_of_sub hl) (hB.spectrum_subset_Iic_of_sub hr)

end Matrix

namespace HermitianMat

noncomputable section CFC

macro "herm_cont":term => `(term|
  by simp only [continuousOn_iff_continuous_restrict, continuous_of_discreteTopology])

variable {d dâ‚‚ ğ•œ : Type*} [Fintype d] [DecidableEq d] [Fintype dâ‚‚] [DecidableEq dâ‚‚] [RCLike ğ•œ]

@[simp]
theorem conjTranspose_cfc (A : HermitianMat d ğ•œ) (f : â„ â†’ â„) :
    (cfc f A.toMat).conjTranspose = cfc f A.toMat := by
  exact cfc_predicate f A.toMat

noncomputable nonrec def cfc (A : HermitianMat d ğ•œ) (f : â„ â†’ â„) : HermitianMat d ğ•œ :=
  âŸ¨cfc f A.toMat, cfc_predicate _ _âŸ©

variable (A : HermitianMat d ğ•œ) (f : â„ â†’ â„) (g : â„ â†’ â„) (r : â„)

@[simp]
theorem cfc_toMat : (cfc A f).toMat = _root_.cfc f A.toMat := by
  rfl

/-- Reindexing a matrix commutes with applying the CFC. -/
@[simp]
theorem cfc_reindex (e : d â‰ƒ dâ‚‚) : cfc (A.reindex e) f = (cfc A f).reindex e := by
  rw [HermitianMat.ext_iff]
  simp only [cfc_toMat, reindex_coe]
  exact Matrix.cfc_reindex f e

--Ensure we get this instance:
/-- info: locallyCompact_of_proper -/
#guard_msgs in
#synth LocallyCompactSpace (HermitianMat d ğ•œ)

--PULLOUT to Inner.lean
--Better name ...
open RealInnerProductSpace in
omit [DecidableEq d] in
theorem inner_eq_trace_mul' (A B : HermitianMat d ğ•œ) :
    âŸªA, BâŸ« = RCLike.re (Matrix.trace (A.toMat * B.toMat)) := by
  exact inner_eq_re_trace A B

@[simp]
theorem norm_one : â€–(1 : HermitianMat d ğ•œ)â€– = âˆš(Fintype.card d : â„) := by
  simp [norm_eq_sqrt_real_inner, inner_eq_trace_mul']

variable {A} in
theorem lt_smul_of_norm_lt {r : â„} (h : â€–Aâ€– â‰¤ r) : A â‰¤ r â€¢ 1 := by
  rcases lt_or_ge r 0 with _ | hr
  Â· have := norm_nonneg A
    order
  rcases isEmpty_or_nonempty d
  Â· exact le_of_subsingleton
  contrapose! h
  -- open ComplexOrder in
  -- rw [le_iff, Matrix.PosSemidef] at h
  -- simp at h
  -- specialize h (r â€¢ 1 - A).H
  -- rcases h with âŸ¨x, hxâŸ©
  -- simp at hx
  sorry

theorem ball_subset_Icc (r : â„) : Metric.ball A r âŠ† Set.Icc (A - r â€¢ 1) (A + r â€¢ 1) := by
  intro x
  simp only [Metric.mem_ball, dist_eq_norm, Set.mem_Icc, tsub_le_iff_right]
  intro h
  constructor
  Â· rw [â† norm_neg] at h
    grw [â† lt_smul_of_norm_lt h.le]
    simp
  Â· grw [â† lt_smul_of_norm_lt h.le]
    simp

section frobenius
--Okay. To get `Continuous.cfc` to play along, we need an `IsometricContinuousFunctionalCalculus`
-- on `Matrix` (because we need a topology, sure). This in turn means we need a choice of norm on
-- matrices. We'll use the Frobenius norm and scope it there.
open Matrix.Norms.Frobenius

--This seems annoying. Matrices aren't a CStarAlgebra when ğ•œ = â„, of course. But if we get super stuck,
--we could just switch this to being only for â„‚ (so that the relevant facts in Mathlib make this easy),
--but this means also specializing a bunch of downtstream stuff.
def _root_.Matrix.instIsometric : IsometricContinuousFunctionalCalculus â„ (Matrix d d ğ•œ) IsSelfAdjoint where
  isometric a ha := by
    intro fâ‚ fâ‚‚
    sorry

scoped[Matrix.Norms.Frobenius] attribute [instance] Matrix.instIsometric

end frobenius

theorem spectrum_subset_of_mem_Icc (A B : HermitianMat d ğ•œ) :
    âˆƒ a b, âˆ€ x, A â‰¤ x âˆ§ x â‰¤ B â†’ spectrum â„ x.toMat âŠ† Set.Icc a b := by
  use â¨… i, A.H.eigenvalues i, â¨† i, B.H.eigenvalues i
  rintro x âŸ¨hl, hrâŸ©
  exact A.H.spectrum