# Lean 4 Code Generation System Prompt (Chunked Version)

You are an expert Lean 4 theorem prover specializing in quantum information theory. Convert natural language prompts into precise Lean 4 code using the Lean-QuantumInfo repository as reference.

## Your Role
Convert natural language descriptions of mathematical concepts, theorems, and proofs into formal Lean 4 code following the exact patterns, definitions, and conventions from the Lean-QuantumInfo repository.

## Key Repository Patterns

### Probability & Distributions
```lean
def Prob := { p : ‚Ñù // 0 ‚â§ p ‚àß p ‚â§ 1 }
def Distribution (Œ± : Type u) [Fintype Œ±] : Type u :=
  { f : Œ± ‚Üí Prob // Finset.sum Finset.univ (fun i ‚Ü¶ (f i : ‚Ñù)) = 1 }
```

### Quantum States
```lean
structure MState (d : Type*) [Fintype d] :=
  m : Matrix d d ‚ÑÇ
  pos : m.PosSemidef
  tr : m.trace = 1

structure Bra (d : ‚Ñï) :=
  vec : Fin d ‚Üí ‚ÑÇ
  normalized' : ‚àë i, ‚Äñvec i‚Äñ^2 = 1
```

### Entropy Functions
```lean
def shannon_entropy (p : Distribution Œ±) : ‚Ñù :=
  -‚àë x, (p.val x).toReal * Real.log (p.val x).toReal

def von_neumann_entropy (œÅ : MState d) : ‚Ñù :=
  -‚àë i, (eigenvalues œÅ.m i).toReal * Real.log (eigenvalues œÅ.m i).toReal
```

## Response Format
1. **Analysis**: Explain the mathematical concept
2. **Lean Code**: Complete implementation with imports
3. **Explanation**: Key components and mathematical meaning
4. **Dependencies**: Required imports and related definitions

## Guidelines
- Use Unicode: `‚Ñù`, `‚Ñï`, `‚ÑÇ`, `‚Üí`, `‚Üî`, `‚àß`, `‚à®`, `‚àÄ`, `‚àÉ`
- Include docstrings: `/-- ... -/`
- Type annotations: `[Fintype Œ±]`, `[DecidableEq Œ±]`
- Use `sorry` for incomplete proofs
- Follow repository naming conventions
- Reference existing definitions when possible

## Repository Content Reference

The following is a portion of the Lean-QuantumInfo repository content. Use this as reference for code generation:

---

eded):
-- #synth Inner ‚Ñù (Matrix (Fin 5) (Fin 5) ‚Ñù)

-- end frobenius_inner_product

section partial_trace

variable [AddCommMonoid R] [Fintype d]

def traceLeft (m : Matrix (d √ó d‚ÇÅ) (d √ó d‚ÇÇ) R) : Matrix d‚ÇÅ d‚ÇÇ R :=
  Matrix.of fun i‚ÇÅ j‚ÇÅ ‚Ü¶ ‚àë i‚ÇÇ, m (i‚ÇÇ, i‚ÇÅ) (i‚ÇÇ, j‚ÇÅ)

def traceRight (m : Matrix (d‚ÇÅ √ó d) (d‚ÇÇ √ó d) R) : Matrix d‚ÇÅ d‚ÇÇ R :=
  Matrix.of fun i‚ÇÇ j‚ÇÇ ‚Ü¶ ‚àë i‚ÇÅ, m (i‚ÇÇ, i‚ÇÅ) (j‚ÇÇ, i‚ÇÅ)

variable [Fintype d‚ÇÅ] [Fintype d‚ÇÇ] in
@[simp]
theorem traceLeft_trace (A : Matrix (d‚ÇÅ √ó d‚ÇÇ) (d‚ÇÅ √ó d‚ÇÇ) R) : A.traceLeft.trace = A.trace := by
  convert (Fintype.sum_prod_type_right _).symm
  rfl

variable [Fintype d‚ÇÅ] [Fintype d‚ÇÇ] in
@[simp]
theorem traceRight_trace (A : Matrix (d‚ÇÅ √ó d‚ÇÇ) (d‚ÇÅ √ó d‚ÇÇ) R) : A.traceRight.trace = A.trace := by
  convert (Fintype.sum_prod_type _).symm
  rfl

variable [StarAddMonoid R] in
theorem IsHermitian.traceLeft {A : Matrix (d √ó d‚ÇÅ) (d √ó d‚ÇÅ) R} (hA : A.IsHermitian) : A.traceLeft.IsHermitian := by
  ext
  simp only [Matrix.traceLeft, conjTranspose_apply, of_apply, star_sum]
  congr!
  exact congrFun‚ÇÇ hA _ _

variable [StarAddMonoid R] in
theorem IsHermitian.traceRight {A : Matrix (d‚ÇÅ √ó d) (d‚ÇÅ √ó d) R} (hA : A.IsHermitian) : A.traceRight.IsHermitian := by
  ext
  simp only [Matrix.traceRight, conjTranspose_apply, of_apply, star_sum]
  congr!
  exact congrFun‚ÇÇ hA _ _

open ComplexOrder

variable {d‚ÇÅ d‚ÇÇ : Type*} {A : Matrix (d‚ÇÅ √ó d‚ÇÇ) (d‚ÇÅ √ó d‚ÇÇ) ùïú}
variable [Fintype d‚ÇÇ] [Fintype d‚ÇÅ]

theorem PosSemidef.traceLeft [DecidableEq d‚ÇÅ] (hA : A.PosSemidef) : A.traceLeft.PosSemidef := by
  constructor
  ¬∑ exact hA.1.traceLeft
  ¬∑ intro x
    convert Finset.sum_nonneg' (s := .univ) (fun (i : d‚ÇÅ) ‚Ü¶ hA.2 (fun (j,k) ‚Ü¶ if i = j then x k else 0))
    simp_rw [Matrix.traceLeft, dotProduct_mulVec]
    simpa [dotProduct, vecMul_eq_sum, ite_apply, Fintype.sum_prod_type, Finset.mul_sum, Finset.sum_mul,
      apply_ite] using Finset.sum_comm_cycle

theorem PosSemidef.traceRight [DecidableEq d‚ÇÇ] (hA : A.PosSemidef) : A.traceRight.PosSemidef := by
  constructor
  ¬∑ exact hA.1.traceRight
  ¬∑ intro x
    convert Finset.sum_nonneg' (s := .univ) (fun (i : d‚ÇÇ) ‚Ü¶ hA.2 (fun (j,k) ‚Ü¶ if i = k then x j else 0))
    simp_rw [Matrix.traceRight, dotProduct_mulVec]
    simpa [dotProduct, vecMul_eq_sum, ite_apply, Fintype.sum_prod_type, Finset.mul_sum, Finset.sum_mul,
      apply_ite] using Finset.sum_comm_cycle

end partial_trace

section posdef

open ComplexOrder
open Kronecker

theorem PosDef.kron {d‚ÇÅ d‚ÇÇ ùïú : Type*} [Fintype d‚ÇÅ] [DecidableEq d‚ÇÅ] [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ] [RCLike ùïú]
    {A : Matrix d‚ÇÅ d‚ÇÅ ùïú} {B : Matrix d‚ÇÇ d‚ÇÇ ùïú} (hA : A.PosDef) (hB : B.PosDef) : (A ‚äó‚Çñ B).PosDef := by
  rw [hA.left.spectral_theorem, hB.left.spectral_theorem]
  rw [mul_kronecker_mul, mul_kronecker_mul]
  rw [star_eq_conjTranspose, star_eq_conjTranspose]
  rw [‚Üê kroneckerMap_conjTranspose]
  rw [diagonal_kronecker_diagonal]
  apply mul_mul_conjTranspose_same
  ¬∑ rw [posDef_diagonal_iff]
    rintro ‚ü®i‚ÇÅ, i‚ÇÇ‚ü©
    convert mul_pos (hA.eigenvalues_pos i‚ÇÅ) (hB.eigenvalues_pos i‚ÇÇ)
    rw [RCLike.pos_iff]
    simp
  ¬∑ apply Matrix.vecMul_injective_of_isUnit
    rw [isUnit_iff_exists]
    use (star hA.left.eigenvectorUnitary.val) ‚äó‚Çñ (star hB.left.eigenvectorUnitary.val)
    simp [‚Üê Matrix.mul_kronecker_mul]

theorem PosDef.submatrix {d‚ÇÅ d‚ÇÇ ùïú : Type*} [Fintype d‚ÇÅ] [DecidableEq d‚ÇÅ] [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ] [RCLike ùïú]
    {M : Matrix d‚ÇÅ d‚ÇÅ ùïú} (hM : M.PosDef) {e : d‚ÇÇ ‚Üí d‚ÇÅ} (he : Function.Injective e) : (M.submatrix e e).PosDef := by
  use hM.left.submatrix e
  intro x hx
  let y : d‚ÇÅ ‚Üí ùïú := fun i ‚Ü¶ ‚àë j ‚àà { j | e j = i}, x j
  have hy : y ‚â† 0 := by
    contrapose! hx
    simp only [funext_iff] at hx ‚ä¢
    intro i
    simpa [y, he.eq_iff, Finset.sum_eq_single_of_mem] using hx (e i)
  convert hM.right y hy
  dsimp [Matrix.mulVec, dotProduct, y]
  simp only [map_sum]
  simp only [Finset.sum_mul, Finset.sum_filter, Finset.mul_sum]
  simp [‚Üê Finset.mul_sum, Finset.sum_comm]

theorem PosDef.reindex {d‚ÇÅ d‚ÇÇ ùïú : Type*} [Fintype d‚ÇÅ] [DecidableEq d‚ÇÅ] [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ] [RCLike ùïú]
    {M : Matrix d‚ÇÅ d‚ÇÅ ùïú} (hM : M.PosDef) (e : d‚ÇÅ ‚âÉ d‚ÇÇ) : (M.reindex e e).PosDef :=
  hM.submatrix e.symm.injective

@[simp]
theorem PosDef.reindex_iff {d‚ÇÅ d‚ÇÇ ùïú : Type*} [Fintype d‚ÇÅ] [DecidableEq d‚ÇÅ] [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ] [RCLike ùïú]
    {M : Matrix d‚ÇÅ d‚ÇÅ ùïú} (e : d‚ÇÅ ‚âÉ d‚ÇÇ) : (M.reindex e e).PosDef ‚Üî M.PosDef := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ h.reindex e‚ü©
  convert h.reindex e.symm
  simp

theorem PosSemidef.rsmul {n : Type*} [Fintype n] {M : Matrix n n ‚ÑÇ} (hM : M.PosSemidef) {c : ‚Ñù} (hc : 0 ‚â§ c) :
    (c ‚Ä¢ M).PosSemidef := by
  constructor
  ¬∑ exact hM.1.smul_real c
  ¬∑ peel hM.2
    rw [smul_mulVec, dotProduct_smul]
    positivity

theorem PosDef.Convex {n : Type*} [Fintype n] : Convex ‚Ñù (Matrix.PosDef (n := n) (R := ‚ÑÇ)) := by
  intro A hA B hB a b ha hb hab
  rcases ha.eq_or_lt with (rfl | ha)
  ¬∑ simp_all
  rcases hb.eq_or_lt with (rfl | hb)
  ¬∑ simp_all
  exact (hA.smul ha).add (hB.smul hb)

end posdef

section eigenvalues

open ComplexOrder

variable {d ùïú : Type*} [Fintype d] [DecidableEq d] [RCLike ùïú]

theorem PosDef_iff_eigenvalues' (M : Matrix d d ùïú) :
    M.PosDef ‚Üî ‚àÉ (h : M.IsHermitian), ‚àÄ i, 0 < h.eigenvalues i :=
  ‚ü®fun h ‚Ü¶ ‚ü®h.left, h.left.posDef_iff_eigenvalues_pos.mp h‚ü©,
    fun ‚ü®w, h‚ü© ‚Ü¶ w.posDef_iff_eigenvalues_pos.mpr h‚ü©

--PR'ed: #27118
theorem IsHermitian.charpoly_roots_eq_eigenvalues {M : Matrix d d ùïú} (hM : M.IsHermitian) :
    M.charpoly.roots = Multiset.map (RCLike.ofReal ‚àò hM.eigenvalues) Finset.univ.val := by
  -- Since M is Hermitian, its characteristic polynomial splits into linear factors over the reals.
  have h_split : M.charpoly = Multiset.prod (Multiset.map (fun (e : ‚Ñù) => Polynomial.X - Polynomial.C (RCLike.ofReal e)) (Multiset.map (fun (i : d) => hM.eigenvalues i) Finset.univ.val)) := by
    -- Since M is Hermitian, it is diagonalizable, and its characteristic polynomial splits into linear factors over the reals.
    have h_diag : ‚àÉ P : Matrix d d ùïú, P.det ‚â† 0 ‚àß ‚àÉ D : Matrix d d ùïú, D = Matrix.diagonal (fun i => RCLike.ofReal (hM.eigenvalues i)) ‚àß M = P * D * P‚Åª¬π := by
      have := hM.spectral_theorem;
      refine' ‚ü® hM.eigenvectorUnitary, _, _ ‚ü©
      ¬∑ -- Since the eigenvector unitary is a unitary matrix, its determinant is a unit, hence non-zero.
        have h_det_unitary : IsUnit (Matrix.det (hM.eigenvectorUnitary : Matrix d d ùïú)) := by
          exact UnitaryGroup.det_isUnit hM.eigenvectorUnitary
        exact h_det_unitary.ne_zero
      ¬∑ refine' ‚ü® _, rfl, this.trans _ ‚ü©
        rw [ Matrix.inv_eq_left_inv ]
        congr!
        bound
    -- Since M is similar to D, their characteristic polynomials are the same.
    have h_char_poly : M.charpoly = Matrix.charpoly (Matrix.diagonal (fun i => RCLike.ofReal (hM.eigenvalues i))) := by
      rcases h_diag with ‚ü®P, left, ‚ü®D, left_1, rfl‚ü©‚ü©
      rw [ ‚Üê left_1, Matrix.charpoly, Matrix.charpoly ];
      simp +decide [ Matrix.charmatrix, Matrix.mul_assoc ];
      -- Since $w$ is invertible, we can simplify the determinant.
      have h_inv : (P.map (‚áëPolynomial.C : ùïú ‚Üí Polynomial ùïú)) * (P‚Åª¬π.map (‚áëPolynomial.C : ùïú ‚Üí Polynomial ùïú)) = 1 := by
        simp [ ‚Üê Matrix.map_mul, left ];
      -- Since $w$ is invertible, we can simplify the determinant using the fact that the determinant of a product is the product of the determinants.
      have h_det_prod : Matrix.det ((Matrix.diagonal (fun _ => Polynomial.X) - P.map (‚áëPolynomial.C : ùïú ‚Üí Polynomial ùïú) * (D.map (‚áëPolynomial.C : ùïú ‚Üí Polynomial ùïú) * P‚Åª¬π.map (‚áëPolynomial.C : ùïú ‚Üí Polynomial ùïú)))) = Matrix.det ((P.map (‚áëPolynomial.C : ùïú ‚Üí Polynomial ùïú)) * (Matrix.diagonal (fun _ => Polynomial.X) - D.map (‚áëPolynomial.C : ùïú ‚Üí Polynomial ùïú)) * (P‚Åª¬π.map (‚áëPolynomial.C : ùïú ‚Üí Polynomial ùïú))) := by
        simp only [ mul_sub, sub_mul, Matrix.mul_assoc ];
        -- Since Matrix.diagonal (fun _ => Polynomial.X) is a scalar matrix, it commutes with any matrix.
        have h_comm : Matrix.diagonal (fun _ => Polynomial.X) * P‚Åª¬π.map Polynomial.C = P‚Åª¬π.map Polynomial.C * Matrix.diagonal (fun _ => Polynomial.X) := by
          ext i j; by_cases hi : i = j <;> simp [ hi ];
        simp only [ h_comm ];
        simp [ ‚Üê mul_assoc, h_inv ];
      rw [ h_det_prod, Matrix.det_mul, Matrix.det_mul ];
      -- Since the determinant of the product of two matrices is the product of their determinants, and the determinant of the identity matrix is 1, we have:
      have h_det_identity : Matrix.det (P.map (‚áëPolynomial.C : ùïú ‚Üí Polynomial ùïú)) * Matrix.det (P‚Åª¬π.map (‚áëPolynomial.C : ùïú ‚Üí Polynomial ùïú)) = 1 := by
        rw [ ‚Üê Matrix.det_mul, h_inv, Matrix.det_one ];
      rw [ mul_right_comm, h_det_identity, one_mul ];
    rw [h_char_poly];
    simp [ Matrix.charpoly, Matrix.det_diagonal ];
  rw [ h_split, Polynomial.roots_multiset_prod ];
  -- Case 1
  ¬∑ erw [ Multiset.bind_map ];
    aesop;
  -- Case 2
  ¬∑ -- Since the eigenvalues are real, and we're working over the complex numbers (since ùïú is a real closed field), the polynomial X - C(e) would be zero only if e is zero. But if e is zero, then the polynomial would be X, which isn't zero. So 0 can't be in the multiset.
    simp [Polynomial.X_sub_C_ne_zero]

--These two are disgusting atm. There's cleaner versions of them headed to Mathlib. See #29526 and follow-ups
lemma _root_.Multiset.map_univ_eq_iff {Œ± Œ≤ : Type*} [Fintype Œ±] [DecidableEq Œ≤] (f g : Œ± ‚Üí Œ≤) :
    Multiset.map f Finset.univ.val = Multiset.map g Finset.univ.val ‚Üî ‚àÉ (e : Œ± ‚âÉ Œ±), f = g ‚àò e := by
  apply Iff.intro
  ¬∑ intro a
    -- Since these two multisets are equal, their elements must be equal up to permutation.
    have h_perm : ‚àÉ e : Œ± ‚âÉ Œ±, ‚àÄ x, f x = g (e x) := by
      have h_count_eq : ‚àÄ y : Œ≤, Finset.card (Finset.filter (fun x => f x = y) Finset.univ) = Finset.card (Finset.filter (fun x => g x = y) Finset.univ) := by
        intro y;
        replace a := congr_arg ( fun m => m.count y ) a;
        simp_all ( config := { decide := Bool.true } ) [ Multiset.count_map ];
        simpa [ eq_comm, Finset.filter_congr ] using a;
      have h_perm : ‚àÄ y : Œ≤, ‚àÉ e : { x : Œ± // f x = y } ‚âÉ { x : Œ± // g x = y }, True := by
        intro y
        simp_all only [exists_const_iff, and_true]
        exact ‚ü® Fintype.equivOfCardEq <| by simpa [ Fintype.card_subtype ] using h_count_eq y ‚ü©;
      choose e he using h_perm;
      refine' ‚ü® _, _ ‚ü©;
      exact ( Equiv.sigmaFiberEquiv f ).symm.trans ( Equiv.sigmaCongrRight e ) |> Equiv.trans <| Equiv.sigmaFiberEquiv g;
      intro x
      specialize e ( f x )
      rename_i e_1
      simp_all only [implies_true, Equiv.trans_apply, Equiv.sigmaCongrRight_apply,
        Equiv.sigmaFiberEquiv_symm_apply_fst, Equiv.sigmaFiberEquiv_apply]
      exact Eq.symm ( e_1 ( f x ) ‚ü® x, rfl ‚ü© |>.2 );
    exact ‚ü® h_perm.choose, funext h_perm.choose_spec ‚ü©;
  ¬∑ intro a
    obtain ‚ü®w, h‚ü© := a
    subst h
    simp_all only [Function.comp_apply, Finset.univ]
    -- Since $w$ is a bijection, the multiset of $w(x)$ for $x$ in the original multiset is just a permutation of the original multiset.
    have h_perm : Multiset.map (fun x => w x) (Finset.val Fintype.elems) = Finset.val Fintype.elems := by
      exact Multiset.map_univ_val_equiv w;
    conv_rhs => rw [ ‚Üê h_perm ];
    simp +zetaDelta at *

theorem IsHermitian.cfc_eigenvalues {M : Matrix d d ùïú} (hM : M.IsHermitian) (f : ‚Ñù ‚Üí ‚Ñù) :
    ‚àÉ (e : d ‚âÉ d), Matrix.IsHermitian.eigenvalues (cfc_predicate f M) = f ‚àò hM.eigenvalues ‚àò e := by
  have h_eigenvalues : Multiset.map hM.eigenvalues Finset.univ.val = Multiset.map (fun i => hM.eigenvalues i) Finset.univ.val := by
    rfl
  generalize_proofs at *;
  have h_eigenvalues_cfc : (IsHermitian.cfc hM f).charpoly.roots = Multiset.map (fun i => (f (hM.eigenvalues i) : ùïú)) Finset.univ.val := by
    rw [ Matrix.IsHermitian.cfc, Matrix.charpoly ];
    -- Since $U$ is unitary, we have $U^* U = I$, and thus the characteristic polynomial of $U D U^*$ is the same as the characteristic polynomial of $D$.
    have h_charpoly : Matrix.det ((hM.eigenvectorUnitary : Matrix d d ùïú) * Matrix.diagonal (RCLike.ofReal ‚àò f ‚àò hM.eigenvalues) * Star.star (hM.eigenvectorUnitary : Matrix d d ùïú)).charmatrix = Matrix.det (Matrix.diagonal (RCLike.ofReal ‚àò f ‚àò hM.eigenvalues)).charmatrix := by
      -- Since $U$ is unitary, we have $U^* U = I$, and thus the characteristic polynomial of $U D U^*$ is the same as the characteristic polynomial of $D$ by the properties of determinants.
      have h_char_poly : ‚àÄ (t : ùïú), Matrix.det (t ‚Ä¢ 1 - (hM.eigenvectorUnitary : Matrix d d ùïú) * Matrix.diagonal (RCLike.ofReal ‚àò f ‚àò hM.eigenvalues) * star (hM.eigenvectorUnitary : Matrix d d ùïú)) = Matrix.det (t ‚Ä¢ 1 - Matrix.diagonal (RCLike.ofReal ‚àò f ‚àò hM.eigenvalues)) := by
        intro t;
        -- Since $U$ is unitary, we have $U^* U = I$, and thus the determinant of $tI - UDU^*$ is the same as the determinant of $tI - D$.
        have h_det : Matrix.det (t ‚Ä¢ 1 - (hM.eigenvectorUnitary : Matrix d d ùïú) * Matrix.diagonal (RCLike.ofReal ‚àò f ‚àò hM.eigenvalues) * star (hM.eigenvectorUnitary : Matrix d d ùïú)) = Matrix.det ((hM.eigenvectorUnitary : Matrix d d ùïú) * (t ‚Ä¢ 1 - Matrix.diagonal (RCLike.ofReal ‚àò f ‚àò hM.eigenvalues)) * star (hM.eigenvectorUnitary : Matrix d d ùïú)) := by
          simp [ mul_sub, sub_mul, mul_assoc ];
        rw [ h_det, Matrix.det_mul, Matrix.det_mul ];
        rw [ mul_right_comm, ‚Üê Matrix.det_mul, mul_comm ];
        norm_num +zetaDelta at *;
      refine' Polynomial.funext fun t => _;
      convert h_char_poly t using 1;
      ¬∑ simp [ Matrix.det_apply', Polynomial.eval_finset_sum ];
        simp [ Matrix.one_apply, Polynomial.eval_prod ];
        congr! 3;
        aesop;
      ¬∑ simp [ Matrix.det_apply', Polynomial.eval_finset_sum ];
        simp [ Matrix.one_apply, Polynomial.eval_prod ];
        exact Finset.sum_congr rfl fun _ _ => by congr; ext; aesop;
    simp_all [ Matrix.charmatrix, Matrix.det_diagonal ];
    rw [ Polynomial.roots_prod ];
    ¬∑ bound;
    ¬∑ exact Finset.prod_ne_zero_iff.mpr fun i _ => Polynomial.X_sub_C_ne_zero _;
  have := IsHermitian.charpoly_roots_eq_eigenvalues (cfc_predicate f M);
  rw [‚Üê Matrix.IsHermitian.cfc_eq] at h_eigenvalues_cfc
  rw [ h_eigenvalues_cfc ] at this;
  simp [ Function.comp ] at this;
  rw [ Multiset.map_univ_eq_iff ] at this;
  obtain ‚ü® e, he ‚ü© := this;
  use e.symm
  ext x
  have := congr_fun he ( e.symm x );
  simp_all only [Function.comp_apply, Equiv.apply_symm_apply, algebraMap.coe_inj]

end eigenvalues

section

variable {Œ± n : Type*} [RCLike Œ±] [Fintype n] [DecidableEq n]

@[simp]
theorem toEuclideanLin_one : Matrix.toEuclideanLin (1 : Matrix n n Œ±) = .id := by
  ext1 x
  simp [Matrix.toEuclideanLin]

end

section more_cfc

open ComplexOrder

variable {d ùïú : Type*} [Fintype d] [DecidableEq d] [RCLike ùïú]

@[simp]
theorem cfc_diagonal (g : d ‚Üí ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) :
    cfc f (Matrix.diagonal (fun x ‚Ü¶ (g x : ùïú))) = diagonal (RCLike.ofReal ‚àò f ‚àò g) := by
  --Thanks Aristotle
  have h_self_adjoint : _root_.IsSelfAdjoint (diagonal (fun x => (g x : ùïú))) := by
      change Matrix.conjTranspose _ = _
      simp [Matrix.conjTranspose]
  --TODO cfc_cont_tac
  rw [cfc, dif_pos ‚ü®h_self_adjoint, continuousOn_iff_continuous_restrict.mpr <| by fun_prop‚ü©]
  rw [cfcHom_eq_of_continuous_of_map_id]
  rotate_left
  ¬∑ refine' { .. }
    use fun f ‚Ü¶ Matrix.diagonal fun x ‚Ü¶ f ‚ü®g x, (by
      simpa [algebraMap_eq_diagonal, diagonal_apply] using
        congr_arg (¬∑ x x) ¬∑.exists_left_inv.choose_spec
      )‚ü©
    ¬∑ simp
    ¬∑ simp [diagonal, ‚Üê Matrix.ext_iff, mul_apply]
      grind
    ¬∑ simp
    ¬∑ simp [diagonal, funext_iff]
      grind [add_zero]
    ¬∑ simp [‚Üê ext_iff, diagonal]
      exact fun r i j ‚Ü¶ rfl
    ¬∑ simp [‚Üê ext_iff, diagonal]
      grind [RCLike.conj_ofReal, map_zero]
  ¬∑ dsimp [diagonal]
    continuity
  ¬∑ simp [diagonal]
  ¬∑ simp [diagonal]

theorem PosSemidef.pos_of_mem_spectrum {A : Matrix d d ùïú} (hA : A.PosSemidef) (r : ‚Ñù) :
    r ‚àà spectrum ‚Ñù A ‚Üí 0 ‚â§ r := by
  intro hr
  rw [hA.left.spectrum_real_eq_range_eigenvalues] at hr
  rcases hr with ‚ü®i, rfl‚ü©
  exact hA.eigenvalues_nonneg i

theorem PosSemidef.pow_add {A : Matrix d d ùïú} (hA : A.PosSemidef) {x y : ‚Ñù} (hxy : x + y ‚â† 0) :
    cfc (¬∑ ^ (x + y) : ‚Ñù ‚Üí ‚Ñù) A = cfc (fun r ‚Ü¶ r ^ x * r ^ y : ‚Ñù ‚Üí ‚Ñù) A := by
  refine cfc_congr fun r hr ‚Ü¶ ?_
  exact Real.rpow_add' (hA.pos_of_mem_spectrum r hr) hxy

theorem PosSemidef.pow_mul {A : Matrix d d ùïú} {x y : ‚Ñù} (hA : A.PosSemidef) :
    cfc (¬∑ ^ (x * y) : ‚Ñù ‚Üí ‚Ñù) A = cfc (fun r ‚Ü¶ (r ^ x) ^ y : ‚Ñù ‚Üí ‚Ñù) A := by
  refine cfc_congr fun r hr ‚Ü¶ ?_
  exact Real.rpow_mul (hA.pos_of_mem_spectrum r hr) x y

end more_cfc

section subm

variable {Œ± : Type*} [AddCommMonoid Œ±]
variable {d‚ÇÅ d‚ÇÇ : Type*} [Fintype d‚ÇÅ] [Fintype d‚ÇÇ]

@[simp]
theorem trace_submatrix
  (A : Matrix d‚ÇÅ d‚ÇÅ Œ±) (e : d‚ÇÇ ‚âÉ d‚ÇÅ) :
    (A.submatrix e e).trace = A.trace := by
  simpa [Matrix.trace] using e.sum_comp (fun x ‚Ü¶ A x x)

end subm


================================================================================
FILE: QuantumInfo/ForMathlib/MatrixNorm/TraceNorm.lean
TYPE: Lean 4
SIZE: 4325 characters
================================================================================

import QuantumInfo.ForMathlib.Matrix

open BigOperators
open Classical

namespace Matrix
noncomputable section traceNorm

open scoped ComplexOrder

variable {m n R : Type*}
variable [Fintype m] [Fintype n]
variable [RCLike R]

/-- The trace norm of a matrix: Tr[‚àö(A‚Ä† A)]. -/
def traceNorm (A : Matrix m n R) : ‚Ñù :=
  RCLike.re A.posSemidef_conjTranspose_mul_self.sqrt.trace

/-- The trace norm of the negative is equal to the trace norm. -/
@[simp]
theorem traceNorm_eq_neg_self (A : Matrix m n R) : traceNorm (-A) = traceNorm A := by
  unfold traceNorm
  congr! 3
  rw [Matrix.conjTranspose_neg, Matrix.neg_mul, Matrix.mul_neg]
  exact neg_neg _

--More generally sum of abs of singular values.
--Proposition 9.1.1 in Wilde
theorem traceNorm_Hermitian_eq_sum_abs_eigenvalues {A : Matrix n n R} (hA : A.IsHermitian) :
    A.traceNorm = ‚àë i, abs (hA.eigenvalues i) :=
  sorry --Diagonalize A

/-- The trace norm is nonnegative. Property 9.1.1 in Wilde -/
theorem traceNorm_nonneg (A : Matrix m n R) : 0 ‚â§ A.traceNorm :=
  And.left $ RCLike.nonneg_iff.1
    A.posSemidef_conjTranspose_mul_self.posSemidef_sqrt.trace_nonneg

/-- The trace norm is zero only if the matrix is zero. -/
theorem traceNorm_zero_iff (A : Matrix m n R) : A.traceNorm = 0 ‚Üî A = 0 := by
  constructor
  ¬∑ intro h
    have h‚ÇÇ : ‚àÄ i, A.posSemidef_conjTranspose_mul_self.posSemidef_sqrt.1.eigenvalues i = 0 :=
      sorry --sum of nonnegative values to zero
    have h‚ÇÉ : A.posSemidef_conjTranspose_mul_self.sqrt = 0 :=
      sorry --all eigenvalues are zero iff matrix is zero
    have h‚ÇÑ : A·¥¥ * A = 0 :=
      sorry --sqrt is zero iff matrix is zero
    have h‚ÇÖ : A = 0 :=
      sorry --conj_mul_self is zero iff A is zero
    exact h‚ÇÖ
  ¬∑ intro hA
    subst hA
    have : (0 : Matrix m n R)·¥¥ * (0 : Matrix m n R) = 0 := by simp
    rw [traceNorm, PosSemidef.sqrt_eq this _ Matrix.PosSemidef.zero]
    simp

/-- Trace norm is linear under scalar multiplication. Property 9.1.2 in Wilde -/
theorem traceNorm_smul (A : Matrix m n R) (c : R) : (c ‚Ä¢ A).traceNorm = ‚Äñc‚Äñ * A.traceNorm := by
  have h : (c ‚Ä¢ A)·¥¥ * (c ‚Ä¢ A) = (‚Äñc‚Äñ^2:R) ‚Ä¢ (A·¥¥ * A) := by
    rw [conjTranspose_smul, RCLike.star_def, mul_smul, smul_mul, smul_smul]
    rw [RCLike.mul_conj c]
  rw [traceNorm, PosSemidef.sqrt_eq' h]
  have : RCLike.re (trace (‚Äñc‚Äñ ‚Ä¢ A.posSemidef_conjTranspose_mul_self.sqrt)) = ‚Äñc‚Äñ * traceNorm A := by
    simp [RCLike.smul_re]
    apply Or.inl
    rfl
  convert this
  rw [RCLike.real_smul_eq_coe_smul (K := R) ‚Äñc‚Äñ]
  by_cases h : c = 0
  ¬∑ nth_rewrite 8 [h]
    simp only [norm_zero, algebraMap.coe_zero, zero_smul]
    rw [‚Üê PosSemidef.sqrt_0]
    apply PosSemidef.sqrt_eq
    simp [h]
  ¬∑ apply PosSemidef.sqrt_nonneg_smul _
    rw [RCLike.pos_iff_exists_ofReal]
    use ‚Äñc‚Äñ
    simp [h]

/-- For square matrices, the trace norm is max Tr[U * A] over unitaries U.-/
theorem traceNorm_eq_max_tr_U (A : Matrix n n R) : IsGreatest {x | ‚àÉ (U : unitaryGroup n R), (U.1 * A).trace = x} A.traceNorm := by
  sorry

/-- the trace norm satisfies the triangle inequality (for square matrices). TODO: Prove in general. -/
theorem traceNorm_triangleIneq (A B : Matrix n n R) : (A + B).traceNorm ‚â§ A.traceNorm + B.traceNorm := by
  obtain ‚ü®Uab, h‚ÇÅ‚ü© := (traceNorm_eq_max_tr_U (A + B)).left
  rw [Matrix.mul_add, Matrix.trace_add] at h‚ÇÅ
  obtain h‚ÇÇ := (traceNorm_eq_max_tr_U A).right
  obtain h‚ÇÉ := (traceNorm_eq_max_tr_U B).right
  simp only [upperBounds, Subtype.exists, exists_prop, Set.mem_setOf_eq, forall_exists_index,
    and_imp, forall_apply_eq_imp_iff‚ÇÇ] at h‚ÇÇ h‚ÇÉ
  replace h‚ÇÇ := h‚ÇÇ Uab.1 Uab.2
  replace h‚ÇÉ := h‚ÇÉ Uab.1 Uab.2
  rw [‚Üê RCLike.ofReal_le_ofReal (K := R)]
  simp only [RCLike.ofReal_add]
  calc _
    _ = _ + _ := h‚ÇÅ.symm
    _ ‚â§ ‚Üë(traceNorm A) + trace (‚ÜëUab * B) := by simp only [add_le_add_iff_right]; exact h‚ÇÇ
    _ ‚â§ _ := by simp only [add_le_add_iff_left]; exact h‚ÇÉ

theorem traceNorm_triangleIneq' (A B : Matrix n n R) : (A - B).traceNorm ‚â§ A.traceNorm + B.traceNorm := by
  rw [sub_eq_add_neg A B, ‚ÜêtraceNorm_eq_neg_self B]
  exact traceNorm_triangleIneq A (-B)

theorem PosSemidef.traceNorm_PSD_eq_trace {A : Matrix m m R} (hA : A.PosSemidef) : A.traceNorm = A.trace := by
  have : A·¥¥ * A = A^2 := by rw [hA.1, pow_two]
  rw [traceNorm, Matrix.PosSemidef.sqrt_eq' this, Matrix.PosSemidef.sqrt_sq hA, hA.1.re_trace_eq_trace]

end traceNorm

end Matrix


================================================================================
FILE: QuantumInfo/ForMathlib/Minimax.lean
TYPE: Lean 4
SIZE: 849 characters
================================================================================

import Mathlib.Analysis.Convex.Basic
import Mathlib.Data.Real.Archimedean
import Mathlib.Topology.Algebra.Monoid.Defs
import Mathlib.Topology.Algebra.MulAction
import Mathlib.Topology.Defs.Filter
import Mathlib.Topology.MetricSpace.Pseudo.Defs

/-- The minimax theorem, at the level of generality we need. For convex, compact, nonempty sets `S`
and `T`in a real topological vector space `M`, and a bilinear function `f` on M, we can exchange
the order of minimizing and maximizing. -/
theorem minimax {M : Type*} [AddCommMonoid M] [Module ‚Ñù M] [TopologicalSpace M] [ContinuousAdd M] [ContinuousSMul ‚Ñù M]
  (f : LinearMap.BilinForm ‚Ñù M) (S : Set M) (T : Set M) (hS‚ÇÅ : IsCompact S) (hT‚ÇÅ : IsCompact T)
  (hS‚ÇÇ : Convex ‚Ñù S) (hT‚ÇÇ : Convex ‚Ñù T) (hS‚ÇÉ : S.Nonempty) (hT‚ÇÉ : T.Nonempty)
    : ‚®Ü x : S, ‚®Ö y : T, f x y =  ‚®Ö y : T, ‚®Ü x : S, f x y := by
  sorry


================================================================================
FILE: QuantumInfo/ForMathlib/Minimax_work.lean
TYPE: Lean 4
SIZE: 34637 characters
================================================================================

import Mathlib.Analysis.Convex.PathConnected
import Mathlib.Analysis.Convex.Quasiconvex
import Mathlib.Analysis.Convex.Topology
import Mathlib.Analysis.Normed.Order.Lattice
import Mathlib.Data.Fintype.Order
import Mathlib.Topology.Semicontinuous
import Mathlib.Analysis.SpecificLimits.Basic

@[simp]
theorem Set.image2_flip {Œ± Œ≤ Œ≥ : Type*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (s : Set Œ±) (t : Set Œ≤) :
    image2 (flip f) t s = image2 f s t := by
  grind [image2, flip]

section ciSup

variable {Œπ Œ± : Type*} [ConditionallyCompleteLattice Œ±] {f g : Œπ ‚Üí Œ±} {a : Œ±}

/-- The **max-min theorem**. A version of `iSup_iInf_le_iInf_iSup` for conditionally complete lattices. -/
theorem ciSup_ciInf_le_ciInf_ciSup {Œπ': Type*} [Nonempty Œπ]
  (f : Œπ ‚Üí Œπ' ‚Üí Œ±) (Ha : ‚àÄ j, BddAbove (Set.range (f ¬∑ j))) (Hb : ‚àÄ i, BddBelow (Set.range (f i))) :
    ‚®Ü i, ‚®Ö j, f i j ‚â§ ‚®Ö j, ‚®Ü i, f i j :=
  ciSup_le fun i ‚Ü¶ ciInf_mono (Hb i) fun j ‚Ü¶ le_ciSup (Ha j) i

theorem lt_ciInf_iff {Œ± : Type*} {Œπ : Sort*} [Nonempty Œπ] [ConditionallyCompleteLattice Œ±] {f : Œπ ‚Üí Œ±} {a : Œ±}
    (hf : BddBelow (Set.range f)) :
    a < iInf f ‚Üî ‚àÉ b, a < b ‚àß ‚àÄ (i : Œπ), b ‚â§ f i :=
  ‚ü®(‚ü®iInf f, ¬∑, (ciInf_le hf ¬∑)‚ü©), fun ‚ü®_, hb‚ÇÅ, hb‚ÇÇ‚ü© ‚Ü¶ lt_of_lt_of_le hb‚ÇÅ (le_ciInf hb‚ÇÇ)‚ü©

theorem BddAbove.range_max (hf : BddAbove (Set.range f)) (hg : BddAbove (Set.range g)) :
    BddAbove (Set.range (max f g)) := by
  rcases hf with ‚ü®a, ha‚ü©
  rcases hg with ‚ü®b, hb‚ü©
  use a ‚äî b
  simp only [mem_upperBounds, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff, Pi.sup_apply] at ha hb ‚ä¢
  intro i
  specialize ha i
  specialize hb i
  order

theorem BddBelow.range_min (hf : BddBelow (Set.range f)) (hg : BddBelow (Set.range g)) :
    BddBelow (Set.range (min f g)) :=
  BddAbove.range_max (Œ± := Œ±·µí·µà) hf hg

variable [Nonempty Œπ]

theorem ciSup_sup_eq (hf : BddAbove (Set.range f)) (hg : BddAbove (Set.range g)) : ‚®Ü x, f x ‚äî g x = (‚®Ü x, f x) ‚äî ‚®Ü x, g x :=
  le_antisymm (ciSup_le fun _ => sup_le_sup (le_ciSup hf _) <| le_ciSup hg _)
    (sup_le (ciSup_mono (hf.range_max hg) fun _ => le_sup_left) <| ciSup_mono (hf.range_max hg) fun _ => le_sup_right)

theorem ciInf_inf_eq (hf : BddBelow (Set.range f)) (hg : BddBelow (Set.range g)) : ‚®Ö x, f x ‚äì g x = (‚®Ö x, f x) ‚äì ‚®Ö x, g x :=
  ciSup_sup_eq (Œ± := Œ±·µí·µà) hf hg

theorem sup_ciSup (hf : BddAbove (Set.range f)) : a ‚äî ‚®Ü x, f x = ‚®Ü x, a ‚äî f x := by
  rw [ciSup_sup_eq (by simp) hf, ciSup_const]

theorem inf_ciInf (hf : BddBelow (Set.range f)) : a ‚äì ‚®Ö x, f x = ‚®Ö x, a ‚äì f x :=
  sup_ciSup (Œ± := Œ±·µí·µà) hf

theorem ciInf_sup_ciInf_le (hf : BddBelow (Set.range f)) (hg : BddBelow (Set.range g)) :
    (‚®Ö i, f i) ‚äî ‚®Ö i, g i ‚â§ ‚®Ö i, f i ‚äî g i :=
  le_ciInf (fun i ‚Ü¶ sup_le_sup (ciInf_le hf i) (ciInf_le hg i))

theorem le_ciSup_inf_ciSup (hf : BddAbove (Set.range f)) (hg : BddAbove (Set.range g)) :
    ‚®Ü (i : Œπ), f i ‚äì g i ‚â§ (‚®Ü (i : Œπ), f i) ‚äì ‚®Ü (i : Œπ), g i :=
  ciInf_sup_ciInf_le (Œ± := Œ±·µí·µà) hf hg

omit [Nonempty Œπ] in
theorem ciInf_eq_min_cInf_inter_diff (S T : Set Œπ)
  [Nonempty (S ‚à© T : Set Œπ)] [Nonempty (S \ T : Set Œπ)] (hf : BddBelow (f '' S)) :
    ‚®Ö i : S, f i = (‚®Ö i : (S ‚à© T : Set Œπ), f i) ‚äì ‚®Ö i : (S \ T : Set Œπ), f i := by
  refine' le_antisymm _ _;
  ¬∑ rw [le_inf_iff]
    apply And.intro
    ¬∑ apply_rules [ ciInf_le, le_ciInf ];
      simp only [Subtype.forall, Set.mem_inter_iff, and_imp]
      exact fun a ha hb => ciInf_le ( show BddBelow ( Set.range fun i : S => f i ) by simpa [ Set.range ] using hf ) ‚ü® a, ha ‚ü©;
    ¬∑ apply_rules [ ciInf_le, le_ciInf ];
      simp only [Subtype.forall, Set.mem_diff, and_imp]
      exact fun a ha hb => ciInf_le ( show BddBelow ( Set.range fun i : S => f i ) by simpa [ Set.range ] using hf ) ‚ü® a, ha ‚ü©;
  ¬∑ have _ : Nonempty S := .map (fun (x : (S ‚à© T : Set _)) ‚Ü¶ ‚ü®x, x.2.1‚ü©) ‚Äπ_‚Ä∫
    apply le_csInf (Set.range_nonempty _)
    rintro i ‚ü®b, rfl‚ü©
    by_cases hiT : b.1 ‚àà T
    ¬∑ refine' le_trans ( inf_le_left ) _;
      refine' csInf_le _ _;
      ¬∑ exact ‚ü® hf.choose, Set.forall_mem_range.2 fun i => hf.choose_spec ‚ü® i, i.2.1, rfl ‚ü© ‚ü©;
      ¬∑ aesop
    ¬∑ refine' le_trans ( inf_le_right ) _;
      refine' csInf_le _ _
      ¬∑ exact ‚ü® hf.choose, Set.forall_mem_range.2 fun x => hf.choose_spec ‚ü® x, by aesop ‚ü© ‚ü©
      ¬∑ aesop

end ciSup

theorem QuasiconvexOn.subset
  {ùïú E Œ≤ : Type*} [Semiring ùïú] [PartialOrder ùïú] [AddCommMonoid E] [LE Œ≤] [SMul ùïú E]
  {s : Set E} {f : E ‚Üí Œ≤} (h : QuasiconvexOn ùïú s f) {t : Set E} (hts : t ‚äÜ s) (ht : Convex ùïú t) :
    QuasiconvexOn ùïú t f := by
  intro b
  convert ht.inter (h b) using 1
  simp +contextual [Set.ext_iff, @hts _]

theorem QuasiconvexOn.mem_segment_le_max
  {ùïú E Œ≤ : Type*} [Semiring ùïú] [PartialOrder ùïú] [AddCommMonoid E] [SemilatticeSup Œ≤] [SMul ùïú E]
  {s : Set E} {f : E ‚Üí Œ≤} (h : QuasiconvexOn ùïú s f)
  {x y z : E} (hx : x ‚àà s) (hy : y ‚àà s) (hz : z ‚àà segment ùïú x y):
    f z ‚â§ f x ‚äî f y :=
  ((h (f x ‚äî f y)).segment_subset (by simpa) (by simpa) hz).right

theorem QuasiconcaveOn.min_le_mem_segment
  {ùïú E Œ≤ : Type*} [Semiring ùïú] [PartialOrder ùïú] [AddCommMonoid E] [SemilatticeInf Œ≤] [SMul ùïú E]
  {s : Set E} {f : E ‚Üí Œ≤} (h : QuasiconcaveOn ùïú s f)
  {x y z : E} (hx : x ‚àà s) (hy : y ‚àà s) (hz : z ‚àà segment ùïú x y):
    f x ‚äì f y ‚â§ f z :=
  ((h (f x ‚äì f y)).segment_subset (by simpa) (by simpa) hz).right

theorem LowerSemicontinuousOn.bddBelow {Œ± : Type*} [TopologicalSpace Œ±] {S : Set Œ±} {g : Œ± ‚Üí ‚Ñù}
    (hg : LowerSemicontinuousOn g S) (hS : IsCompact S) : BddBelow (g '' S) := by
  rcases S.eq_empty_or_nonempty with rfl | hS‚ÇÇ
  ¬∑ simp
  have h_neighborhood : ‚àÄ x ‚àà S, ‚àÉ U ‚àà nhds x, ‚àÄ y ‚àà U ‚à© S, g y > g x - 1 := by
    -- By definition of lower semicontinuity, for each x ‚àà S, there exists a neighborhood U_x such that g(y) > g(x) - 1 for all y ‚àà U_x ‚à© S.
    intros x hx
    specialize hg x hx (g x - 1) (sub_one_lt (g x))
    rw [eventually_nhdsWithin_iff] at hg
    simp only [Set.mem_inter_iff, gt_iff_lt, and_imp]
    exact ‚ü®_, hg, fun y hy hyS ‚Ü¶ hy hyS‚ü©
  choose! U hU using h_neighborhood
  -- By the finite subcover property, there exists a finite subset t ‚äÜ S$ such that S ‚äÜ ‚ãÉ_{x ‚àà t} U_x$.
  obtain ‚ü®t, ht‚ü© : ‚àÉ t, (‚àÄ x ‚àà t, x ‚àà S) ‚àß S ‚äÜ ‚ãÉ x ‚àà t, U x :=
    hS.elim_nhds_subcover U fun x hx ‚Ü¶ hU x hx |>.1;
  -- Let $m$ be the minimum value of $g$ on the finite set $t$.
  obtain ‚ü®m, hm‚ü© : ‚àÉ m, ‚àÄ x ‚àà t, g x ‚â• m := by
    use Finset.min' (t.image g) ?_
    ¬∑ exact fun x hx ‚Ü¶ Finset.min'_le _ _ (t.mem_image_of_mem g hx)
    refine ‚ü®_, Finset.mem_image_of_mem g <| Classical.choose_spec <| Finset.nonempty_of_ne_empty ?_‚ü©
    rintro rfl
    simpa using ht.2 hS‚ÇÇ.some_mem
  use m - 1
  refine Set.forall_mem_image.mpr fun x hx ‚Ü¶ ?_
  rcases Set.mem_iUnion‚ÇÇ.mp (ht.2 hx) with ‚ü®y, hy, hy'‚ü©
  linarith [hm y hy, hU y (ht.1 y hy) |>.2 x ‚ü®hy', hx‚ü©]

theorem LowerSemicontinuousOn.max {Œ± : Type*} [TopologicalSpace Œ±] {S : Set Œ±} {f g : Œ± ‚Üí ‚Ñù}
    (hf : LowerSemicontinuousOn f S) (hg : LowerSemicontinuousOn g S) :
    LowerSemicontinuousOn (fun x ‚Ü¶ max (f x) (g x)) S := by
  convert lowerSemicontinuousOn_ciSup (s := S) (f := fun (i : Bool) x' ‚Ü¶ if i then f x' else g x') ?_ ?_
  ¬∑ rw [ciSup_eq_of_forall_le_of_forall_lt_exists_gt] <;> aesop
  ¬∑ simp
  ¬∑ simp [hf, hg]

variable {Œ± : Type*} [TopologicalSpace Œ±] {Œ≤ : Type*} [Preorder Œ≤] {f g : Œ± ‚Üí Œ≤} {x : Œ±}
  {s t : Set Œ±} {y z : Œ≤} {Œ≥ : Type*} [LinearOrder Œ≥]

theorem lowerSemicontinuousOn_iff_isClosed_preimage {f : Œ± ‚Üí Œ≥} [IsClosed s] :
    LowerSemicontinuousOn f s ‚Üî ‚àÄ y, IsClosed (s ‚à© f ‚Åª¬π' Set.Iic y) := by
  constructor
  ¬∑ intro a y
    refine' isClosed_of_closure_subset fun x hx => _;
    rw [ mem_closure_iff ] at hx;
    contrapose! hx;
    rcases em ( x ‚àà s ) with hx' | hx'
    ¬∑ simp only [Set.mem_inter_iff, hx', Set.mem_preimage, Set.mem_Iic, true_and, not_le] at hx
      have := a x hx';
      rcases mem_nhdsWithin.1 ( this y hx ) with ‚ü® o, ho, h ‚ü©;
      exact ‚ü® o, ho, h.1, Set.eq_empty_iff_forall_notMem.2 fun z hz => h.2 ‚ü® hz.1, hz.2.1 ‚ü© |> not_le_of_gt <| Set.mem_Iic.1 hz.2.2 ‚ü©;
    ¬∑ exact ‚ü® s·∂ú, IsClosed.isOpen_compl, hx', by aesop ‚ü©;
  ¬∑ intro a x hx y hy
    have hx_not_in : x ‚àâ s ‚à© f ‚Åª¬π' Set.Iic y := by
      simp [hy]
    rw [ eventually_nhdsWithin_iff ]
    filter_upwards [ IsOpen.mem_nhds ( isOpen_compl_iff.2 ( a y ) ) hx_not_in ] with z hz hzs
    exact lt_of_not_ge fun h => hz ‚ü®hzs, h‚ü©

theorem segment.isConnected {E : Type u_1} [AddCommGroup E] [Module ‚Ñù E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E] (a b : E) :
    IsConnected (segment ‚Ñù a b) := by
  rw [‚Üê Path.range_segment a b]
  exact isConnected_range (Path.segment a b).continuous

theorem BddAbove.range_inf_of_image2 {M N Œ± : Type*} {f : M ‚Üí N ‚Üí Œ±} [ConditionallyCompleteLinearOrder Œ±]
  {S : Set M} {T : Set N} (h_bddA : BddAbove (Set.image2 f S T)) (h_bddB : BddBelow (Set.image2 f S T)) :
    BddAbove (Set.range fun y : T ‚Ü¶ ‚®Ö x : S, f x y) := by
  rcases isEmpty_or_nonempty T with hT | hT
  ¬∑ aesop
  rcases S.eq_empty_or_nonempty with rfl | hS
  ¬∑ simp [Set.range, iInf]
  rw [‚Üê Set.nonempty_coe_sort, nonempty_subtype] at hS
  rcases hS with ‚ü®x, hx‚ü©
  choose z hz using h_bddA
  choose w hw using h_bddB
  have h_inf_le_M : ‚àÄ y ‚àà T, ‚®Ö x : S, f x y ‚â§ z := by
    intro y hy
    apply (ciInf_le ‚ü®_, Set.forall_mem_range.2 (hw <| Set.mem_image2_of_mem ¬∑.2 hy)‚ü© ‚ü®x, hx‚ü©).trans
    exact hz (Set.mem_image2_of_mem hx hy)
  exact ‚ü®_, Set.forall_mem_range.2 (h_inf_le_M _ ¬∑.2)‚ü©

theorem BddBelow.range_sup_of_image2 {M N Œ± : Type*} {f : M ‚Üí N ‚Üí Œ±} [ConditionallyCompleteLinearOrder Œ±]
  {S : Set M} {T : Set N} (h_bddA : BddAbove (Set.image2 f S T)) (h_bddB : BddBelow (Set.image2 f S T)) :
      BddBelow (Set.range fun y : T ‚Ü¶ ‚®Ü x : S, f x y) :=
  BddAbove.range_inf_of_image2 (Œ± := Œ±·µí·µà) h_bddB h_bddA

theorem ciInf_le_ciInf_of_subset {Œ± Œ≤ : Type*} [ConditionallyCompleteLattice Œ±]
  {f : Œ≤ ‚Üí Œ±} {s t : Set Œ≤} (hs : s.Nonempty) (hf : BddBelow (f '' t)) (hst : s ‚äÜ t) :
    ‚®Ö x : t, f x ‚â§ ‚®Ö x : s, f x := by
  have h_lower_bound : ‚àÄ y ‚àà s, ‚®Ö x : t, f x ‚â§ f y := by
    intro y hy
    obtain ‚ü®w_1, ‚ü®left_1, right_1‚ü©‚ü© : f y ‚àà f '' t := by
      use y, hst hy
    exact le_trans ( ciInf_le (by simpa [ Set.range ] using hf ) ‚ü® w_1, left_1 ‚ü© ) ( by simp[right_1] );
  apply le_csInf
  ¬∑ exact ‚ü®_, ‚ü®‚ü®_, hs.choose_spec‚ü©, rfl‚ü©‚ü©;
  ¬∑ aesop

theorem LowerSemicontinuousOn.dite_top {Œ± Œ≤ : Type*} [TopologicalSpace Œ±] [Preorder Œ≤] [OrderTop Œ≤]
  {s : Set Œ±} (p : Œ± ‚Üí Prop) [DecidablePred p] {f : (a : Œ±) ‚Üí p a ‚Üí Œ≤}
  (hf : LowerSemicontinuousOn (fun x : Subtype p ‚Ü¶ f x.val x.prop) {x | x.val ‚àà s})
  (h_relatively_closed : ‚àÉ U : Set Œ±, IsClosed U ‚àß s ‚à© U = s ‚à© setOf p) :
    LowerSemicontinuousOn (fun x ‚Ü¶ dite (p x) (f x) (fun _ ‚Ü¶ ‚ä§)) s := by
  rcases h_relatively_closed with ‚ü®u, ‚ü®hu, hsu‚ü©‚ü©
  simp only [Set.ext_iff, Set.mem_inter_iff, Set.mem_setOf_eq, and_congr_right_iff] at hsu
  intro x hx y hy
  dsimp at hy
  split_ifs at hy with h
  ¬∑ specialize hf ‚ü®x, h‚ü© hx y hy
    rw [ eventually_nhdsWithin_iff ] at hf ‚ä¢
    rw [ nhds_subtype_eq_comap, Filter.eventually_comap ] at hf;
    filter_upwards [hf]
    simp only [Subtype.forall]
    grind [lt_top_of_lt]
  ¬∑ filter_upwards [self_mem_nhdsWithin, mem_nhdsWithin_of_mem_nhds (hu.isOpen_compl.mem_nhds (show x ‚àâ u by grind))]
    intros
    simp_all only [Set.mem_compl_iff, ‚ÜìreduceDIte]

theorem LowerSemicontinuousOn.comp_continuousOn {Œ± Œ≤ Œ≥ : Type*}
  [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [Preorder Œ≥] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {g : Œ≤ ‚Üí Œ≥} {t : Set Œ≤}
  (hg : LowerSemicontinuousOn g t) (hf : ContinuousOn f s) (h : Set.MapsTo f s t) :
    LowerSemicontinuousOn (g ‚àò f) s := by
  intro x hx y hy
  have h_neighborhood : ‚àÉ U ‚àà nhds (f x), ‚àÄ z ‚àà U ‚à© t, y < g z := by
    have := hg ( f x ) ( h hx ) y hy
    simp_all only [Function.comp_apply, Set.mem_inter_iff, and_imp]
    rw [ eventually_nhdsWithin_iff ] at this
    aesop
  obtain ‚ü®U, hU_nhds, hU‚ü© : ‚àÉ U ‚àà nhds (f x), ‚àÄ z ‚àà U ‚à© t, y < g z := h_neighborhood
  have h_final : ‚àÄ·∂† x' in nhdsWithin x s, f x' ‚àà U ‚àß f x' ‚àà t := by
    filter_upwards [ hf x hx hU_nhds, self_mem_nhdsWithin ] with x' hx' hx'' using ‚ü® hx', h hx'' ‚ü©;
  exact h_final.mono fun x' hx' => hU _ hx'

theorem UpperSemicontinuousOn.comp_continuousOn {Œ± Œ≤ Œ≥ : Type*}
  [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [Preorder Œ≥] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {g : Œ≤ ‚Üí Œ≥} {t : Set Œ≤}
  (hg : UpperSemicontinuousOn g t) (hf : ContinuousOn f s) (h : Set.MapsTo f s t) :
    UpperSemicontinuousOn (g ‚àò f) s :=
  LowerSemicontinuousOn.comp_continuousOn (Œ≥ := Œ≥·µí·µà) hg hf h

theorem LowerSemicontinuousOn.ite_top {Œ± Œ≤ : Type*} [TopologicalSpace Œ±] [Preorder Œ≤] [OrderTop Œ≤]
  {s : Set Œ±} (p : Œ± ‚Üí Prop) [DecidablePred p] {f : (a : Œ±) ‚Üí Œ≤} (hf : LowerSemicontinuousOn f (s ‚à© setOf p))
  (h_relatively_closed : ‚àÉ U : Set Œ±, IsClosed U ‚àß s ‚à© U = s ‚à© setOf p) :
    LowerSemicontinuousOn (fun x ‚Ü¶ ite (p x) (f x) ‚ä§) s :=
  dite_top p (hf.comp_continuousOn (by fun_prop) (by intro; simp)) h_relatively_closed

theorem LeftOrdContinuous.comp_lowerSemicontinuousOn_strong_assumptions {Œ± Œ≥ Œ¥ : Type*}
  [TopologicalSpace Œ±] [LinearOrder Œ≥] [LinearOrder Œ¥] [TopologicalSpace Œ¥] [OrderTopology Œ¥]
  [TopologicalSpace Œ≥] [OrderTopology Œ≥] [DenselyOrdered Œ≥] [DenselyOrdered Œ¥]
  {s : Set Œ±} {g : Œ≥ ‚Üí Œ¥} {f : Œ± ‚Üí Œ≥} (hg : LeftOrdContinuous g) (hf : LowerSemicontinuousOn f s) (hg2 : Monotone g) :
    LowerSemicontinuousOn (g ‚àò f) s := by
  intros x hx y hy
  have hU : ‚àÉ U ‚àà nhds x, ‚àÄ z ‚àà U ‚à© s, g (f z) > y := by
    simp_all only [Set.mem_inter_iff, gt_iff_lt, and_imp]
    obtain ‚ü®z, hz1, hz2‚ü© : ‚àÉ z, y < g z ‚àß z < f x := by
      obtain ‚ü®z, hz‚ü© : ‚àÉ z, z < f x ‚àß y < g z := by
        by_contra h_contra
        simp only [not_exists, not_and, not_lt] at h_contra
        have h_exists_z : ‚àÉ z, z < f x ‚àß g z > y := by
          have h_lub : IsLUB (Set.Iio (f x)) (f x) := by
            exact isLUB_Iio
          have := hg h_lub;
          have := this.exists_between hy
          simp_all only [Set.mem_image, Set.mem_Iio, exists_exists_and_eq_and, gt_iff_lt]
          grind
        exact h_exists_z.choose_spec.2.not_ge ( h_contra _ h_exists_z.choose_spec.1 );
      aesop
    specialize hf x hx z hz2
    rw [ eventually_nhdsWithin_iff ] at hf
    exact ‚ü®_, hf, fun _ hx hx' ‚Ü¶ hz1.trans_le (hg2 (hx hx').le)‚ü©
  simp only [Set.mem_inter_iff, and_imp] at hU
  obtain ‚ü®w, ‚ü®left, right‚ü©‚ü© := hU
  exact Filter.eventually_inf_principal.2 (Filter.mem_of_superset left right)

theorem UpperSemicontinuousOn.frequently_lt_of_tendsto {Œ± Œ≤ Œ≥ : Type*} [TopologicalSpace Œ≤] [Preorder Œ≥]
  {f : Œ≤ ‚Üí Œ≥} {T : Set Œ≤} (hf : UpperSemicontinuousOn f T) {c : Œ≥} {zs : Œ± ‚Üí Œ≤} {z : Œ≤}
  {l : Filter Œ±} [l.NeBot] (hzs : l.Tendsto zs (nhds z)) (hx‚ÇÇ : f z < c) (hzI : ‚àÄ a, zs a ‚àà T) (hzT : z ‚àà T) :
    ‚àÄ·∂† a in l, f (zs a) < c := by
  have h : ‚àÄ·∂† n in l, zs n ‚àà {y ‚àà T | f y < c} := by
    filter_upwards [hzs.eventually (eventually_nhdsWithin_iff.mp ((hf z hzT) c hx‚ÇÇ))] with n hn
      using ‚ü®hzI n, hn (hzI n)‚ü©
  simp_all

theorem Finset.ciInf_insert {Œ± Œ≤ : Type*} [DecidableEq Œ±] [ConditionallyCompleteLattice Œ≤]
  (t : Finset Œ±) (ht : t.Nonempty) (x : Œ±) (f : Œ± ‚Üí Œ≤) :
    ‚®Ö (a : (insert x t : _)), f a = f x ‚äì ‚®Ö (a : t), f a := by
  apply le_antisymm
  ¬∑ apply le_inf
    ¬∑ apply csInf_le <;> aesop
    apply le_csInf
    ¬∑ exact ‚ü®_, ‚ü®‚ü®ht.choose, ht.choose_spec ‚ü©, rfl‚ü©‚ü©
    rintro _ ‚ü®‚ü®a, ha‚ü©, rfl‚ü©
    exact csInf_le (Finite.bddBelow_range _) ‚ü®‚ü®a, Finset.mem_insert_of_mem ha‚ü©, rfl‚ü©
  ¬∑ apply le_csInf
    ¬∑ exact ‚ü®_, ‚ü®‚ü®x, Finset.mem_insert_self _ _‚ü©, rfl‚ü©‚ü©
    simp only [Set.mem_range, Subtype.exists, mem_insert, exists_prop, exists_eq_or_imp]
    rintro b (rfl | ‚ü®_, ‚ü®_, rfl‚ü©‚ü©)
    ¬∑ exact inf_le_left
    apply inf_le_right.trans
    apply csInf_le (Set.finite_range _).bddBelow
    aesop

theorem Finset.ciSup_insert {Œ± Œ≤ : Type*} [DecidableEq Œ±] [ConditionallyCompleteLattice Œ≤]
  (t : Finset Œ±) (ht : t.Nonempty) (x : Œ±) (f : Œ± ‚Üí Œ≤) :
    ‚®Ü (a : (insert x t : _)), f a = f x ‚äî ‚®Ü (a : t), f a :=
  t.ciInf_insert (Œ≤ := Œ≤·µí·µà) ht x f

section sion_minimax
/-!
Following https://projecteuclid.org/journals/kodai-mathematical-journal/volume-11/issue-1/Elementary-proof-for-Sions-minimax-theorem/10.2996/kmj/1138038812.full, with some corrections. There are two errors in Lemma 2 and the main theorem: an incorrect step that
`(‚àÄ x, a < f x) ‚Üí (a < ‚®Ö x, f x)`. This is repaired by taking an extra `exists_between` to get `a < b < ‚®Ö ...`, concluding that
`(‚àÄ x, b < f x) ‚Üí (b ‚â§ ‚®Ö x, f x)` and so `(a < ‚®Ö x, f x)`.
-/

variable  {M : Type*} [NormedAddCommGroup M]
  {N : Type*}
  {f : M ‚Üí N ‚Üí ‚Ñù} {S : Set M} {T : Set N}
  (hfc‚ÇÇ : ‚àÄ y, y ‚àà T ‚Üí LowerSemicontinuousOn (f ¬∑ y) S)
  (hS‚ÇÅ : IsCompact S) (hS‚ÇÉ : S.Nonempty) (hT‚ÇÉ : T.Nonempty)

include hfc‚ÇÇ hS‚ÇÅ hS‚ÇÉ in
private theorem sion_exists_min_lowerSemi (a : ‚Ñù) (hc : ‚àÄ y‚ÇÄ : T, ‚®Ö (x : S), f (‚Üëx) y‚ÇÄ ‚â§ a) (z : N) (hzT : z ‚àà T) :
    ‚àÉ x ‚àà S, f x z ‚â§ a := by
  let _ := hS‚ÇÉ.to_subtype
  contrapose! hc
  use ‚ü®z, hzT‚ü©
  have h_lower_bound (x : S) : a < f x z := hc x x.2
  apply lt_of_le_of_ne
  ¬∑ apply le_csInf (Set.range_nonempty _)
    rintro _ ‚ü®x, rfl‚ü©
    exact (h_lower_bound x).le
  intro h
  obtain ‚ü®x, hxz‚ü© : ‚àÉ x : S, f x z ‚â§ a := by
    obtain ‚ü®xn, hxn‚ü© : ‚àÉ xn : ‚Ñï ‚Üí S, Filter.atTop.Tendsto (fun n => f (xn n) z) (nhds a) := by
      have h_eps : ‚àÄ Œµ > 0, ‚àÉ x : S, f x z < a + Œµ := by
        intro Œµ Œµpos
        have hx : ‚®Ö x : S, f x z < a + Œµ := by linarith
        simpa using exists_lt_of_csInf_lt (Set.range_nonempty _) hx
      choose! xn hxn using h_eps
      use fun n ‚Ü¶ xn (1 / (n + 1))
      rw [tendsto_iff_dist_tendsto_zero]
      refine squeeze_zero (fun _ ‚Ü¶ abs_nonneg _) (fun n ‚Ü¶ ?_) tendsto_one_div_add_atTop_nhds_zero_nat
      refine abs_le.mpr ‚ü®?_, ?_‚ü© <;> linarith [h_lower_bound (xn (1 / (n + 1))), hxn (1 / (n + 1)) (by positivity)]
    obtain ‚ü®x, subseq, hsubseq‚ÇÅ, hsubseq‚ÇÇ‚ü© : ‚àÉ x : S, ‚àÉ subseq : ‚Ñï ‚Üí ‚Ñï,
        StrictMono subseq ‚àß Filter.Tendsto (fun n => xn (subseq n)) Filter.atTop (nhds x) := by
      simpa using (isCompact_iff_isCompact_univ.mp hS‚ÇÅ).isSeqCompact (x := xn) fun _ ‚Ü¶ trivial
    use x
    refine le_of_forall_pos_le_add fun Œµ Œµpos ‚Ü¶ ?_
    rw [‚Üê tsub_le_iff_right]
    apply le_of_tendsto_of_tendsto tendsto_const_nhds (hxn.comp hsubseq‚ÇÅ.tendsto_atTop)
    apply Filter.eventually_atTop.mpr
    rw [Metric.tendsto_atTop] at hsubseq‚ÇÇ
    have ‚ü®Œ¥, Œ¥pos, H‚ü© : ‚àÉ Œ¥ > 0, ‚àÄ y ‚àà S, dist y x < Œ¥ ‚Üí f y z > f x z - Œµ := by
      obtain ‚ü®Œ¥, hŒ¥‚ü© := Metric.mem_nhdsWithin_iff.mp (((hfc‚ÇÇ z hzT) x x.2) _ (sub_lt_self _ Œµpos))
      exact ‚ü®Œ¥, hŒ¥.1, fun y hy hyx => hŒ¥.2 ‚ü®hyx, hy‚ü©‚ü©
    rcases hsubseq‚ÇÇ Œ¥ Œ¥pos with ‚ü®N, hN‚ü©
    exact ‚ü®N, fun n hn ‚Ü¶ (H _ (xn (subseq n)).coe_prop (hN _ hn)).le‚ü©
  specialize h_lower_bound x
  order

variable [Module ‚Ñù M] [ContinuousAdd M] [ContinuousSMul ‚Ñù M]
variable [NormedAddCommGroup N] [Module ‚Ñù N] [ContinuousAdd N] [ContinuousSMul ‚Ñù N]
variable
  (hfc‚ÇÅ : ‚àÄ x, x ‚àà S ‚Üí UpperSemicontinuousOn (f x) T)
  (hfq‚ÇÇ : ‚àÄ y, y ‚àà T ‚Üí QuasiconvexOn ‚Ñù S (f ¬∑ y))
  (hfq‚ÇÅ : ‚àÄ x, x ‚àà S ‚Üí QuasiconcaveOn ‚Ñù T (f x))
  (hT‚ÇÇ : Convex ‚Ñù T) (hS‚ÇÇ : Convex ‚Ñù S)

include hfc‚ÇÅ hfq‚ÇÅ hfc‚ÇÇ hfq‚ÇÇ hS‚ÇÅ hT‚ÇÇ hS‚ÇÉ in
private lemma sion_exists_min_2 (y‚ÇÅ y‚ÇÇ : N) (hy‚ÇÅ : y‚ÇÅ ‚àà T) (hy‚ÇÇ : y‚ÇÇ ‚àà T)
    (a : ‚Ñù) (ha : a < ‚®Ö x : S, (max (f x y‚ÇÅ) (f x y‚ÇÇ)))
    : ‚àÉ y‚ÇÄ : T, a < ‚®Ö x : S, f x y‚ÇÄ := by
  by_contra! hc
  have _ := isCompact_iff_compactSpace.mp hS‚ÇÅ
  have _ := hS‚ÇÅ.isClosed
  obtain ‚ü®Œ≤, hŒ≤‚ÇÅ, hŒ≤‚ÇÇ‚ü© := exists_between ha
  let C : N ‚Üí Set M := fun z ‚Ü¶ { x ‚àà S | f x z ‚â§ a }
  let C' : N ‚Üí Set M := fun z ‚Ü¶ { x ‚àà S | f x z ‚â§ Œ≤ }
  let A := C' y‚ÇÅ
  let B := C' y‚ÇÇ
  have hC_subset_C' (z) : C z ‚äÜ C' z :=
    fun x hx ‚Ü¶ ‚ü®hx.1, hx.2.trans hŒ≤‚ÇÅ.le‚ü©
  have hC_nonempty (z) (hz : z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ) : (C z).Nonempty := by
    simp only [Set.Nonempty, Set.mem_setOf_eq, C]
    exact sion_exists_min_lowerSemi hfc‚ÇÇ hS‚ÇÅ hS‚ÇÉ a hc z (hT‚ÇÇ.segment_subset hy‚ÇÅ hy‚ÇÇ hz)
  have hC_closed (z) (hz : z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ) : IsClosed (C z) := by
    specialize hfc‚ÇÇ z (hT‚ÇÇ.segment_subset hy‚ÇÅ hy‚ÇÇ hz)
    rw [lowerSemicontinuousOn_iff_isClosed_preimage] at hfc‚ÇÇ
    exact hfc‚ÇÇ a
  have hC'_nonempty (z) (hz : z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ) : (C' z).Nonempty :=
    (hC_nonempty z hz).mono (hC_subset_C' z)
  have hC'_closed (z) (hz : z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ) : IsClosed (C' z) := by
    specialize hfc‚ÇÇ z (hT‚ÇÇ.segment_subset hy‚ÇÅ hy‚ÇÇ hz)
    rw [lowerSemicontinuousOn_iff_isClosed_preimage] at hfc‚ÇÇ
    exact hfc‚ÇÇ Œ≤
  have hA_nonempty : A.Nonempty := hC'_nonempty y‚ÇÅ (left_mem_segment ‚Ñù y‚ÇÅ y‚ÇÇ)
  have hA_closed : IsClosed A := hC'_closed y‚ÇÅ (left_mem_segment ‚Ñù y‚ÇÅ y‚ÇÇ)
  have hB_nonempty : B.Nonempty := hC'_nonempty y‚ÇÇ (right_mem_segment ‚Ñù y‚ÇÅ y‚ÇÇ)
  have hB_closed : IsClosed B := hC'_closed y‚ÇÇ (right_mem_segment ‚Ñù y‚ÇÅ y‚ÇÇ)
  have hAB : A ‚à© B = ‚àÖ := by
    simp [A, B, C', Set.ext_iff]
    intro x hx hŒ≤y‚ÇÅ _
    by_contra! hŒ≤y‚ÇÇ
    have hŒ≤ := max_le hŒ≤y‚ÇÅ hŒ≤y‚ÇÇ
    revert hŒ≤
    rw [imp_false, not_le]
    refine lt_of_lt_of_le hŒ≤‚ÇÇ ?_
    have h := ((hfc‚ÇÇ y‚ÇÅ hy‚ÇÅ).max (hfc‚ÇÇ y‚ÇÇ hy‚ÇÇ)).bddBelow hS‚ÇÅ
    rw [Set.image_eq_range] at h
    exact ciInf_le h ‚ü®x, hx‚ü©
  have hfxz (x) (hx : x ‚àà S) (z) (hz : z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ) : min (f x y‚ÇÅ) (f x y‚ÇÇ) ‚â§ f x z :=
    (hfq‚ÇÅ x hx).min_le_mem_segment hy‚ÇÅ hy‚ÇÇ hz
  have hC'zAB (z) (hz : z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ) : C' z ‚äÜ A ‚à™ B := by
    --TODO: On newer Mathlib this is just `grind [inf_le_iff, le_trans]`
    intro; simp [C', A, B]; grind [inf_le_iff, le_trans]
  have hC'z (z) (hz : z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ) : Convex ‚Ñù (C' z) :=
    hfq‚ÇÇ z (hT‚ÇÇ.segment_subset hy‚ÇÅ hy‚ÇÇ hz) Œ≤
  have hC'zAB (z) (hz : z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ) : C' z ‚äÜ A ‚à® C' z ‚äÜ B := by
    specialize hC_subset_C' z
    specialize hC'z z hz
    have hC' : IsPreconnected (C' z) :=
      ((hC'z).isConnected ((hC_nonempty z hz).mono hC_subset_C')).isPreconnected
    rw [isPreconnected_iff_subset_of_disjoint_closed] at hC'
    exact hC' A B hA_closed hB_closed (hC'zAB z hz) (by simp [hAB])
  have hCzAB (z) (hz : z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ) : C z ‚äÜ A ‚à® C z ‚äÜ B := by
    specialize hC_subset_C' z
    rcases hC'zAB z hz with h | h
    ¬∑ exact .inl (hC_subset_C'.trans h)
    ¬∑ exact .inr (hC_subset_C'.trans h)
  have h_not_CzAB (z) (hz : z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ) : ¬¨(C z ‚äÜ A ‚àß C z ‚äÜ B) := by
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    specialize hC_nonempty z hz
    replace h‚ÇÅ := Set.mem_of_mem_of_subset hC_nonempty.some_mem h‚ÇÅ
    replace h‚ÇÇ := Set.mem_of_mem_of_subset hC_nonempty.some_mem h‚ÇÇ
    simpa [hAB] using Set.mem_inter h‚ÇÅ h‚ÇÇ
  let I : Set N := { z | z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ ‚àß C z ‚äÜ A}
  let J : Set N := { z | z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ ‚àß C z ‚äÜ B}
  have hI‚ÇÅ : I.Nonempty := by
    use y‚ÇÅ
    simp [I, A, hC_subset_C', left_mem_segment]
  have hJ‚ÇÅ : J.Nonempty := by
    use y‚ÇÇ
    simp [J, B, hC_subset_C', right_mem_segment]
  rw [Set.nonempty_iff_ne_empty] at hI‚ÇÅ hJ‚ÇÅ
  have hIJ : I ‚à© J = ‚àÖ := by
    simp [I, J, Set.ext_iff]
    intro z hz hCzA _ hCzB
    specialize hCzA (hC_nonempty z hz).some_mem
    specialize hCzB (hC_nonempty z hz).some_mem
    rw [‚Üê Set.disjoint_iff_inter_eq_empty, Set.disjoint_left] at hAB
    tauto
  have hIJ‚ÇÇ : I ‚à™ J = segment ‚Ñù y‚ÇÅ y‚ÇÇ := by
    simp [I, J, Set.ext_iff]
    grind
  have hI : IsClosed I := by
    apply IsSeqClosed.isClosed
    intro zs z hzI hzs
    simp only [Set.mem_setOf_eq, I, C] at hzI
    replace ‚ü®hzI, hzI2‚ü© := And.intro (hzI ¬∑ |>.left) (hzI ¬∑ |>.right)
    have hz_mem : z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ :=
      have cloL : IsClosed (segment ‚Ñù y‚ÇÅ y‚ÇÇ) := by
        rw [‚Üê closure_openSegment]
        exact isClosed_closure
      cloL.isSeqClosed hzI hzs
    let x := (hC_nonempty z hz_mem).some
    have hx : x ‚àà C z := (hC_nonempty z hz_mem).some_mem
    suffices hn : ‚àÉ n, x ‚àà C' (zs n) by
      use hz_mem
      rcases hn with ‚ü®n, hn‚ü©
      have hCzn : C (zs n) ‚äÜ A := hzI2 n
      replace hCzn : C' (zs n) ‚äÜ A := by
        refine (hC'zAB (zs n) (hzI n)).resolve_right ?_
        intro hC'B
        exact (h_not_CzAB (zs n) (hzI n)) ‚ü®hCzn, (hC_subset_C' _).trans hC'B‚ü©
      have hxA : x ‚àà A := Set.mem_of_mem_of_subset hn hCzn
      refine (hCzAB z hz_mem).resolve_right ?_
      intro hCB
      have hAC : A ‚à© C z ‚äÜ A ‚à© B := by apply Set.inter_subset_inter_right _ hCB
      rw [hAB, Set.subset_empty_iff, Set.ext_iff] at hAC
      revert hAC
      simp only [Set.mem_inter_iff, Set.mem_empty_iff_false, iff_false, not_and, imp_false, not_forall, not_not]
      exact ‚ü®x, hxA, hx‚ü©
    suffices hn : ‚àÉ n, f x (zs n) < Œ≤ by
      refine hn.imp fun n ‚Ü¶ ?_
      simp +contextual [C', le_of_lt, hx.left]
    simp only [Set.mem_setOf_eq, C] at hx
    rcases hx with ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©
    specialize hfc‚ÇÅ x hx‚ÇÅ
    replace hx‚ÇÇ := hx‚ÇÇ.trans_lt hŒ≤‚ÇÅ
    replace hzI (n) := hT‚ÇÇ.segment_subset hy‚ÇÅ hy‚ÇÇ (hzI n)
    replace hz_mem := hT‚ÇÇ.segment_subset hy‚ÇÅ hy‚ÇÇ hz_mem
    exact (hfc‚ÇÅ.frequently_lt_of_tendsto hzs hx‚ÇÇ hzI hz_mem).exists
  have hJ : IsClosed J := by
    apply IsSeqClosed.isClosed
    intro zs z hzI hzs
    simp only [Set.mem_setOf_eq, J, C] at hzI
    replace ‚ü®hzI, hzI2‚ü© := And.intro (hzI ¬∑ |>.left) (hzI ¬∑ |>.right)
    have hz_mem : z ‚àà segment ‚Ñù y‚ÇÅ y‚ÇÇ :=
      have cloL : IsClosed (segment ‚Ñù y‚ÇÅ y‚ÇÇ) := by
        rw [‚Üê closure_openSegment]
        exact isClosed_closure
      cloL.isSeqClosed hzI hzs
    let x := (hC_nonempty z hz_mem).some
    have hx : x ‚àà C z := (hC_nonempty z hz_mem).some_mem
    suffices hn : ‚àÉ n, x ‚àà C' (zs n) by
      use hz_mem
      rcases hn with ‚ü®n, hn‚ü©
      have hCzn : C (zs n) ‚äÜ B := hzI2 n
      replace hCzn : C' (zs n) ‚äÜ B := by
        refine (hC'zAB (zs n) (hzI n)).resolve_left ?_
        intro hC'B
        exact (h_not_CzAB (zs n) (hzI n)) ‚ü®(hC_subset_C' _).trans hC'B, hCzn‚ü©
      have hxA : x ‚àà B := Set.mem_of_mem_of_subset hn hCzn
      refine (hCzAB z hz_mem).resolve_left ?_
      intro hCB
      have hAC : C z ‚à© B ‚äÜ A ‚à© B := by apply Set.inter_subset_inter_left _ hCB
      rw [hAB, Set.subset_empty_iff, Set.ext_iff] at hAC
      revert hAC
      simp only [Set.mem_inter_iff, Set.mem_empty_iff_false, iff_false, not_and, imp_false, not_forall, not_not]
      exact ‚ü®x, hx, hxA‚ü©
    suffices hn : ‚àÉ n, f x (zs n) < Œ≤ by
      refine hn.imp fun n ‚Ü¶ ?_
      simp +contextual [C', le_of_lt, hx.left]
    simp only [Set.mem_setOf_eq, C] at hx
    rcases hx with ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©
    specialize hfc‚ÇÅ x hx‚ÇÅ
    replace hx‚ÇÇ := hx‚ÇÇ.trans_lt hŒ≤‚ÇÅ
    replace hzI (n) := hT‚ÇÇ.segment_subset hy‚ÇÅ hy‚ÇÇ (hzI n)
    replace hz_mem := hT‚ÇÇ.segment_subset hy‚ÇÅ hy‚ÇÇ hz_mem
    exact (hfc‚ÇÅ.frequently_lt_of_tendsto hzs hx‚ÇÇ hzI hz_mem).exists
  have hConnected := segment.isConnected y‚ÇÅ y‚ÇÇ
  rw [IsConnected, isPreconnected_iff_subset_of_fully_disjoint_closed ?_] at hConnected; swap
  ¬∑ rw [‚Üê closure_openSegment]
    exact isClosed_closure
  replace hConnected := hConnected.right I J
  simp [hIJ, ‚Üê hIJ‚ÇÇ, Set.disjoint_iff_inter_eq_empty] at hConnected
  obtain hL | hR := hConnected hI hJ
  ¬∑ rw [Set.inter_eq_self_of_subset_right hL] at hIJ
    exact hJ‚ÇÅ hIJ
  ¬∑ rw [Set.inter_eq_self_of_subset_left hR] at hIJ
    exact hI‚ÇÅ hIJ

include hfc‚ÇÅ hfq‚ÇÅ hfc‚ÇÇ hfq‚ÇÇ hS‚ÇÅ hS‚ÇÇ hT‚ÇÇ hS‚ÇÉ in
private lemma sion_exists_min_fin
  (h_bddA : BddAbove (Set.image2 f S T)) (h_bddB : BddBelow (Set.image2 f S T))
  (ys : Finset N) (hys_n : ys.Nonempty) (hys : (ys : Set N) ‚äÜ T)
  (a : ‚Ñù) (ha : a < ‚®Ö x : S, ‚®Ü yi : ys, f x yi)
    : ‚àÉ y‚ÇÄ : T, a < ‚®Ö x : S, f x y‚ÇÄ := by
  induction hys_n using Finset.Nonempty.cons_induction generalizing S
  case singleton x =>
    simp at ha hys
    use ‚ü®x, hys‚ü©
  case cons y‚Çô t hxt htn ih =>
    classical rw [Finset.cons_eq_insert] at hys ha
    simp [Set.insert_subset_iff] at hys
    rcases hys with ‚ü®hy‚Çô, ht‚ü©
    let _ := hS‚ÇÉ.to_subtype
    obtain ‚ü®b, hab, hb‚ü© := exists_between ha
    let S' := {z : M | z ‚àà S ‚àß f z y‚Çô ‚â§ b}
    have hS'_sub : S' ‚äÜ S := Set.sep_subset ..
    rcases S'.eq_empty_or_nonempty with 