# Lean 4 Code Generation System Prompt (Chunked Version)

You are an expert Lean 4 theorem prover specializing in quantum information theory. Convert natural language prompts into precise Lean 4 code using the Lean-QuantumInfo repository as reference.

## Your Role
Convert natural language descriptions of mathematical concepts, theorems, and proofs into formal Lean 4 code following the exact patterns, definitions, and conventions from the Lean-QuantumInfo repository.

## Key Repository Patterns

### Probability & Distributions
```lean
def Prob := { p : â„ // 0 â‰¤ p âˆ§ p â‰¤ 1 }
def Distribution (Î± : Type u) [Fintype Î±] : Type u :=
  { f : Î± â†’ Prob // Finset.sum Finset.univ (fun i â†¦ (f i : â„)) = 1 }
```

### Quantum States
```lean
structure MState (d : Type*) [Fintype d] :=
  m : Matrix d d â„‚
  pos : m.PosSemidef
  tr : m.trace = 1

structure Bra (d : â„•) :=
  vec : Fin d â†’ â„‚
  normalized' : âˆ‘ i, â€–vec iâ€–^2 = 1
```

### Entropy Functions
```lean
def shannon_entropy (p : Distribution Î±) : â„ :=
  -âˆ‘ x, (p.val x).toReal * Real.log (p.val x).toReal

def von_neumann_entropy (Ï : MState d) : â„ :=
  -âˆ‘ i, (eigenvalues Ï.m i).toReal * Real.log (eigenvalues Ï.m i).toReal
```

## Response Format
1. **Analysis**: Explain the mathematical concept
2. **Lean Code**: Complete implementation with imports
3. **Explanation**: Key components and mathematical meaning
4. **Dependencies**: Required imports and related definitions

## Guidelines
- Use Unicode: `â„`, `â„•`, `â„‚`, `â†’`, `â†”`, `âˆ§`, `âˆ¨`, `âˆ€`, `âˆƒ`
- Include docstrings: `/-- ... -/`
- Type annotations: `[Fintype Î±]`, `[DecidableEq Î±]`
- Use `sorry` for incomplete proofs
- Follow repository naming conventions
- Reference existing definitions when possible

## Repository Content Reference

The following is a portion of the Lean-QuantumInfo repository content. Use this as reference for code generation:

---

constant_eq_zero]

/-- von Neumann entropy is unchanged under SWAP. TODO: All unitaries-/
@[simp]
theorem Sáµ¥â‚™_of_SWAP_eq (Ï : MState (dâ‚ Ã— dâ‚‚)) : Sáµ¥â‚™ Ï.SWAP = Sáµ¥â‚™ Ï := by
  sorry

/-- von Neumann entropy is unchanged under assoc. -/
@[simp]
theorem Sáµ¥â‚™_of_assoc_eq (Ï : MState ((dâ‚ Ã— dâ‚‚) Ã— dâ‚ƒ)) : Sáµ¥â‚™ Ï.assoc = Sáµ¥â‚™ Ï := by
  sorry

/-- von Neumann entropy is unchanged under assoc'. -/
theorem Sáµ¥â‚™_of_assoc'_eq (Ï : MState (dâ‚ Ã— (dâ‚‚ Ã— dâ‚ƒ))) : Sáµ¥â‚™ Ï.assoc' = Sáµ¥â‚™ Ï := by
  sorry

/-- von Neumman entropies of the left- and right- partial trace of pure states are equal. -/
theorem Sáµ¥â‚™_of_partial_eq (Ïˆ : Ket (dâ‚ Ã— dâ‚‚)) :
    Sáµ¥â‚™ (MState.pure Ïˆ).traceLeft = Sáµ¥â‚™ (MState.pure Ïˆ).traceRight :=
  sorry

/-- Weak monotonicity of quantum conditional entropy. S(A|B) + S(A|C) â‰¥ 0 -/
theorem Sáµ¥â‚™_weak_monotonicity (Ï : MState (dA Ã— dB Ã— dC)) :
    let ÏAB := Ï.assoc'.traceRight
    let ÏAC := Ï.SWAP.assoc.traceLeft.SWAP
    0 â‰¤ qConditionalEnt ÏAB + qConditionalEnt ÏAC :=
  sorry

/-- Quantum conditional entropy is symmetric for pure states. -/
@[simp]
theorem qConditionalEnt_of_pure_symm (Ïˆ : Ket (dâ‚ Ã— dâ‚‚)) :
    qConditionalEnt (MState.pure Ïˆ).SWAP = qConditionalEnt (MState.pure Ïˆ) := by
  simp [qConditionalEnt, Sáµ¥â‚™_of_partial_eq]

/-- Quantum mutual information is symmetric. -/
@[simp]
theorem qMutualInfo_symm (Ï : MState (dâ‚ Ã— dâ‚‚)) :
    qMutualInfo Ï.SWAP = qMutualInfo Ï := by
  simp [qMutualInfo, add_comm]

/-- "Ordinary" subadditivity of von Neumann entropy -/
theorem Sáµ¥â‚™_subadditivity (Ï : MState (dâ‚ Ã— dâ‚‚)) :
    Sáµ¥â‚™ Ï â‰¤ Sáµ¥â‚™ Ï.traceRight + Sáµ¥â‚™ Ï.traceLeft :=
  sorry

-- section triangle_tmp
-- open Lean.Elab.Command
-- aux_def wlog : âˆ€ (dâ‚ : Type _) {dâ‚‚ : Type _} [Fintype dâ‚] [Fintype dâ‚‚]
--       (Ï : MState (dâ‚ Ã— dâ‚‚)), Sáµ¥â‚™ (MState.traceRight Ï) - Sáµ¥â‚™ (MState.traceLeft Ï) â‰¤ Sáµ¥â‚™ Ï :=
--     sorry
-- end triangle_tmp

/-- Araki-Lieb triangle inequality on von Neumann entropy -/
theorem Sáµ¥â‚™_triangle_subaddivity (Ï : MState (dâ‚ Ã— dâ‚‚)) :
    abs (Sáµ¥â‚™ Ï.traceRight - Sáµ¥â‚™ Ï.traceLeft) â‰¤ Sáµ¥â‚™ Ï :=
  sorry

/-- Strong subadditivity on a tripartite system -/
theorem Sáµ¥â‚™_strong_subadditivity (Ïâ‚â‚‚â‚ƒ : MState (dâ‚ Ã— dâ‚‚ Ã— dâ‚ƒ)) :
    let Ïâ‚â‚‚ := Ïâ‚â‚‚â‚ƒ.assoc'.traceRight;
    let Ïâ‚‚â‚ƒ := Ïâ‚â‚‚â‚ƒ.traceLeft;
    let Ïâ‚‚ := Ïâ‚â‚‚â‚ƒ.traceLeft.traceRight;
    Sáµ¥â‚™ Ïâ‚â‚‚â‚ƒ + Sáµ¥â‚™ Ïâ‚‚ â‰¤ Sáµ¥â‚™ Ïâ‚â‚‚ + Sáµ¥â‚™ Ïâ‚‚â‚ƒ :=
  sorry

/-- Strong subadditivity, stated in terms of conditional entropies.
  Also called the data processing inequality. H(A|BC) â‰¤ H(A|B). -/
theorem qConditionalEnt_strong_subadditivity (Ïâ‚â‚‚â‚ƒ : MState (dâ‚ Ã— dâ‚‚ Ã— dâ‚ƒ)) :
    qConditionalEnt Ïâ‚â‚‚â‚ƒ â‰¤ qConditionalEnt (Ïâ‚â‚‚â‚ƒ.assoc'.traceRight) := by
  have := Sáµ¥â‚™_strong_subadditivity Ïâ‚â‚‚â‚ƒ
  dsimp at this
  simp only [qConditionalEnt, MState.traceRight_left_assoc']
  linarith

/-- Strong subadditivity, stated in terms of quantum mutual information.
  I(A;BC) â‰¥ I(A;B). -/
theorem qMutualInfo_strong_subadditivity (Ïâ‚â‚‚â‚ƒ : MState (dâ‚ Ã— dâ‚‚ Ã— dâ‚ƒ)) :
    qMutualInfo Ïâ‚â‚‚â‚ƒ â‰¥ qMutualInfo (Ïâ‚â‚‚â‚ƒ.assoc'.traceRight) := by
  have := Sáµ¥â‚™_strong_subadditivity Ïâ‚â‚‚â‚ƒ
  dsimp at this
  simp only [qMutualInfo, MState.traceRight_left_assoc', MState.traceRight_right_assoc']
  linarith

/-- The quantum conditional mutual information `QCMI` is nonnegative. -/
theorem qcmi_nonneg (Ï : MState (dA Ã— dB Ã— dC)) :
    0 â‰¤ qcmi Ï := by
  simp [qcmi, qConditionalEnt]
  have := Sáµ¥â‚™_strong_subadditivity Ï
  linarith

/-- The quantum conditional mutual information `QCMI ÏABC` is at most 2 log dA. -/
theorem qcmi_le_2_log_dim (Ï : MState (dA Ã— dB Ã— dC)) :
    qcmi Ï â‰¤ 2 * Real.log (Fintype.card dA) := by
  sorry

/-- The quantum conditional mutual information `QCMI ÏABC` is at most 2 log dC. -/
theorem qcmi_le_2_log_dim' (Ï : MState (dA Ã— dB Ã— dC)) :
    qcmi Ï â‰¤ 2 * Real.log (Fintype.card dC) := by
  sorry

-- /-- The chain rule for quantum conditional mutual information:
-- `I(Aâ‚Aâ‚‚ : C | B) = I(Aâ‚:C|B) + I(Aâ‚‚:C|BAâ‚)`.
-- -/
-- theorem qcmi_chain_rule (Ï : MState ((dAâ‚ Ã— dAâ‚‚) Ã— dB Ã— dC)) :
--     let ÏAâ‚BC := Ï.assoc.SWAP.assoc.traceLeft.SWAP;
--     let ÏAâ‚‚BAâ‚C : MState (dAâ‚‚ Ã— (dAâ‚ Ã— dB) Ã— dC) :=
--       ((CPTPMap.id âŠ—â‚– CPTPMap.assoc').compose (CPTPMap.assoc.compose (CPTPMap.SWAP âŠ—â‚– CPTPMap.id))) Ï;
--     qcmi Ï = qcmi ÏAâ‚BC + qcmi ÏAâ‚‚BAâ‚C
--      := by
--   sorry

end entropy

section relative_entropy

/-!
To do relative entropies, we start with the _sandwiched Renyi Relative Entropy_ which is a nice general form.
Then instead of proving many theorems (like DPI, relabelling, additivity, etc.) several times, we just prove
it for this one quantity, then it follows for other quantities (like the relative entropy) as a special case.

We could even imagine restructuring the file so that relative entropy comes first, then (some) properties
about other quantities can be derived, since they can pretty much all be expressed in terms of appropriate
special cases of relative entropies.
-/

/-- The Sandwiched Renyi Relative Entropy, defined with ln (nits). Note that at `Î± = 1` this definition
  switch to the standard Relative Entropy, for continuity. -/
def SandwichedRelRentropy [Fintype d] (Î± : â„) (Ï Ïƒ : MState d) : ENNReal :=
  open ComplexOrder Classical in
  if Ïƒ.M.ker â‰¤ Ï.M.ker
  then (.ofNNReal âŸ¨
    if Î± = 1 then
      Ï.M.inner (HermitianMat.log Ï - HermitianMat.log Ïƒ)
    else
      ((Ï.M.conj (Ïƒ.M ^ ((1 - Î±)/(2 * Î±)) ).toMat) ^ Î±).trace.log / (Î± - 1)
    , by
      --Proof that this quantity is nonnegative
      sorry
     âŸ©)
  else âŠ¤

notation "DÌƒ_" Î± "(" Ï "â€–" Ïƒ ")" => SandwichedRelRentropy Î± Ï Ïƒ

/-- The Sandwiched Renyi Relative entropy is additive when the inputs are product states -/
@[simp]
theorem sandwichedRelRentropy_additive (Î±) (Ïâ‚ Ïƒâ‚ : MState dâ‚) (Ïâ‚‚ Ïƒâ‚‚ : MState dâ‚‚) :
    DÌƒ_ Î±(Ïâ‚ âŠ— Ïâ‚‚â€–Ïƒâ‚ âŠ— Ïƒâ‚‚) = DÌƒ_ Î±(Ïâ‚â€–Ïƒâ‚) + DÌƒ_ Î±(Ïâ‚‚â€–Ïƒâ‚‚) := by
  dsimp [SandwichedRelRentropy]
  sorry
  -- split_ifs
  -- Â· sorry
  -- Â· sorry
  -- Â· sorry
  /-
  handle the kernels of tensor products
  log of âŠ— is (log A âŠ— I) + (I âŠ— log B)
  rinner distributes over sub and add
  rinner of âŠ— is mul of rinner
  -/

@[simp]
theorem sandwichedRelRentropy_relabel {Î± : â„} (Ï Ïƒ : MState d) (e : dâ‚‚ â‰ƒ d) :
    DÌƒ_ Î±(Ï.relabel eâ€–Ïƒ.relabel e) = DÌƒ_ Î±(Ïâ€–Ïƒ) := by
  simp only [SandwichedRelRentropy, MState.relabel_M]
  rw [HermitianMat.ker_reindex_le_iff] --Why doesn't this `simp`? Because it's an if condition, I'm guessing
  simp

@[simp]
theorem sandwichedRelRentropy_self {d : Type*} [Fintype d] [DecidableEq d] {Î± : â„}
    (hÎ± : 0 < Î±) (Ï : MState d) :
  --Technically this holds for all Î± except for `-1` and `0`. But those are stupid.
  --TODO: Maybe SandwichedRelRentropy should actually be defined differently for Î± = 0?
    DÌƒ_ Î±(Ïâ€–Ï) = 0 := by
  simp? [SandwichedRelRentropy, NNReal.eq_iff] says
    simp only [SandwichedRelRentropy, le_refl, â†“reduceIte, sub_self, HermitianMat.inner_zero,
    ENNReal.coe_eq_zero, NNReal.eq_iff, NNReal.coe_mk, NNReal.coe_zero, ite_eq_left_iff,
    div_eq_zero_iff, Real.log_eq_zero]
  intro hÎ±
  left; right; left
  rw [HermitianMat.pow_eq_cfc, HermitianMat.pow_eq_cfc]
  nth_rw 1 [â† HermitianMat.cfc_id Ï.M]
  rw [HermitianMat.cfc_conj, â† HermitianMat.cfc_comp]
  conv =>
    enter [1, 1]
    equals Ï.M.cfc id =>
      apply HermitianMat.cfc_congr_of_zero_le Ï.zero_le
      intro i (hi : 0 â‰¤ i)
      simp
      rw [â† Real.rpow_mul_natCast hi, â† Real.rpow_one_add' hi]
      Â· rw [â† Real.rpow_mul hi]
        field_simp
        ring_nf
        exact Real.rpow_one i
      Â· field_simp; ring_nf; positivity
  simp

open ComplexOrder in
@[aesop (rule_sets := [finiteness]) unsafe apply]
theorem sandwichedRelEntropy_ne_top {Î± : â„} {d : Type*} [Fintype d] [DecidableEq d] {Ï Ïƒ : MState d}
    (hÏƒ : Ïƒ.m.PosDef) : DÌƒ_ Î±(Ïâ€–Ïƒ) â‰  âŠ¤ := by
  have h : Ïƒ.M.ker = âŠ¥ := hÏƒ.toLin_ker_eq_bot
  simp [SandwichedRelRentropy, h]

@[fun_prop]
theorem sandwichedRelRentropy.continuousOn {d : Type*} [Fintype d] [DecidableEq d] (Ï Ïƒ : MState d) :
    ContinuousOn (fun Î± => DÌƒ_ Î±(Ïâ€–Ïƒ)) (Set.Ioi 0) := by
  --If this turns out too hard, we just need `ContinousAt f 1`.
  --If that's still too hard, we really _just_ need that `(ğ“[â‰ ] 1).tendsto f (f 1)`.
  sorry

/-- The Data Processing Inequality for the Sandwiched Renyi relative entropy.
Proved in `https://arxiv.org/pdf/1306.5920`. Seems kind of involved. -/
theorem sandwichedRenyiEntropy_DPI {d dâ‚‚ : Type*} [Fintype d] [DecidableEq d] [Fintype dâ‚‚] [DecidableEq dâ‚‚]
    {Î± : â„} (hÎ± : 1 â‰¤ Î±) (Ï Ïƒ : MState d) (Î¦ : CPTPMap d dâ‚‚) : DÌƒ_ Î±(Î¦ Ïâ€–Î¦ Ïƒ) â‰¤ DÌƒ_ Î±(Ïâ€–Ïƒ) := by
  --If we want, we can prove this just for 1 < Î±, and then use continuity (above) to take the limit as
  -- Î± â†’ 1.
  sorry

open Classical in
/-- The quantum relative entropy `ğƒ(Ïâ€–Ïƒ) := Tr[Ï (log Ï - log Ïƒ)]`. -/
def qRelativeEnt (Ï Ïƒ : MState d) : ENNReal :=
  DÌƒ_1(Ïâ€–Ïƒ)

notation "ğƒ(" Ï "â€–" Ïƒ ")" => qRelativeEnt Ï Ïƒ

/-- Quantum relative entropy as `Tr[Ï (log Ï - log Ïƒ)]` when supports are correct. -/
theorem qRelativeEnt_ker {Ï Ïƒ : MState d} (h : Ïƒ.M.ker â‰¤ Ï.M.ker) :
    ğƒ(Ïâ€–Ïƒ).toEReal = Ï.M.inner (HermitianMat.log Ï - HermitianMat.log Ïƒ) := by
  simp [qRelativeEnt, SandwichedRelRentropy, h, EReal.coe_nnreal_eq_coe_real]

/-- The quantum relative entropy is unchanged by `MState.relabel` -/
@[simp]
theorem qRelativeEnt_relabel (Ï Ïƒ : MState d) (e : dâ‚‚ â‰ƒ d) :
    ğƒ(Ï.relabel eâ€–Ïƒ.relabel e) = ğƒ(Ïâ€–Ïƒ) := by
  simp [qRelativeEnt]

/-- "Formula for conversion from operator inequality to quantum relative entropy",
-- Proposition S17 of https://arxiv.org/pdf/2401.01926v2 -/
theorem qRelativeEnt_op_le {Ï Ïƒ : MState d} {Î± : â„} (hpos : 0 < Î±) (h : Ï.M â‰¤ Î± â€¢ Ïƒ.M) :
    ğƒ(Ïâ€–Ïƒ) â‰¤ ENNReal.ofReal (Real.log Î±) := by
  sorry

@[gcongr]
theorem qRelEntropy_heq_congr {dâ‚ dâ‚‚ : Type u} [Fintype dâ‚] [DecidableEq dâ‚] [Fintype dâ‚‚] [DecidableEq dâ‚‚]
      {Ïâ‚ Ïƒâ‚ : MState dâ‚} {Ïâ‚‚ Ïƒâ‚‚ : MState dâ‚‚} (hd : dâ‚ = dâ‚‚) (hÏ : Ïâ‚ â‰ Ïâ‚‚) (hÏƒ : Ïƒâ‚ â‰ Ïƒâ‚‚) :
    ğƒ(Ïâ‚â€–Ïƒâ‚) = ğƒ(Ïâ‚‚â€–Ïƒâ‚‚) := by
  rw [heq_iff_exists_eq_cast] at hÏ hÏƒ
  obtain âŸ¨_, rflâŸ© := hÏ
  obtain âŸ¨_, rflâŸ© := hÏƒ
  simp [â† MState.relabel_cast _ hd]

/-- Quantum relative entropy when Ïƒ has full rank -/
theorem qRelativeEnt_rank {Ï Ïƒ : MState d} (h : Ïƒ.M.ker = âŠ¥) :
    (ğƒ(Ïâ€–Ïƒ) : EReal) = Ï.M.inner (HermitianMat.log Ï - HermitianMat.log Ïƒ) := by
  apply qRelativeEnt_ker
  simp only [h, bot_le]

/-- The quantum relative entropy is additive when the inputs are product states -/
@[simp]
theorem qRelativeEnt_additive (Ïâ‚ Ïƒâ‚ : MState dâ‚) (Ïâ‚‚ Ïƒâ‚‚ : MState dâ‚‚) :
    ğƒ(Ïâ‚ âŠ— Ïâ‚‚â€–Ïƒâ‚ âŠ— Ïƒâ‚‚) = ğƒ(Ïâ‚â€–Ïƒâ‚) + ğƒ(Ïâ‚‚â€–Ïƒâ‚‚) := by
  simp [qRelativeEnt]

--PULLOUT
attribute [fun_prop] LowerSemicontinuous
attribute [fun_prop] LowerSemicontinuousOn
attribute [fun_prop] LowerSemicontinuous.lowerSemicontinuousOn

theorem _root_.IsCompact.exists_isMinOn_lowerSemicontinuousOn {Î± Î² : Type*}
  [LinearOrder Î±] [TopologicalSpace Î±] [TopologicalSpace Î²] [ClosedIicTopology Î±]
  {s : Set Î²} (hs : IsCompact s) (ne_s : s.Nonempty) {f : Î² â†’ Î±} (hf : LowerSemicontinuousOn f s) :
    âˆƒ x âˆˆ s, IsMinOn f s x := by
  --Thanks Aristotle
  -- By the Extreme Value Theorem for lower semicontinuous functions on compact sets, there exists x in s such that f(x) is the minimum value of f on s.
  have h_extreme : âˆƒ x âˆˆ s, âˆ€ y âˆˆ s, f x â‰¤ f y := by
    by_contra! h;
    choose! g hg using h;
    -- For each $x \in s$, since $f$ is lower semicontinuous at $x$, there exists a neighborhood $U_x$ of $x$ such that $f(y) > f(g(x))$ for all $y \in U_x \cap s$.
    have h_neighborhood : âˆ€ x âˆˆ s, âˆƒ U : Set Î², IsOpen U âˆ§ x âˆˆ U âˆ§ âˆ€ y âˆˆ U âˆ© s, f y > f (g x) := by
      intro x hx;
      have := hf x hx;
      rcases mem_nhdsWithin_iff_exists_mem_nhds_inter.mp ( this ( f ( g x ) ) ( hg x hx |>.2 ) ) with âŸ¨ U, hU, hU' âŸ©;
      exact âŸ¨ interior U, isOpen_interior, mem_interior_iff_mem_nhds.mpr hU, fun y hy => hU' âŸ¨ interior_subset hy.1, hy.2 âŸ© âŸ©;
    choose! U hU using h_neighborhood;
    -- Since $s$ is compact, the open cover $\{U_x \cap s \mid x \in s\}$ has a finite subcover.
    obtain âŸ¨t, htâŸ© : âˆƒ t : Finset Î², (âˆ€ x âˆˆ t, x âˆˆ s) âˆ§ s âŠ† â‹ƒ x âˆˆ t, U x âˆ© s := by
      -- Since $s$ is compact, the open cover $\{U_x \mid x \in s\}$ has a finite subcover.
      obtain âŸ¨t, htâŸ© : âˆƒ t : Finset Î², (âˆ€ x âˆˆ t, x âˆˆ s) âˆ§ s âŠ† â‹ƒ x âˆˆ t, U x := by
        exact hs.elim_nhds_subcover U fun x hx => IsOpen.mem_nhds ( hU x hx |>.1 ) ( hU x hx |>.2.1 );
      exact âŸ¨ t, ht.1, fun x hx => by rcases Set.mem_iUnionâ‚‚.1 ( ht.2 hx ) with âŸ¨ y, hy, hy' âŸ© ; exact Set.mem_iUnionâ‚‚.2 âŸ¨ y, hy, âŸ¨ hy', hx âŸ© âŸ© âŸ©;
    -- Since $t$ is finite, there exists $x \in t$ such that $f(g(x))$ is minimal.
    obtain âŸ¨x, hxâŸ© : âˆƒ x âˆˆ t, âˆ€ y âˆˆ t, f (g x) â‰¤ f (g y) := by
      apply_rules [ Finset.exists_min_image ];
      -- Since $s$ is nonempty, there exists some $y \in s$.
      obtain âŸ¨y, hyâŸ© : âˆƒ y, y âˆˆ s := ne_s;
      exact Exists.elim ( Set.mem_iUnionâ‚‚.1 ( ht.2 hy ) ) fun x hx => âŸ¨ x, hx.1 âŸ©;
    obtain âŸ¨ y, hy âŸ© := ht.2 ( hg x ( ht.1 x hx.1 ) |>.1 );
    simp_all only [Set.mem_inter_iff, and_self, and_true, gt_iff_lt, and_imp, Set.mem_range]
    obtain âŸ¨left, rightâŸ© := ht
    obtain âŸ¨left_1, right_1âŸ© := hx
    obtain âŸ¨âŸ¨w, rflâŸ©, right_2âŸ© := hy
    simp_all only [Set.mem_iUnion, Set.mem_inter_iff, and_true, exists_prop]
    obtain âŸ¨left_2, right_2âŸ© := right_2
    exact lt_irrefl _ ( lt_of_le_of_lt ( right_1 _ left_2 ) ( hU _ ( left _ left_2 ) |>.2.2 _ right_2 ( hg _ ( left _ left_1 ) ) ) );
  -- By definition of IsMinOn, we need to show that for all y in s, f(x) â‰¤ f(y). This is exactly what h_extreme provides.
  obtain âŸ¨x, hx_s, hx_minâŸ© := h_extreme;
  use x, hx_s;
  exact hx_min


/-- Relative entropy is lower semicontinuous (in each argument, actually, but we only need in the
latter here). Will need the fact that all the cfc / eigenvalue stuff is continuous, plus
carefully handling what happens with the kernel subspace, which will make this a pain. -/
@[fun_prop]
theorem qRelativeEnt.LowerSemicontinuous (Ï : MState d) : LowerSemicontinuous fun Ïƒ => ğƒ(Ïâ€–Ïƒ) := by
  sorry

/-- Joint convexity of Quantum relative entropy. We can't state this with `ConvexOn` because that requires
an `AddCommMonoid`, which `MState`s are not. Instead we state it with `Mixable`.

TODO:
 * Add the `Mixable` instance that infers from the `Coe` so that the right hand side can be written as
`p [ğƒ(Ïâ‚â€–Ïƒâ‚) â†” ğƒ(Ïâ‚‚â€–Ïƒâ‚‚)]`
 * Define (joint) convexity as its own thing - a `ConvexOn` for `Mixable` types.
 * Maybe, more broadly, find a way to make `ConvexOn` work with the subset of `Matrix` that corresponds to `MState`.
-/
theorem qRelativeEnt_joint_convexity :
  âˆ€ (Ïâ‚ Ïâ‚‚ Ïƒâ‚ Ïƒâ‚‚ : MState d), âˆ€ (p : Prob),
    ğƒ(p [Ïâ‚ â†” Ïâ‚‚]â€–p [Ïƒâ‚ â†” Ïƒâ‚‚]) â‰¤ p * ğƒ(Ïâ‚â€–Ïƒâ‚) + (1 - p) * ğƒ(Ïâ‚‚â€–Ïƒâ‚‚) := by
  sorry

@[simp]
theorem qRelEntropy_self {d : Type*} [Fintype d] [DecidableEq d] (Ï : MState d) :
    ğƒ(Ïâ€–Ï) = 0 := by
  simp [qRelativeEnt]

open ComplexOrder in
@[aesop (rule_sets := [finiteness]) unsafe apply]
theorem qRelativeEnt_ne_top {d : Type*} [Fintype d] [DecidableEq d] {Ï Ïƒ : MState d}
    (hÏƒ : Ïƒ.m.PosDef) : ğƒ(Ïâ€–Ïƒ) â‰  âŠ¤ := by
  rw [qRelativeEnt]
  finiteness

/-- `I(A:B) = ğƒ(Ïá´¬á´®â€–Ïá´¬ âŠ— Ïá´®)` -/
theorem qMutualInfo_as_qRelativeEnt (Ï : MState (dA Ã— dB)) :
    qMutualInfo Ï = (ğƒ(Ïâ€–Ï.traceRight âŠ— Ï.traceLeft) : EReal) :=
  sorry

end relative_entropy


================================================================================
FILE: QuantumInfo/Finite/MState.lean
TYPE: Lean 4
SIZE: 31166 characters
================================================================================

import QuantumInfo.ForMathlib
import ClassicalInfo.Distribution
import QuantumInfo.Finite.Braket

import Mathlib.Logic.Equiv.Basic

/-!
Finite dimensional quantum mixed states, Ï.

The same comments apply as in `Braket`:

These could be done with a Hilbert space of Fintype, which would look like
```lean4
(H : Type*) [NormedAddCommGroup H] [InnerProductSpace â„‚ H] [CompleteSpace H] [FiniteDimensional â„‚ H]
```
or by choosing a particular `Basis` and asserting it is `Fintype`. But frankly it seems easier to
mostly focus on the basis-dependent notion of `Matrix`, which has the added benefit of an obvious
"classical" interpretation (as the basis elements, or diagonal elements of a mixed state). In that
sense, this quantum theory comes with the a particular classical theory always preferred.

Important definitions:
 * `instMixable`: the `Mixable` instance allowing convex combinations of `MState`s
 * `ofClassical`: Mixed states representing classical distributions
 * `purity`: The purity `Tr[Ï^2]` of a state
 * `spectrum`: The spectrum of the matrix
 * `uniform`: The maximally mixed state
 * `mix`: The total state corresponding to an ensemble
 * `average`: Averages a function over an ensemble, with appropriate weights
-/

noncomputable section

open BigOperators
open ComplexConjugate
open HermitianMat
open scoped Matrix ComplexOrder

/-- A **mixed quantum state** is a PSD matrix with trace 1.

We don't `extend (M : HermitianMat d â„‚)` because that gives an annoying thing where
`M` is actually a `Subtype`, which means `Ï.M.foo` notation doesn't work. -/
@[ext]
structure MState (d : Type*) [Fintype d] [DecidableEq d] where
  M : HermitianMat d â„‚
  zero_le : 0 â‰¤ M
  tr : HermitianMat.trace M = 1

namespace MState

variable {d dâ‚ dâ‚‚ dâ‚ƒ : Type*}
variable [Fintype d] [Fintype dâ‚] [Fintype dâ‚‚] [Fintype dâ‚ƒ]
variable [DecidableEq d] [DecidableEq dâ‚] [DecidableEq dâ‚‚] [DecidableEq dâ‚ƒ]

attribute [coe] MState.M
instance instCoe : Coe (MState d) (HermitianMat d â„‚) := âŸ¨MState.MâŸ©

attribute [simp] MState.tr

/-- The underlying `Matrix` in an MState. Prefer `MState.M` for the `HermitianMat`. -/
def m (Ï : MState d) : Matrix d d â„‚ := Ï.M.toMat

@[simp]
theorem toMat_M (Ï : MState d) : Ï.M.toMat = Ï.m := by
  rfl

--XXX These are methods that directly reference the matrix, "m" or ".val".
-- We'd like to remove these (where possible) so that mostly go through HermitianMat
-- where possible.
theorem pos (Ï : MState d) : Ï.m.PosSemidef :=
  HermitianMat.zero_le_iff.mp Ï.zero_le

/-- Every mixed state is Hermitian. -/
theorem Hermitian (Ï : MState d) : Ï.m.IsHermitian :=
  Ï.pos.left

@[simp]
theorem tr' (Ï : MState d) : Ï.m.trace = 1 := by
  rw [MState.m.eq_def, â† HermitianMat.trace_eq_trace_rc, Ï.tr]
  simp

theorem ext_m {Ïâ‚ Ïâ‚‚ : MState d} (h : Ïâ‚.m = Ïâ‚‚.m) : Ïâ‚ = Ïâ‚‚ := by
  rw [MState.mk.injEq]
  ext1
  exact h
--XXX

/-- The map from mixed states to their matrices is injective -/
theorem toMat_inj : (MState.m (d := d)).Injective :=
  fun _ _ h â†¦ by ext1; ext1; exact h

theorem M_Injective : Function.Injective (MState.M (d := d)) := by
  intro _ _
  exact MState.ext

variable (d) in
/-- The matrices corresponding to MStates are `Convex â„` -/
theorem convex : Convex â„ (Set.range (MState.M (d := d))) := by
  simp only [Convex, Set.mem_range, StarConvex,
    forall_exists_index, forall_apply_eq_imp_iff]
  intro x y a b ha hb hab
  replace hab : a + b = (1 : â„‚) := by norm_cast
  have := HermitianMat.convex_cone x.zero_le y.zero_le ha hb
  exact âŸ¨âŸ¨_, this, by simpa using mod_cast habâŸ©, rflâŸ©

instance instMixable : Mixable (HermitianMat d â„‚) (MState d) where
  to_U := MState.M
  to_U_inj := MState.ext
  mkT {u} := fun h â†¦
    âŸ¨âŸ¨u, h.casesOn fun t ht â†¦ ht â–¸ t.zero_le,
      h.casesOn fun t ht â†¦ ht â–¸ t.trâŸ©, rflâŸ©
  convex := convex d

--An MState is a witness that d is nonempty.
instance nonempty (Ï : MState d) : Nonempty d := by
  by_contra h
  simpa [HermitianMat.trace_eq_re_trace, not_nonempty_iff.mp h] using Ï.tr

-- Could have used properties of Ï.spectrum
theorem eigenvalue_nonneg (Ï : MState d) : âˆ€ i, 0 â‰¤ Ï.Hermitian.eigenvalues i := by
  apply (Matrix.PosSemidef.nonneg_iff_eigenvalue_nonneg Ï.Hermitian).mp
  exact Ï.zero_le

-- Could have used properties of  Ï.spectrum
theorem eigenvalue_le_one (Ï : MState d) : âˆ€ i, Ï.Hermitian.eigenvalues i â‰¤ 1 := by
  intro i
  convert Finset.single_le_sum (fun y _ â†¦ Ï.pos.eigenvalues_nonneg y) (Finset.mem_univ i)
  rw [Ï.M.sum_eigenvalues_eq_trace, Ï.tr]

theorem le_one (Ï : MState d) : Ï.M â‰¤ 1 := by
  rw [Subtype.mk_le_mk]
  simp only [HermitianMat.val_eq_coe, selfAdjoint.val_one]
  suffices h : Ï.m â‰¤ (1 : â„) â€¢ 1 by
    rw [one_smul] at h
    exact h
  apply (Matrix.PosSemidef.le_smul_one_of_eigenvalues_iff Ï.pos 1).mp
  exact eigenvalue_le_one Ï

/-- The inner product of two MState's, as a real number between 0 and 1. -/
def inner (Ï : MState d) (Ïƒ : MState d) : Prob :=
  âŸ¨Ï.M.inner Ïƒ.M, Ï.M.inner_ge_zero Ï.zero_le Ïƒ.zero_le,
    (Ï.M.inner_le_mul_trace Ï.zero_le Ïƒ.zero_le).trans (by simp)âŸ©

section exp_val

def exp_val_â„‚ (Ï : MState d) (T : Matrix d d â„‚) : â„‚ :=
  (T * Ï.m).trace

--TODO: Bundle as a ContinuousLinearMap.
/-- The **expectation value** of an operator on a quantum state. -/
def exp_val (Ï : MState d) (T : HermitianMat d â„‚) : â„ :=
  Ï.M.inner T

theorem exp_val_nonneg {T : HermitianMat d â„‚} (h : 0 â‰¤ T) (Ï : MState d) : 0 â‰¤ Ï.exp_val T :=
  HermitianMat.inner_ge_zero Ï.zero_le h

@[simp]
theorem exp_val_zero (Ï : MState d) : Ï.exp_val 0 = 0 := by
  simp [MState.exp_val]

@[simp]
theorem exp_val_one (Ï : MState d) : Ï.exp_val 1 = 1 := by
  simp [MState.exp_val]

theorem exp_val_le_one {T : HermitianMat d â„‚} (h : T â‰¤ 1) (Ï : MState d) : Ï.exp_val T â‰¤ 1 := by
  have hmono := HermitianMat.inner_mono Ï.zero_le h
  rwa [HermitianMat.inner_one Ï.M, Ï.tr] at hmono

theorem exp_val_prob {T : HermitianMat d â„‚} (h : 0 â‰¤ T âˆ§ T â‰¤ 1) (Ï : MState d) :
    0 â‰¤ Ï.exp_val T âˆ§ Ï.exp_val T â‰¤ 1 :=
  âŸ¨Ï.exp_val_nonneg h.1, Ï.exp_val_le_one h.2âŸ©

theorem exp_val_sub (Ï : MState d) (A B : HermitianMat d â„‚) :
    Ï.exp_val (A - B) = Ï.exp_val A - Ï.exp_val B := by
  simp [exp_val, HermitianMat.inner_left_sub]

/-- If a PSD observable `A` has expectation value of 0 on a state `Ï`, it must entirely contain the
support of `Ï` in its kernel. -/
theorem exp_val_eq_zero_iff (Ï : MState d) {A : HermitianMat d â„‚} (hAâ‚ : 0 â‰¤ A)   :
    Ï.exp_val A = 0 â†” Ï.M.support â‰¤ A.ker := by
  exact Ï.M.inner_zero_iff Ï.zero_le hAâ‚

/-- If an observable `A` has expectation value of 1 on a state `Ï`, it must entirely contain the
support of `Ï` in its 1-eigenspace. -/
theorem exp_val_eq_one_iff (Ï : MState d) {A : HermitianMat d â„‚} (hAâ‚‚ : A â‰¤ 1) :
    Ï.exp_val A = 1 â†” Ï.M.support â‰¤ (1 - A).ker := by
  rw [â† exp_val_eq_zero_iff Ï (A := 1 - A) (HermitianMat.zero_le_iff.mpr hAâ‚‚)]
  rw [exp_val_sub, exp_val_one]
  rw [sub_eq_zero, eq_comm]

theorem exp_val_add (Ï : MState d) (A B : HermitianMat d â„‚) :
    Ï.exp_val (A + B) = Ï.exp_val A + Ï.exp_val B := by
  simp [MState.exp_val, HermitianMat.inner_left_distrib]

@[simp]
theorem exp_val_smul (Ï : MState d) (r : â„) (A : HermitianMat d â„‚) :
    Ï.exp_val (r â€¢ A) = r * Ï.exp_val A := by
  simp [MState.exp_val]

@[gcongr]
theorem exp_val_le_exp_val (Ï : MState d) {A B : HermitianMat d â„‚} (h : A â‰¤ B) :
    Ï.exp_val A â‰¤ Ï.exp_val B := by
  simp only [MState.exp_val]
  refine Ï.M.inner_mono Ï.zero_le h

end exp_val

section pure

/-- A mixed state can be constructed as a pure state arising from a ket. -/
def pure (Ïˆ : Ket d) : MState d where
  M := {
    val := Matrix.vecMulVec Ïˆ (Ïˆ : Bra d)
    property := (Matrix.PosSemidef.outer_self_conj Ïˆ).1
  }
  zero_le := HermitianMat.zero_le_iff.mpr (.outer_self_conj Ïˆ)
  tr := by
    have hâ‚ (x) : Ïˆ x * conj (Ïˆ x) = Complex.normSq (Ïˆ x) := by
      rw [mul_comm, Complex.normSq_eq_conj_mul_self]
    simp [HermitianMat.trace_eq_re_trace, Matrix.trace, Matrix.vecMulVec_apply, Bra.eq_conj, hâ‚]
    exact Ïˆ.normalized

@[simp]
theorem pure_of (Ïˆ : Ket d) : (pure Ïˆ).m i j = (Ïˆ i) * conj (Ïˆ j) := by
  rfl

/-- The purity of a state is Tr[Ï^2]. This is a `Prob`, because it is always between zero and one. -/
def purity (Ï : MState d) : Prob :=
  âŸ¨Ï.M.inner Ï.M, âŸ¨HermitianMat.inner_ge_zero Ï.zero_le Ï.zero_le,
    by simpa using  HermitianMat.inner_le_mul_trace Ï.zero_le Ï.zero_leâŸ©âŸ©

/-- The eigenvalue spectrum of a mixed quantum state, as a `Distribution`. -/
def spectrum [DecidableEq d] (Ï : MState d) : Distribution d :=
  Distribution.mk'
    (Ï.M.H.eigenvalues Â·)
    (Ï.pos.eigenvalues_nonneg Â·)
    (by rw [Ï.M.sum_eigenvalues_eq_trace, Ï.tr])

/-- The specturm of a pure state is (1,0,0,...), i.e. a constant distribution. -/
theorem spectrum_pure_eq_constant (Ïˆ : Ket d) :
    âˆƒ i, (pure Ïˆ).spectrum = Distribution.constant i := by
  let Ï := pure Ïˆ
  -- Prove 1 is in the spectrum of pure Ïˆ by exhibiting an eigenvector with value 1.
  have : âˆƒi, (pure Ïˆ).spectrum i = 1 := by
    simp [spectrum, Distribution.mk']
    have hEig : âˆƒi, (pure Ïˆ).M.H.eigenvalues i = 1 := by
      -- Prove Ïˆ is an eigenvector of Ï = pure Ïˆ
      have hv : Ï.M *áµ¥ Ïˆ = Ïˆ := by
        ext
        simp_rw [Ï, pure, Matrix.mulVec, HermitianMat.toMat, Matrix.vecMulVec_apply, dotProduct,
        Bra.apply', Ket.apply, mul_assoc, â† Finset.mul_sum, â† Complex.normSq_eq_conj_mul_self,
        â† Complex.ofReal_sum, â† Ket.apply, Ïˆ.normalized, Complex.ofReal_one, mul_one]
      let U : Matrix.unitaryGroup d â„‚ := star Ï.M.H.eigenvectorUnitary -- Diagonalizing unitary of Ï
      let w : d â†’ â„‚ := U *áµ¥ Ïˆ
      -- Prove w = U Ïˆ is an eigenvector of the diagonalized matrix of Ï = pure Ïˆ
      have hDiag : Matrix.diagonal (RCLike.ofReal âˆ˜ Ï.M.H.eigenvalues) *áµ¥ w = w := by
        simp_rw [â†Matrix.IsHermitian.star_mul_self_mul_eq_diagonal, eq_comm,
        â†Matrix.mulVec_mulVec, w, U, Matrix.mulVec_mulVec] -- Uses spectral theorem
        simp_all
        rw [â†Matrix.mulVec_mulVec, hv]
      -- Prove w = U Ïˆ is nonzero by contradiction
      have hwNonZero : âˆƒj, w j â‰  0 := by
        by_contra hwZero
        simp at hwZero
        rw [â†funext_iff] at hwZero
        -- If w is zero, then Ïˆ is zero, since U is invertible
        have hÏˆZero : âˆ€x, Ïˆ x = 0 := by
          apply congr_fun
          -- Prove U is invertible
          have hUdetNonZero : (U : Matrix d d â„‚).det â‰  0 := by
            by_contra hDetZero
            obtain âŸ¨u, huUniâŸ© := U
            have h0uni: 0 âˆˆ unitary â„‚ := by
              rw [â†hDetZero]
              simp
              exact Matrix.det_of_mem_unitary huUni
            rw [unitary.mem_iff] at h0uni
            simp_all
          exact Matrix.eq_zero_of_mulVec_eq_zero hUdetNonZero hwZero
        -- Reach an contradiction that Ïˆ has norm 0
        have hÏˆn := Ket.normalized Ïˆ
        have hnormZero : âˆ€ x : d, Complex.normSq (Ïˆ x) = 0 := fun x => by
          rw [hÏˆZero x, Complex.normSq_zero]
        have hsumZero : âˆ‘ x : d, Complex.normSq (Ïˆ x) = 0 := by
          apply Finset.sum_eq_zero
          intros x _
          exact hnormZero x
        simp_all
      obtain âŸ¨j, hwNonZero'âŸ© := hwNonZero
      have hDiagj := congr_fun hDiag j
      rw [Matrix.mulVec_diagonal, mul_eq_rightâ‚€ hwNonZero'] at hDiagj
      use j
      simp_all
    obtain âŸ¨i, hEig'âŸ© := hEig
    use i
    ext
    exact hEig'
  --If 1 is in a distribution, the distribution is a constant.
  obtain âŸ¨i, hiâŸ© := this
  use i
  exact Distribution.constant_of_exists_one hi

/-- If the specturm of a mixed state is (1,0,0...) i.e. a constant distribution, it is
 a pure state. -/
theorem pure_of_constant_spectrum (Ï : MState d) (h : âˆƒ i, Ï.spectrum = Distribution.constant i) :
    âˆƒ Ïˆ, Ï = pure Ïˆ := by
  obtain âŸ¨i, h'âŸ© := h
  -- Translate assumption to eigenvalues being (1,0,0,...)
  have hEig : Ï.M.H.eigenvalues = fun x => if x = i then 1 else 0 := by
    ext x
    simp [spectrum, Distribution.constant, Distribution.mk'] at h'
    rw [Subtype.mk.injEq] at h'
    have h'x := congr_fun h' x
    rw [if_congr (Eq.comm) (Eq.refl 1) (Eq.refl 0)]
    rw [Prob.eq_iff] at h'x
    dsimp at h'x
    rw [h'x]
    split_ifs
    case pos => rfl
    case neg => rfl
  -- Choose the eigenvector v of Ï with eigenvalue 1 to make Ïˆ
  let âŸ¨u, huUniâŸ© := Ï.M.H.eigenvectorUnitary -- Diagonalizing unitary of Ï
  let D : Matrix d d â„‚ := Matrix.diagonal (RCLike.ofReal âˆ˜ Ï.M.H.eigenvalues) -- Diagonal matrix of Ï
  let v : EuclideanSpace â„‚ d := Ï.M.H.eigenvectorBasis i
  -- Prove v is normalized
  have hUvNorm : âˆ‘ x, â€–v xâ€–^2 = 1 := by
    have hinnerv : Inner.inner â„‚ v v = 1 := by
      have := Ï.M.H.eigenvectorBasis.orthonormal
      rw [orthonormal_iff_ite] at this
      convert this i i
      simp
    simp only [PiLp.inner_apply, RCLike.inner_apply, Complex.mul_conj'] at hinnerv
    rw [â† Fintype.sum_equiv (Equiv.refl d) _ (fun x => (Complex.ofReal â€–v xâ€–) ^ 2) (fun x => Complex.ofReal_pow â€–v xâ€– 2)] at hinnerv
    rw [â† Complex.ofReal_sum Finset.univ (fun x => â€–v xâ€– ^ 2), Complex.ofReal_eq_one] at hinnerv
    exact hinnerv
  let Ïˆ : Ket d := âŸ¨v, hUvNormâŸ© -- Construct Ïˆ
  use Ïˆ
  ext j k
  -- Use spectral theorem to prove that Ï = pure Ïˆ
  rw [Matrix.IsHermitian.spectral_theorem Ï.M.H, Matrix.mul_apply]
  simp [Ïˆ, v, hEig, -toMat_M]
  have hsum : âˆ€ x âˆˆ Finset.univ, x âˆ‰ ({i} : Finset d) â†’ (Ï.M.H.eigenvectorBasis x j) * (â†‘(if x = i then 1 else 0) : â„) * (starRingEnd â„‚) (Ï.Hermitian.eigenvectorBasis x k) = 0 := by
    intros x hx hxnoti
    rw [Finset.mem_singleton] at hxnoti
    rw [if_neg hxnoti, Complex.ofReal_zero]
    ring
  simp_rw [â†Finset.sum_subset (Finset.subset_univ {i}) hsum, Finset.sum_singleton, reduceIte, Complex.ofReal_one, mul_one]
  rfl

/-- A state Ï is pure iff its spectrum is (1,0,0,...) i.e. a constant distribution. -/
theorem pure_iff_constant_spectrum (Ï : MState d) : (âˆƒ Ïˆ, Ï = pure Ïˆ) â†”
    âˆƒ i, Ï.spectrum = Distribution.constant i :=
  âŸ¨fun h â†¦ h.rec fun Ïˆ hâ‚‚ â†¦ hâ‚‚ â–¸ spectrum_pure_eq_constant Ïˆ,
  pure_of_constant_spectrum ÏâŸ©

theorem pure_iff_purity_one (Ï : MState d) : (âˆƒ Ïˆ, Ï = pure Ïˆ) â†” Ï.purity = 1 := by
  --purity = exp(-Collision entropy)
  --purity eq 1 iff collision entropy is zero
  --entropy is zero iff distribution is constant
  --distribution is constant iff pure
  sorry

end pure

section prod

def prod (Ïâ‚ : MState dâ‚) (Ïâ‚‚ : MState dâ‚‚) : MState (dâ‚ Ã— dâ‚‚) where
  M := Ïâ‚.M âŠ—â‚– Ïâ‚‚.M
  zero_le := HermitianMat.zero_le_iff.mpr (Ïâ‚.pos.PosSemidef_kronecker Ïâ‚‚.pos)
  tr := by simp

infixl:100 " âŠ— " => MState.prod

/-- The product of pure states is a pure product state , `Ket.prod`. -/
theorem pure_prod_pure (Ïˆâ‚ : Ket dâ‚) (Ïˆâ‚‚ : Ket dâ‚‚) : pure (Ïˆâ‚ âŠ— Ïˆâ‚‚) = (pure Ïˆâ‚) âŠ— (pure Ïˆâ‚‚) := by
  ext
  simp [Ket.prod, Ket.apply, prod]
  ac_rfl

end prod

/-- A representation of a classical distribution as a quantum state, diagonal in the given basis. -/
def ofClassical (dist : Distribution d) : MState d where
  M := HermitianMat.diagonal (fun x â†¦ dist x)
  zero_le := HermitianMat.zero_le_iff.mpr (by simp [HermitianMat.diagonal, Matrix.posSemidef_diagonal_iff])
  tr := by simp [HermitianMat.trace_diagonal]

@[simp]
theorem coe_ofClassical (dist : Distribution d) :
    (MState.ofClassical dist).M = HermitianMat.diagonal (dist Â·) := by
  rfl

theorem ofClassical_pow (dist : Distribution d) (p : â„) :
    (MState.ofClassical dist).M ^ p = HermitianMat.diagonal (fun i â†¦ (dist i) ^ p) := by
  rw [coe_ofClassical]
  convert HermitianMat.diagonal_pow (dist Â·) p

/-- The maximally mixed state. -/
def uniform [Nonempty d] : MState d := ofClassical Distribution.uniform

/-- There is exactly one state on a dimension-1 system. -/
--note that this still takes (and uses) the `Fintype d` and `DecidableEq d` instances on `MState d`.
--Even though instances for those can be derived from `Unique d`, we want this `Unique` instance to
--apply on `@MState d ?x ?y` for _any_ x and y.
instance instUnique [Unique d] : Unique (MState d) where
  default := @uniform _ _ _ _
  uniq := by
    intro Ï
    ext
    have hâ‚ := Ï.tr
    have hâ‚‚ := (@uniform _ _ _ _ : MState d).tr
    simp [Matrix.trace, Unique.eq_default, -MState.tr, HermitianMat.trace_eq_re_trace] at hâ‚ hâ‚‚ âŠ¢
    apply Complex.ext
    Â· exact hâ‚.trans hâ‚‚.symm
    Â· trans 0
      exact Ï.M.Complex_im_eq_zero default
      exact (uniform.M.Complex_im_eq_zero default).symm

/-- There exists a mixed state for every nonempty `d`.
Here, the maximally mixed one is chosen. -/
instance instInhabited [Nonempty d] : Inhabited (MState d) where
  default := uniform

section ptrace

-- TODO:
-- * Partial trace of direct product is the original state

/-- Partial tracing out the left half of a system. -/
def traceLeft (Ï : MState (dâ‚ Ã— dâ‚‚)) : MState dâ‚‚ where
  M := âŸ¨Ï.m.traceLeft, Ï.M.H.traceLeftâŸ©
  zero_le :=  HermitianMat.zero_le_iff.mpr (Ï.pos.traceLeft)
  tr := by simp [trace]

/-- Partial tracing out the right half of a system. -/
def traceRight (Ï : MState (dâ‚ Ã— dâ‚‚)) : MState dâ‚ where
  M := âŸ¨Ï.m.traceRight, Ï.M.H.traceRightâŸ©
  zero_le := HermitianMat.zero_le_iff.mpr (Ï.pos.traceRight)
  tr := by simp [trace]

/-- Taking the direct product on the left and tracing it back out gives the same state. -/
@[simp]
theorem traceLeft_prod_eq (Ïâ‚ : MState dâ‚) (Ïâ‚‚ : MState dâ‚‚) : traceLeft (Ïâ‚ âŠ— Ïâ‚‚) = Ïâ‚‚ := by
  ext
  simp_rw [traceLeft, Matrix.traceLeft, prod]
  have h : (âˆ‘ i : dâ‚, Ïâ‚.M.toMat i i) = 1 := Ïâ‚.tr'
  simp [MState.m, â† Finset.sum_mul, h, -toMat_M]

/-- Taking the direct product on the right and tracing it back out gives the same state. -/
@[simp]
theorem traceRight_prod_eq (Ïâ‚ : MState dâ‚) (Ïâ‚‚ : MState dâ‚‚) : traceRight (Ïâ‚ âŠ— Ïâ‚‚) = Ïâ‚ := by
  ext
  simp_rw [traceRight, Matrix.traceRight, prod]
  have h : (âˆ‘ i : dâ‚‚, Ïâ‚‚.M.toMat i i) = 1 := Ïâ‚‚.tr'
  simp [MState.m, â† Finset.mul_sum, h, -toMat_M]

end ptrace

-- TODO: direct sum (by zero-padding)

--TODO: Spectra of left- and right- partial traces of a pure state are equal.

/-- Spectrum of direct product. There is a permutation Ïƒ so that the spectrum of the direct product of
  Ïâ‚ and Ïâ‚‚, as permuted under Ïƒ, is the pairwise products of the spectra of Ïâ‚ and Ïâ‚‚. -/
theorem spectrum_prod (Ïâ‚ : MState dâ‚) (Ïâ‚‚ : MState dâ‚‚) : âˆƒ(Ïƒ : dâ‚ Ã— dâ‚‚ â‰ƒ dâ‚ Ã— dâ‚‚),
    âˆ€i, âˆ€j, MState.spectrum (Ïâ‚ âŠ— Ïâ‚‚) (Ïƒ (i, j)) = (Ïâ‚.spectrum i) * (Ïâ‚‚.spectrum j) := by
  sorry

--TODO: Spectrum of direct sum. Spectrum of partial trace?

/-- A mixed state is separable iff it can be written as a convex combination of product mixed states. -/
def IsSeparable (Ï : MState (dâ‚ Ã— dâ‚‚)) : Prop :=
  âˆƒ ÏLRs : Finset (MState dâ‚ Ã— MState dâ‚‚), --Finite set of (ÏL, ÏR) pairs
    âˆƒ ps : Distribution ÏLRs, --Distribution over those pairs, an ensemble
      Ï.M = âˆ‘ ÏLR : ÏLRs, (ps ÏLR : â„) â€¢ (Prod.fst ÏLR.val).M âŠ—â‚– (Prod.snd ÏLR.val).M

/-- A product state `MState.prod` is separable. -/
theorem IsSeparable_prod (Ïâ‚ : MState dâ‚) (Ïâ‚‚ : MState dâ‚‚) : IsSeparable (Ïâ‚ âŠ— Ïâ‚‚) := by
  let only := (Ïâ‚, Ïâ‚‚)
  use { only }, Distribution.constant âŸ¨only, Finset.mem_singleton_self onlyâŸ©
  simp [prod, Unique.eq_default, only]

/-- A pure state is separable iff the ket is a product state. -/
theorem pure_separable_iff_IsProd (Ïˆ : Ket (dâ‚ Ã— dâ‚‚)) :
    IsSeparable (pure Ïˆ) â†” Ïˆ.IsProd := by
  sorry

/-- A pure state is separable iff the partial trace on the left is pure. -/
theorem pure_separable_iff_traceLeft_pure (Ïˆ : Ket (dâ‚ Ã— dâ‚‚)) : IsSeparable (pure Ïˆ) â†”
    âˆƒ Ïˆâ‚, pure Ïˆâ‚ = (pure Ïˆ).traceLeft := by
  sorry

--TODO: Separable states are convex

section purification

/-- The purification of a mixed state. Always uses the full dimension of the Hilbert space (d) to
 purify, so e.g. an existing pure state with d=4 still becomes d=16 in the purification. The defining
 property is `MState.traceRight_of_purify`; see also `MState.purify'` for the bundled version. -/
def purify (Ï : MState d) : Ket (d Ã— d) where
  vec := fun (i,j) â†¦
    let Ï2 := Ï.Hermitian.eigenvectorUnitary i j
    Ï2 * (Ï.Hermitian.eigenvalues j).sqrt
  normalized' := by
    have hâ‚ := fun i â†¦ Ï.pos.eigenvalues_nonneg i
    simp [mul_pow, Real.sq_sqrt, hâ‚, Fintype.sum_prod_type_right]
    simp_rw [â† Finset.sum_mul]
    have : âˆ€x, âˆ‘ i : d, â€–Ï.Hermitian.eigenvectorBasis x iâ€– ^ 2 = 1 :=
      sorry
    apply @RCLike.ofReal_injective â„‚
    simp_rw [this, one_mul, Matrix.IsHermitian.sum_eigenvalues_eq_trace]
    exact Ï.tr'

/-- The defining property of purification, that tracing out the purifying system gives the
 original mixed state. -/
@[simp]
theorem purify_spec (Ï : MState d) : (pure Ï.purify).traceRight = Ï := by
  ext i j
  simp_rw [purify, traceRight, Matrix.traceRight]
  simp only [pure_of, Ket.apply]
  simp only [map_mul]
  simp_rw [mul_assoc, mul_comm, â† mul_assoc (Complex.ofReal _), Complex.mul_conj]
  sorry

/-- `MState.purify` bundled with its defining property `MState.traceRight_of_purify`. -/
def purifyX (Ï : MState d) : { Ïˆ : Ket (d Ã— d) // (pure Ïˆ).traceRight = Ï } :=
  âŸ¨Ï.purify, Ï.purify_specâŸ©

end purification

@[simps]
def relabel (Ï : MState dâ‚) (e : dâ‚‚ â‰ƒ dâ‚) : MState dâ‚‚ where
  M := Ï.M.reindex e.symm
  zero_le := (HermitianMat.zero_le_iff.trans (Matrix.posSemidef_submatrix_equiv e)).mpr <| Ï.pos
  tr := by simp [trace]

@[simp]
theorem relabel_m (Ï : MState dâ‚) (e : dâ‚‚ â‰ƒ dâ‚) :
    (Ï.relabel e).m = Ï.m.submatrix e e := by
  rfl

@[simp]
theorem relabel_refl {d : Type*} [Fintype d] [DecidableEq d] (Ï : MState d) :
    Ï.relabel (Equiv.refl d) = Ï := by
  ext
  simp

@[simp]
theorem relabel_relabel {d dâ‚‚ dâ‚ƒ : Type*}
    [Fintype d] [DecidableEq d] [Fintype dâ‚‚] [DecidableEq dâ‚‚] [Fintype dâ‚ƒ] [DecidableEq dâ‚ƒ]
    (Ï : MState d) (e : dâ‚‚ â‰ƒ d) (eâ‚‚ : dâ‚ƒ â‰ƒ dâ‚‚) : (Ï.relabel e).relabel eâ‚‚ = Ï.relabel (eâ‚‚.trans e) := by
  rfl

theorem eq_relabel_iff {dâ‚ dâ‚‚ : Type u} [Fintype dâ‚] [DecidableEq dâ‚] [Fintype dâ‚‚] [DecidableEq dâ‚‚]
    (Ï : MState dâ‚) (Ïƒ : MState dâ‚‚) (h : dâ‚ â‰ƒ dâ‚‚) :
    Ï = Ïƒ.relabel h â†” Ï.relabel h.symm = Ïƒ := by
  simp only [MState.ext_iff, HermitianMat.ext_iff, toMat_M, relabel_m]
  exact âŸ¨(by simp[Â·]), (by simp[â† Â·])âŸ©

theorem relabel_comp {dâ‚ dâ‚‚ dâ‚ƒ : Type*} [Fintype dâ‚] [DecidableEq dâ‚] [Fintype dâ‚‚] [DecidableEq dâ‚‚]
      [Fintype dâ‚ƒ] [DecidableEq dâ‚ƒ] (Ï : MState dâ‚) (e : dâ‚‚ â‰ƒ dâ‚) (f : dâ‚ƒ â‰ƒ dâ‚‚) :
    (Ï.relabel e).relabel f = Ï.relabel (f.trans e) := by
  ext
  simp

theorem relabel_cast {dâ‚ dâ‚‚ : Type u} [Fintype dâ‚] [DecidableEq dâ‚]
    [Fintype dâ‚‚] [DecidableEq dâ‚‚]
       (Ï : MState dâ‚) (e : dâ‚‚ = dâ‚) :
    Ï.relabel (Equiv.cast e) = cast (by have := e.symm; congr <;> (apply Subsingleton.helim; congr)) Ï := by
  ext i j
  simp
  rw [eq_comm] at e
  congr
  Â· apply Subsingleton.helim; congr
  Â· apply Subsingleton.helim; congr
  Â· symm; apply cast_heq
  Â· apply cast_heq
  Â· apply cast_heq

--TODO: Swap and assoc for kets.
--TODO: Connect these to unitaries (when they can be)

/-- The heterogeneous SWAP gate that exchanges the left and right halves of a quantum system.
  This can apply even when the two "halves" are of different types, as opposed to (say) the SWAP
  gate on quantum circuits that leaves the qubit dimensions unchanged. Notably, it is not unitary. -/
def SWAP (Ï : MState (dâ‚ Ã— dâ‚‚)) : MState (dâ‚‚ Ã— dâ‚) :=
  Ï.relabel (Equiv.prodComm dâ‚ dâ‚‚).symm

def spectrum_SWAP (Ï : MState (dâ‚ Ã— dâ‚‚)) : âˆƒ e, Ï.SWAP.spectrum.relabel e = Ï.spectrum := by
  sorry

@[simp]
theorem SWAP_SWAP (Ï : MState (dâ‚ Ã— dâ‚‚)) : Ï.SWAP.SWAP = Ï :=
  rfl

@[simp]
theorem traceLeft_SWAP (Ï : MState (dâ‚ Ã— dâ‚‚)) : Ï.SWAP.traceLeft = Ï.traceRight :=
  rfl

@[simp]
theorem traceRight_SWAP (Ï : MState (dâ‚ Ã— dâ‚‚)) : Ï.SWAP.traceRight = Ï.traceLeft :=
  rfl

/-- The associator that re-clusters the parts of a quantum system. -/
def assoc (Ï : MState ((dâ‚ Ã— dâ‚‚) Ã— dâ‚ƒ)) : MState (dâ‚ Ã— dâ‚‚ Ã— dâ‚ƒ) :=
  Ï.relabel (Equiv.prodAssoc dâ‚ dâ‚‚ dâ‚ƒ).symm

/-- The associator that re-clusters the parts of a quantum system. -/
def assoc' (Ï : MState (dâ‚ Ã— dâ‚‚ Ã— dâ‚ƒ)) : MState ((dâ‚ Ã— dâ‚‚) Ã— dâ‚ƒ) :=
  Ï.SWAP.assoc.SWAP.assoc.SWAP

@[simp]
theorem assoc_assoc' (Ï : MState (dâ‚ Ã— dâ‚‚ Ã— dâ‚ƒ)) : Ï.assoc'.assoc = Ï := by
  rfl

@[simp]
theorem assoc'_assoc (Ï : MState ((dâ‚ Ã— dâ‚‚) Ã— dâ‚ƒ)) : Ï.assoc.assoc' = Ï := by
  rfl

@[simp]
theorem traceLeft_right_assoc (Ï : MState ((dâ‚ Ã— dâ‚‚) Ã— dâ‚ƒ)) :
    Ï.assoc.traceLeft.traceRight = Ï.traceRight.traceLeft := by
  ext
  simpa [assoc, relabel, Matrix.traceLeft, traceLeft, Matrix.traceRight, traceRight]
    using Finset.sum_comm

@[simp]
theorem traceRight_left_assoc' (Ï : MState (dâ‚ Ã— dâ‚‚ Ã— dâ‚ƒ)) :
    Ï.assoc'.traceRight.traceLeft = Ï.traceLeft.traceRight := by
  rw [â† Ï.assoc'.traceLeft_right_assoc, assoc_assoc']

@[simp]
theorem traceRight_assoc (Ï : MState ((dâ‚ Ã— dâ‚‚) Ã— dâ‚ƒ)) :
    Ï.assoc.traceRight = Ï.traceRight.traceRight := by
  simp [Matrix.traceRight, traceRight, Fintype.sum_prod_type]
  rfl

@[simp]
theorem traceLeft_assoc' (Ï : MState (dâ‚ Ã— dâ‚‚ Ã— dâ‚ƒ)) :
    Ï.assoc'.traceLeft = Ï.traceLeft.traceLeft := by
  convert Ï.SWAP.assoc.SWAP.traceRight_assoc
  simp

@[simp]
theorem traceLeft_left_assoc (Ï : MState ((dâ‚ Ã— dâ‚‚) Ã— dâ‚ƒ)) :
    Ï.assoc.traceLeft.traceLeft = Ï.traceLeft := by
  ext
  simpa [assoc, relabel, traceLeft, Matrix.traceLeft, Matrix.of_apply, Fintype.sum_prod_type]
    using Finset.sum_comm

@[simp]
theorem traceRight_right_assoc' (Ï : MState (dâ‚ Ã— dâ‚‚ Ã— dâ‚ƒ)) :
    Ï.assoc'.traceRight.traceRight = Ï.traceRight := by
  simp [assoc']

@[simp]
theorem traceNorm_eq_1 (Ï : MState d) : Ï.m.traceNorm = 1 :=
  have := calc (Ï.m.traceNorm : â„‚)
    _ = Ï.m.trace := Ï.pos.traceNorm_PSD_eq_trace
    _ = 1 := Ï.tr'
  Complex.ofReal_eq_one.mp this

--TODO: This naming is very inconsistent. Should be better about "prod" vs "kron"

theorem relabel_kron {dâ‚ dâ‚‚ dâ‚ƒ : Type*} [Fintype dâ‚] [DecidableEq dâ‚] [Fintype dâ‚‚] [DecidableEq dâ‚‚]
      [Fintype dâ‚ƒ] [DecidableEq dâ‚ƒ] (Ï : MState dâ‚) (Ïƒ : MState dâ‚‚) (e : dâ‚ƒ â‰ƒ dâ‚) :
    ((Ï.relabel e) âŠ— Ïƒ) = (Ï âŠ— Ïƒ).relabel (e.prodCongr (Equiv.refl dâ‚‚)) := by
  ext
  rfl --is this defeq abuse? I don't know

theorem kron_relabel {dâ‚ dâ‚‚ dâ‚ƒ : Type*} [Fintype dâ‚] [DecidableEq dâ‚] [Fintype dâ‚‚] [DecidableEq dâ‚‚]
      [Fintype dâ‚ƒ] [DecidableEq dâ‚ƒ] (Ï : MState dâ‚) (Ïƒ : MState dâ‚‚) (e : dâ‚ƒ â‰ƒ dâ‚‚) :
    (Ï âŠ— Ïƒ.relabel e) = (Ï âŠ— Ïƒ).relabel ((Equiv.refl dâ‚).prodCongr e) := by
  ext
  rfl

theorem prod_assoc {dâ‚ dâ‚‚ dâ‚ƒ : Type*} [Fintype dâ‚] [DecidableEq dâ‚] [Fintype dâ‚‚] [DecidableEq dâ‚‚]
      [Fintype dâ‚ƒ] [DecidableEq dâ‚ƒ] (Ï : MState dâ‚) (Ïƒ : MState dâ‚‚) (Ï„ : MState dâ‚ƒ) :
    (Ï âŠ— (Ïƒ âŠ— Ï„)) = (Ï âŠ— Ïƒ âŠ— Ï„).relabel (Equiv.prodAssoc dâ‚ dâ‚‚ dâ‚ƒ).symm := by
  ext1; ext1; symm
  simpa [MState.prod, MState.relabel, -Matrix.kronecker_assoc']
    using Matrix.kronecker_assoc' Ï.m Ïƒ.m Ï„.m

section topology

/-- Mixed states inherit the subspace topology from matrices -/
instance : TopologicalSpace (MState d) :=
  TopologicalSpace.induced MState.M inferInstance

/-- The projection from mixed states to their Hermitian matrices is an embedding -/
theorem toMat_IsEmbedding : Topology.IsEmbedding (MState.M (d := d)) where
  eq_induced := rfl
  injective := @MState.ext _ _ _

instance : T3Space (MState d) :=
  Topology.IsEmbedding.t3Space toMat_IsEmbedding

instance : CompactSpace (MState d) := by
  constructor
  rw [(Topology.IsInducing.induced MState.M).isCompact_iff]
  suffices IsCompact (Set.Icc 0 1 âˆ© { m | m.trace = 1} : Set (HermitianMat d â„‚)) by
    convert this
    ext1 m
    constructor
    Â· rintro âŸ¨Ï, _, rflâŸ©
      simp [Ï.zero_le, Ï.le_one]
    Â· simpa using fun m_pos _ m_tr â†¦ âŸ¨âŸ¨m, m_pos, m_trâŸ©, rflâŸ©
  apply isCompact_Icc.inter_right
  refine isClosed_eq ?_ continuous_const
  rw [funext trace_eq_re_trace]
  fun_prop

noncomputable instance : MetricSpace (MState d) :=
  MetricSpace.induced MState.M MState.M_Injective inferInstance

theorem dist_eq (x y : MState d) : dist x y = dist x.M y.M := by
  rfl

instance : BoundedSpace (MState d) where
  bounded_univ :=
    CompactSpace.isCompact_univ.isBounded

@[fun_prop]
theorem Continuous_HermitianMat : Continuous (MState.M (d := d)) :=
  continuous_iff_le_induced.mpr fun _ => id

@[fun_prop]
theorem Continuous_Matrix : Continuous (MState.m (d := d)) := by
  unfold MState.m
  fun_prop

theorem image_M_isBounded (S : Set (MState d)) : Bornology.IsBounded (MState.M '' S) := by
  rw [â† Bornology.isBounded_induced]
  exact Bornology.IsBounded.all S

end topology

section finprod

variable {Î¹ : Type u} [DecidableEq Î¹] [fÎ¹ : Fintype Î¹]
variable {dI : Î¹ â†’ Type v} [âˆ€(i :Î¹), Fintype (dI i)] [âˆ€(i :Î¹), DecidableEq (dI i)]

def piProd (Ïi : (i:Î¹) â†’ MState (dI i)) : MState ((i:Î¹) â†’ dI i) where
  M := {
    val j k := âˆ (i : Î¹), (Ïi i).m (j i) (k i)
    property := sorry
  }
  zero_le := by
    rw [HermitianMat.zero_le_iff]
    --Should be in Mathlib
    constructor
    Â· ext j k
      dsimp
      rw [map_prod]
      congr! with i
      exact Matrix.ext_iff.mpr ((Ïi i).pos.isHermitian) (j i) (k i)
    Â· intro v
      sorry
  tr := by
    sorry
    -- rw [HermitianMat.trace_eq_trace_rc]
    -- convert (Finset.prod_univ_sum (Îº := dI) (fun _ â†¦ Finset.univ) (fun i_1 x â†¦ (Ïi i_1).m x x)).symm
    -- symm
    -- apply Finset.prod_eq_one
    -- intro x hx
    -- exact (Ïi x).tr

/-- The n-copy "power" of a mixed state, with the standard basis indexed by pi types. -/
def npow (Ï : MState d) (n : â„•) : MState (Fin n â†’ d) :=
  piProd (fun _ â†¦ Ï)

@[inherit_doc]
infixl:110 "âŠ—^" => MState.npow

end finprod

section posdef

theorem PosDef.kron {dâ‚ dâ‚‚ : Type*} [Fintype dâ‚] [DecidableEq dâ‚] [Fintype dâ‚‚] [DecidableEq dâ‚‚]
    {Ïƒâ‚ : MState dâ‚} {Ïƒâ‚‚ : MState dâ‚‚} (hÏƒâ‚ : Ïƒâ‚.m.PosDef) (hÏƒâ‚‚ : Ïƒâ‚‚.m.PosDef) : (Ïƒâ‚ âŠ— Ïƒâ‚‚).m.PosDef :=
  hÏƒâ‚.kron hÏƒâ‚‚

theorem PosDef.relabel {dâ‚ dâ‚‚ : Type*} [Fintype dâ‚] [DecidableEq dâ‚] [Fintype dâ‚‚] [DecidableEq dâ‚‚]
    {Ï : MState dâ‚} (hÏ : Ï.m.PosDef) (e : dâ‚‚ â‰ƒ dâ‚) : (Ï.relabel e).m.PosDef :=
  Matrix.PosDef.reindex hÏ e.symm

/-- If both states positive definite, so is their mixture. -/
theorem PosDef_mix {d : Type*} [Fintype d] [DecidableEq d] {Ïƒâ‚ Ïƒâ‚‚ : MState d}
    (hÏƒâ‚ : Ïƒâ‚.m.PosDef) (hÏƒâ‚‚ : Ïƒâ‚‚.m.PosDef) (p : Prob) : (p [Ïƒâ‚ â†” Ïƒâ‚‚]).m.PosDef :=
  Matrix.PosDef.Convex hÏƒâ‚ hÏƒâ‚‚ p.zero_le (1 - p).zero_le (by simp)

/-- If one state is positive definite and the mixture is nondegenerate, their mixture is also positive definite. -/
theorem PosDef_mix_of_ne_zero {d : Type*} [Fintype d] [DecidableEq d] {Ïƒâ‚ Ïƒâ‚‚ : MState d}
    (hÏƒâ‚ : Ïƒâ‚.m.PosDef) (p : Prob) (hp : p â‰  0) : (p [Ïƒâ‚ â†” Ïƒâ‚‚]).m.PosDef := by
  rw [â† zero_lt_iff] at hp
  exact (hÏƒâ‚.smul hp).add_posSemidef (Ïƒâ‚‚.pos.rsmul (1 - p).zero_le)

/-- If the second state is positive definite and the mixture is nondegenerate, their mixture is also positive definite. -/
theorem PosDef_mix_of_ne_one {d : Type*} [Fintype d] [DecidableEq d] {Ïƒâ‚ Ïƒâ‚‚ : MState d}
    (hÏƒâ‚‚ : Ïƒâ‚‚.m.PosDef) (p : Prob) (hp : p â‰  1) : (p [Ïƒâ‚ â†” Ïƒâ‚‚]).m.PosDef := by
  have : 0 < 1 - p := by
    --TODO this is ridiculous, move to Prob
    contrapose! hp
    have : (1 : â„) - (p : â„) = (0 : â„) := by
      have := le_antisymm hp (1 - p).zero_le
      rw [Subtype.ext_iff] at this
      simpa using this
    ext
    change (p : â„) = 1
    linarith
  exact (hÏƒâ‚‚.smul this).posSemidef_add (Ïƒâ‚.pos.rsmul p.zero_le)

theorem uniform_posDef {d : Type*} [Nonempty d] [Fintype d] [DecidableEq d] :
    (uniform (d := d)).m.PosDef := by
  simp [uniform, ofClassical, m, HermitianMat.diagonal]
  exact Fintype.card_pos

theorem posDef_of_unique {d : Type*} [Fintype d] [DecidableEq d] (Ï : MState d) [Unique d] : Ï.m.PosDef := by
  rw [Subsingleton.allEq Ï uniform]
  exact uniform_posDef

end posdef

end MState


================================================================================
FILE: QuantumInfo/Finite/POVM.lean
TYPE: Lean 4
SIZE: 6758 characters


[Repository content continues in next chunk]