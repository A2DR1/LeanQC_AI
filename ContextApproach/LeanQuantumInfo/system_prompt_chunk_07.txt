# Lean 4 Code Generation System Prompt (Chunked Version)

You are an expert Lean 4 theorem prover specializing in quantum information theory. Convert natural language prompts into precise Lean 4 code using the Lean-QuantumInfo repository as reference.

## Your Role
Convert natural language descriptions of mathematical concepts, theorems, and proofs into formal Lean 4 code following the exact patterns, definitions, and conventions from the Lean-QuantumInfo repository.

## Key Repository Patterns

### Probability & Distributions
```lean
def Prob := { p : ‚Ñù // 0 ‚â§ p ‚àß p ‚â§ 1 }
def Distribution (Œ± : Type u) [Fintype Œ±] : Type u :=
  { f : Œ± ‚Üí Prob // Finset.sum Finset.univ (fun i ‚Ü¶ (f i : ‚Ñù)) = 1 }
```

### Quantum States
```lean
structure MState (d : Type*) [Fintype d] :=
  m : Matrix d d ‚ÑÇ
  pos : m.PosSemidef
  tr : m.trace = 1

structure Bra (d : ‚Ñï) :=
  vec : Fin d ‚Üí ‚ÑÇ
  normalized' : ‚àë i, ‚Äñvec i‚Äñ^2 = 1
```

### Entropy Functions
```lean
def shannon_entropy (p : Distribution Œ±) : ‚Ñù :=
  -‚àë x, (p.val x).toReal * Real.log (p.val x).toReal

def von_neumann_entropy (œÅ : MState d) : ‚Ñù :=
  -‚àë i, (eigenvalues œÅ.m i).toReal * Real.log (eigenvalues œÅ.m i).toReal
```

## Response Format
1. **Analysis**: Explain the mathematical concept
2. **Lean Code**: Complete implementation with imports
3. **Explanation**: Key components and mathematical meaning
4. **Dependencies**: Required imports and related definitions

## Guidelines
- Use Unicode: `‚Ñù`, `‚Ñï`, `‚ÑÇ`, `‚Üí`, `‚Üî`, `‚àß`, `‚à®`, `‚àÄ`, `‚àÉ`
- Include docstrings: `/-- ... -/`
- Type annotations: `[Fintype Œ±]`, `[DecidableEq Œ±]`
- Use `sorry` for incomplete proofs
- Follow repository naming conventions
- Reference existing definitions when possible

## Repository Content Reference

The following is a portion of the Lean-QuantumInfo repository content. Use this as reference for code generation:

---

‚àß q2 = Œ¶ œÉ := by
      --The relevant map here is to take the T that optimizes inside Œ≤_ Œµ (œÅ‚Äñ{œÉ}),
      --and use the projective measurement onto {T, 1 - T}. This achieves the optimum
      --discrimination rate on œÉ, and so gives the outcome distribution q2. And it
      --is tight on the bound that Tr[œÅ T] = Œµ.

      --Get the measurement operator T.
      obtain ‚ü®T, hT‚ÇÅ, hT‚ÇÇ‚ü© := exists_min œÅ Œµ {œÉ}
      simp only [Set.mem_singleton_iff, iSup_iSup_eq_left] at hT‚ÇÅ
      --Turn it into a POVM (probably want to have lemmas around this ideally)
      let Œõ : POVM (Fin 2) d := {
        mats i := if i = 0 then T else 1 - T
        zero_le i := by
          split
          ¬∑ exact T.prop.2.1
          ¬∑ exact HermitianMat.zero_le_iff.mpr T.prop.2.2
        normalized := by simp
      }
      use Œõ.MeasureDiscard
      simp only [POVM.measureDiscard_apply, p2, q2]
      constructor
      ¬∑ congr
        rw [Distribution.coin_eq_iff]
        ext
        dsimp [MState.exp_val] at hT‚ÇÇ
        simp [POVM.Measure, Œõ, p, Distribution.mk', coe_one_minus, ‚Üê hT‚ÇÇ, HermitianMat.inner_comm]
      ¬∑ congr
        rw [Distribution.coin_eq_iff]
        ext
        dsimp [POVM.Measure, Œõ, q]
        rw [‚Üê hT‚ÇÅ]
        exact HermitianMat.inner_comm _ _
    rw [hŒ¶‚ÇÅ, hŒ¶‚ÇÇ]
    exact sandwichedRenyiEntropy_DPI hŒ±.le œÅ œÉ Œ¶

  --If q = 1, this inequality is trivial
  by_cases hq‚ÇÇ : q = 1
  ¬∑ rw [hq‚ÇÇ]
    simp

  replace hq‚ÇÇ : q < 1 := show q.val < 1 by
    linarith +splitNe [q.coe_le_one, unitInterval.coe_ne_one.mpr hq‚ÇÇ]


  --The Renyi entropy is finite
  rw [SandwichedRelRentropy, if_pos ?_]; swap
  ¬∑ suffices q2.M.ker = ‚ä• by
      simp only [this, bot_le]
    --q2 has eigenvalues Œ≤_ Œµ(œÅ‚Äñ{œÉ}) and 1-Œ≤_ Œµ(œÅ‚Äñ{œÉ}), so as long as Œ≤_ Œµ(œÅ‚Äñ{œÉ}) isn't 0 or 1,
    --this is true.
    exact ker_diagonal_prob_eq_bot hq hq‚ÇÇ

  conv => enter [2, 1, 1, 1]; rw [if_neg hŒ±.ne']

  --The logs are finite
  rw [Prob.negLog, Prob.negLog, if_neg hq.ne']
  rw [if_neg (show 1 - Œµ ‚â† 0 by simpa [Subtype.eq_iff, Prob.coe_sub] using h‚ÇÇ.ne')]

  --Turn the ENNReal problem into a Real problem
  have hŒ±‚ÇÇ : Subtype.mk _ pf2 ‚â† 0 := by
    change ¬¨(_ = Subtype.mk 0 _)
    simp only [mk_zero, Nonneg.mk_eq_zero]
    linarith
  rw [‚Üê ENNReal.coe_mul, ‚Üê ENNReal.coe_div hŒ±‚ÇÇ, ‚Üê ENNReal.coe_add, ENNReal.coe_le_coe]
  clear hŒ±‚ÇÇ
  simp only [‚Üê coe_le_coe, coe_mk, NNReal.coe_add, NNReal.coe_div, NNReal.coe_mul, neg_mul]
  clear pf1 pf2

  rw [‚Üê add_div, ‚Üê sub_eq_add_neg]
  conv =>
    enter [2,1,1,1]
    equals (p^Œ± * q^(1-Œ±) + (1-p)^Œ± * (1-q)^(1-Œ±) : ‚Ñù) =>
      unfold q2
      rw [MState.ofClassical_pow]
      unfold p2
      rw [MState.coe_ofClassical]
      rw [HermitianMat.diagonal_conj_diagonal, HermitianMat.diagonal_pow]
      rw [HermitianMat.trace_diagonal]
      simp only [Fin.sum_univ_two, Fin.isValue, Distribution.coin_val_zero,
        Distribution.coin_val_one, Prob.coe_one_minus]
      rw [Real.mul_rpow p.zero_le (by positivity)]
      rw [‚Üê Real.rpow_natCast_mul (by bound)]
      rw [‚Üê Real.rpow_mul q.zero_le]
      rw [Real.mul_rpow (by bound) (by positivity)]
      rw [‚Üê Real.rpow_natCast_mul (by bound)]
      rw [‚Üê Real.rpow_mul (by bound)]
      congr <;> simp [field]

  by_cases h : Œµ = 0
  ¬∑ simp [h, p, @Real.zero_rpow Œ± (by positivity)]
    apply Eq.le
    rw [Real.log_rpow hq]
    have : Œ± - 1 ‚â† 0 := by linarith
    field_simp
    ring_nf

  have hp : 0 < p := show (0 : ‚Ñù) < p by simp [p, hŒµ]

  replace h : 0 < Œµ := zero_lt_iff.mpr h
  trans (Real.log (p ^ Œ± * q ^ (1 - Œ±)) - Real.log (1 - Œµ.val) * Œ±) / (Œ± - 1)
  ¬∑ rw [Real.log_mul]
    rotate_left
    ¬∑ exact (Real.rpow_pos_of_pos hp _).ne'
    ¬∑ exact (Real.rpow_pos_of_pos hq _).ne'
    simp only [p, Prob.coe_one_minus]
    rw [Real.log_rpow (by linarith), mul_comm Œ±, add_sub_cancel_left]
    rw [Real.log_rpow (x := q.val) hq]
    rw [mul_comm, ‚Üê mul_div, mul_comm, show (1 - Œ±) = -(Œ± - 1) by abel]
    simp [-neg_sub, neg_div, div_self (a := Œ± - 1) (by linarith)]
  ¬∑ rw [div_le_div_iff_of_pos_right (by linarith), tsub_le_iff_right]
    nth_rewrite 4 [Prob.coe_sub]
    simp only [Set.Icc.coe_one, sub_nonneg, Prob.coe_le_one, sup_of_le_left, sub_add_cancel]
    apply Real.log_le_log
    ¬∑ refine mul_pos (Real.rpow_pos_of_pos hp _) (Real.rpow_pos_of_pos hq _)
    rw [le_add_iff_nonneg_right]
    refine mul_nonneg (Real.rpow_nonneg ?_ _) (Real.rpow_nonneg ?_ _)
    ¬∑ exact sub_nonneg_of_le p.2.2
    ¬∑ exact sub_nonneg_of_le q.2.2

theorem rate_pos_of_smul_pos {Œµ : Prob} {d : Type*} [Fintype d] [DecidableEq d] {œÅ œÉ‚ÇÅ œÉ‚ÇÇ : MState d}
    (hœÉ‚ÇÇ : 0 < Œ≤_ Œµ(œÅ‚Äñ{œÉ‚ÇÇ})) {c : ‚Ñù} (hc : 0 < c) (hœÉ : c ‚Ä¢ œÉ‚ÇÇ ‚â§ œÉ‚ÇÅ.M) : 0 < Œ≤_ Œµ(œÅ‚Äñ{œÉ‚ÇÅ}) := by
  simp only [of_singleton, lt_iInf_iff] at hœÉ‚ÇÇ ‚ä¢
  rcases hœÉ‚ÇÇ with ‚ü®‚ü®b, _, hb_le‚ü©, hb_pos, hb‚ü©
  change 0 < b at hb_pos --TODO simp thm / lemma
  use ‚ü®(min c 1) * b, by positivity, by bound‚ü©
  constructor
  ¬∑ change 0 < (min c 1) * b --TODO simp thm / lemma
    positivity
  intro i
  specialize hb i
  rw [Subtype.mk_le_mk, MState.exp_val] at hb ‚ä¢
  replace hb : c * b ‚â§ (c ‚Ä¢ œÉ‚ÇÇ.M).inner i := by
    rwa [‚Üê mul_le_mul_iff_of_pos_left hc, ‚Üê HermitianMat.smul_inner] at hb
  grw [min_le_left]
  refine hb.trans (HermitianMat.inner_mono' i.2.2.1 hœÉ)

@[fun_prop]
theorem rate_Continuous_singleton {Œµ : Prob} {d : Type*} [Fintype d] [DecidableEq d] (œÅ : MState d) :
    Continuous fun œÉ ‚Ü¶ Œ≤_ Œµ(œÅ‚Äñ{œÉ}) := by
  have h := LinearMap.BilinForm.continuous_iInf_fst
    HermitianMat.inner_BilinForm.flip (S := { m | œÅ.exp_val (1 - m) ‚â§ ‚ÜëŒµ ‚àß 0 ‚â§ m ‚àß m ‚â§ 1 })
    ((Metric.isBounded_Icc 0 1).subset (Set.setOf_subset_setOf_of_imp fun _ ‚Ü¶ And.right))
  simp only [of_singleton]
  conv => enter [1, œÉ]; rw [subtype_val_iInf']
  exact Continuous.subtype_mk (h.comp MState.Continuous_HermitianMat) _


================================================================================
FILE: QuantumInfo/Finite/ResourceTheory/ResourceTheory.lean
TYPE: Lean 4
SIZE: 8075 characters
================================================================================

import QuantumInfo.Finite.ResourceTheory.FreeState

/-- A quantum resource theory extends a `FreeStateTheory` with a collection of free operations. It is
required that any state we can always prepare for free must be free, and this is all then the resource
theory is "minimal", but we can have a more restricted set of operations. -/
class ResourceTheory (Œπ : Type*) extends FreeStateTheory Œπ where
  freeOps i j : Set (CPTPMap (H i) (H j))
  /-- Free operations in a ResourceTheory are nongenerating: they only create a free states from a free state. -/
  nongenerating {i j : Œπ} {f} (h : f ‚àà freeOps i j) : ‚àÄ œÅ, IsFree œÅ ‚Üí IsFree (f œÅ)
  --We might need to require some more closure properties on `freeOps`, like closure under tensor product...?
  --For now we just require that they include the identity and composition, so that we have at least a category.
  /-- The identity operation is free -/
  free_id i : CPTPMap.id ‚àà freeOps i i
  /-- Free operations are closed under composition -/
  free_comp {i j k} (Y : freeOps j k) (X : freeOps i j) : Y.1.compose X.1 ‚àà freeOps i k

namespace ResourceTheory
open ResourcePretheory
open FreeStateTheory

variable {Œπ : Type*}

/-- Given a `FreeStateTheory`, there is a maximal set of free operations compatible with the free states.
That is the set of all operations that don't generate non-free states from free states. We
call this the maximal resource theory. -/
def maximal [FreeStateTheory Œπ] : ResourceTheory Œπ where
  freeOps i j := { f | ‚àÄ œÅ, IsFree œÅ ‚Üí IsFree (f œÅ)}
  nongenerating := id
  free_id _ _ _ := by rwa [CPTPMap.id_MState]
  free_comp f g œÅ h := f.prop _ (g.prop œÅ h)

/-- A resource theory `IsMaximal` if it includes all non-generating operations. -/
def IsMaximal (r : ResourceTheory Œπ) : Prop :=
  ‚àÄ (i j), r.freeOps i j = { f | ‚àÄ œÅ, IsFree œÅ ‚Üí IsFree (f œÅ)}

/-- A resource theory `IsTensorial` if it includes tensor products of operations, creating
free states, and discarding. This implies that includes a unit object. -/
structure IsTensorial [UnitalPretheory Œπ] : Prop where
  prod :  ‚àÄ {i j k l : Œπ} {f g}, f ‚àà freeOps i k ‚Üí g ‚àà freeOps j l ‚Üí (f ‚äó‚Çñ·µ£ g) ‚àà freeOps (prod i j) (prod k l)
  create : ‚àÄ {i : Œπ} (œÅ), IsFree œÅ ‚Üí CPTPMap.const_state œÅ ‚àà freeOps Unital.unit i
  destroy : ‚àÄ (i : Œπ), CPTPMap.destroy ‚àà freeOps i Unital.unit

/-- The theory `ResourceTheory.maximal` always `IsMaximal`. -/
theorem maximal_IsMaximal [FreeStateTheory Œπ] : IsMaximal (maximal (Œπ := Œπ)) :=
  fun _ _ ‚Ü¶ rfl

-- --Helper theorem for ResourceTheory.mk_of_ops
-- private lemma convex_states_of_convex_ops [ResourcePretheory Œπ] (O : ‚àÄ (i j : Œπ), Set (CPTPMap (H i) (H j)))
--   (h_convex : ‚àÄ {i j}, Convex ‚Ñù (CPTPMap.choi '' O i j)) (i : Œπ) :
--     Convex ‚Ñù (MState.M '' fun œÅ ‚Ü¶ ‚àÄ {j} œÉ, ‚àÉ f, O j i f ‚àß f œÉ = œÅ) := by
--   intro _ hx _ hy a b ha hb hab
--   rw [Set.mem_image] at hx hy ‚ä¢
--   obtain ‚ü®x,hx1,hx2‚ü© := hx
--   obtain ‚ü®y,hy1,hy2‚ü© := hy
--   use Mixable.mix_ab ha hb hab x y
--   constructor
--   ¬∑ change forall _, _
--     intro j œÉ
--     obtain ‚ü®fx,‚ü®hfx1,hfx2‚ü©‚ü© := hx1 œÉ
--     obtain ‚ü®fy,‚ü®hfy1,hfy2‚ü©‚ü© := hy1 œÉ
--     use Mixable.mix_ab ha hb hab fx fy
--     constructor
--     ¬∑ specialize h_convex ‚ü®fx, hfx1, rfl‚ü© ‚ü®fy, hfy1, rfl‚ü© ha hb hab
--       rw [Set.mem_image] at h_convex
--       obtain ‚ü®w,hw1,hw2‚ü© := h_convex
--       have : w = Mixable.mix_ab ha hb hab fx fy := by
--         apply CPTPMap.choi_ext
--         convert hw2
--         --Should be a theorem
--         simp only [Mixable.mix_ab, Mixable.mkT]
--         exact CPTPMap.choi_of_CPTP_of_choi (a ‚Ä¢ fx.choi + b ‚Ä¢ fy.choi)
--       exact this ‚ñ∏ hw1
--     ¬∑ --Should be a theorem about CPTPMap.instMixable, really. Also, this proof is terrible.
--       subst x y
--       simp only [Mixable.mix_ab, Mixable.mkT, MState.instMixable, CPTPMap.instMFunLike,
--         CPTPMap.CPTP_of_choi_PSD_Tr, CPTPMap.mk, MatrixMap.of_choi_matrix, Mixable.to_U]
--       ext
--       change (Finset.sum _ _) = ((_ : ‚ÑÇ) + _)
--       simp only [Matrix.add_apply, Matrix.smul_apply, Complex.real_smul]
--       simp_rw [mul_add, Finset.sum_add_distrib]
--       congr
--       ¬∑ sorry
--       ¬∑ sorry
--   ¬∑ rw [Mixable.mix_ab, Mixable.mkT, MState.instMixable, ‚Üê hx2, ‚Üê hy2]
--     rfl

-- /-- A `ResourceTheory` can be constructed from a set of operations (satisfying appropriate axioms of closure),
-- and then the free states are taken to be the set of states that can be prepared from any initial state.
-- -/
-- def mk_of_ops [ResourcePretheory Œπ] (O : ‚àÄ (i j : Œπ), Set (CPTPMap (H i) (H j)))
--     (h_id : ‚àÄ i, CPTPMap.id ‚àà O i i) --Operations include identity
--     (h_comp : ‚àÄ {i j k} (Y : O j k) (X : O i j), Y.1.compose X.1 ‚àà O i k) --Operations include compositions
--     (h_closed : ‚àÄ {i j}, IsClosed (O i j)) -- Operations are topologically closed
--     (h_convex : ‚àÄ {i j}, Convex ‚Ñù (CPTPMap.choi '' O i j)) -- (The choi matrices of) operations are convex
--     (h_prod : ‚àÄ {i j k l f g} (hf : f ‚àà O i k) (hg : g ‚àà O j l), (f ‚äó‚Çñ·µ£ g) ‚àà O (prod i j) (prod k l)) --Closed under products
--     (h_fullRank : ‚àÄ {i : Œπ}, sorry) --Some statement about having full rank states as output
--     (h_appendFree : ‚àÄ {i j k : Œπ}, sorry) --Some statement that appending free states is free
--     : ResourceTheory Œπ where
--   freeOps := O
--   free_id := h_id
--   free_comp := h_comp

--   IsFree {i} œÅ := ‚àÄ {j} œÉ, ‚àÉ f, O j i f ‚àß f œÉ = œÅ
--   free_closed := sorry
--   free_convex {i} := convex_states_of_convex_ops O @h_convex i
--   free_prod {i j œÅ œÉ} hœÅ hœÉ k œÅ‚ÇÄ := by
--     obtain ‚ü®f,hf1‚ü© := hœÅ œÅ
--     obtain ‚ü®g,hg‚ü© := hœÉ œÉ
--     sorry
--   free_fullRank := sorry
--   nongenerating := by
--     intro i j f hf œÅ hFree k œÉ
--     obtain ‚ü®g,hg1,hg2‚ü© := hFree œÉ
--     use f.compose g
--     constructor
--     ¬∑ exact h_comp ‚ü®f,hf‚ü© ‚ü®g,hg1‚ü©
--     ¬∑ simp only [CPTPMap.compose_eq, hg2]


-- /-- A `ResourceTheory` provides a category structure -/
-- instance instQRTCategory (Œπ : Type*) [ResourceTheory Œπ] : CategoryTheory.Category Œπ where
--   Hom x y := freeOps x y
--   id := fun _ ‚Ü¶ ‚ü®CPTPMap.id, free_id _‚ü©
--   comp f g := ‚ü®CPTPMap.compose g.1 f.1, free_comp g f‚ü©
--   id_comp X := by simp
--   comp_id := by simp
--   assoc := fun f g h ‚Ü¶ by simpa using CPTPMap.compose_assoc h.1 g.1 f.1

-- open ComplexOrder in
-- /-- The 'fully free' quantum resource theory: the category is all finite Hilbert spaces, all maps are
-- free and all states are free. Marked noncomputable because we use `Fintype.ofFinite`. -/
-- noncomputable def fullyFreeQRT : ResourceTheory { Œπ : Type // Finite Œπ ‚àß Nonempty Œπ} where
--     H := Subtype.val
--     FinH := fun i ‚Ü¶ have := i.prop.left; Fintype.ofFinite i
--     DecEqH := fun i a b ‚Ü¶ Classical.propDecidable (a = b)
--     NonemptyH := fun i ‚Ü¶ i.prop.right

--     prod := fun ‚ü®i,‚ü®hi,hi2‚ü©‚ü© ‚ü®j,‚ü®hj,hj2‚ü©‚ü© ‚Ü¶ ‚ü®i √ó j, ‚ü®Finite.instProd, instNonemptyProd‚ü©‚ü©
--     prodEquiv := fun ‚ü®_,‚ü®_,_‚ü©‚ü© ‚ü®_,‚ü®_,_‚ü©‚ü© ‚Ü¶ Equiv.refl _

--     IsFree := Set.univ
--     free_closed := isClosed_univ
--     free_convex {i} := by
--       -- convert MState.convex (H i) --For MState.m, not MState.M
--       sorry
--     free_prod _ _ := trivial
--     free_fullRank := by
--       intro i
--       have := i.prop.left
--       have := i.prop.right
--       let _ := Fintype.ofFinite i
--       let _ : DecidableEq i := fun _ _ ‚Ü¶ Classical.propDecidable _
--       use MState.uniform --use the fully mixed state
--       --The fact that the fully mixed state is PosDef should be stated somewhere else... TODO
--       suffices Matrix.PosDef (@MState.uniform (d := i.val) _ _ this).M.toMat by
--         change _ ‚àß True
--         rw [and_true]
--         exact this
--       simp only [MState.uniform, MState.ofClassical, Distribution.uniform_def, Set.univ]
--       classical apply Matrix.PosDef.diagonal
--       intro
--       rw [Finset.card_univ, one_div, Complex.ofReal_inv]
--       exact RCLike.inv_pos_of_pos (Nat.cast_pos'.mpr Fintype.card_pos)

--     freeOps _ _ := Set.univ
--     nongenerating _ _ _ := trivial
--     free_id := Set.mem_univ
--     free_comp _ _ := Set.mem_univ _

-- end ResourceTheory


================================================================================
FILE: QuantumInfo/Finite/ResourceTheory/SteinsLemma.lean
TYPE: Lean 4
SIZE: 41394 characters
================================================================================

import QuantumInfo.Finite.ResourceTheory.FreeState
import QuantumInfo.Finite.ResourceTheory.HypothesisTesting
import QuantumInfo.Finite.Pinching

import Mathlib.Tactic.Bound

open NNReal
open scoped ENNReal
open ComplexOrder
open Topology
open scoped Prob
open scoped OptimalHypothesisRate
open ResourcePretheory
open FreeStateTheory
open UnitalPretheory
open UnitalFreeStateTheory

namespace SteinsLemma

variable {Œπ : Type*} [UnitalFreeStateTheory Œπ]
variable {i : Œπ}

/-- The \tilde{œÉ}_n defined in Lemma 6, also in equation (S40) in Lemma 7. -/
noncomputable def Lemma6_œÉn (m : ‚Ñï) (œÉf : MState (H i)) (œÉ‚Çò : MState (H (i ^ m))) : (n : ‚Ñï) ‚Üí MState (H (i ^ n)) :=
  fun n ‚Ü¶ (œÉ‚Çò‚äó^S[n / m] ‚äó·µ£ œÉf‚äó^S[n % m]).relabel <| .cast <| congrArg H (by
    rw [‚Üê pow_mul, ‚Üê spacePow_add, Nat.div_add_mod n m]
  )

theorem Lemma6_œÉn_IsFree {œÉ‚ÇÅ : MState (H i)} {œÉ‚Çò : (m : ‚Ñï) ‚Üí MState (H (i ^ m))} (hœÉ‚ÇÅ_free : IsFree œÉ‚ÇÅ)
    (hœÉ‚Çò : ‚àÄ (m : ‚Ñï), œÉ‚Çò m ‚àà IsFree) (m n : ‚Ñï) : Lemma6_œÉn m œÉ‚ÇÅ (œÉ‚Çò m) n ‚àà IsFree := by
  rw [Lemma6_œÉn, relabel_cast_isFree]
  ¬∑ apply free_prod --pick a better name / alias for this
    ¬∑ exact (hœÉ‚Çò m).npow (n / m)
    ¬∑ exact hœÉ‚ÇÅ_free.npow (n % m)
  ¬∑ rw [‚Üê pow_mul, ‚Üê spacePow_add, Nat.div_add_mod n m]

--PULLOUT.
--PR? This is "not specific to our repo", but might be a bit too specialized to be in Mathlib. Not sure.
--Definitely would need to clean up the proof first
theorem extracted_limsup_inequality (z : ‚Ñù‚â•0‚àû) (hz : z ‚â† ‚ä§) (y x : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû) (h_lem5 : ‚àÄ (n : ‚Ñï), x n ‚â§ y n + z)
    : Filter.atTop.limsup (fun n ‚Ü¶ x n / n) ‚â§ Filter.atTop.limsup (fun n ‚Ü¶ y n / n) := by
  --Thanks Aristotle!
  simp? [Filter.limsup_eq] says simp only [Filter.limsup_eq, Filter.eventually_atTop,
    ge_iff_le, le_sInf_iff, Set.mem_setOf_eq, forall_exists_index]
  -- Taking the limit superior of both sides of the inequality x n / n ‚â§ y_n / n + z / n, we
  -- get limsup x n / n ‚â§ limsup (y n / n + z / n).
  intro b n h_bn
  have h_le : ‚àÄ m ‚â• n, x m / (m : ‚Ñù‚â•0‚àû) ‚â§ b + z / (m : ‚Ñù‚â•0‚àû) := by
    intro m hm
    grw [‚Üê h_bn m hm, ‚Üê ENNReal.add_div, h_lem5 m]
  -- Since z is finite, we have lim z / n = 0.
  have h_z_div_n_zero : Filter.atTop.Tendsto (fun n : ‚Ñï ‚Ü¶ z / (n : ‚Ñù‚â•0‚àû)) (ùìù 0) := by
    rw [ENNReal.tendsto_nhds_zero]
    intro Œµ hŒµ
    rw [gt_iff_lt, ENNReal.lt_iff_exists_real_btwn] at hŒµ
    rcases hŒµ with ‚ü®Œµ', hŒµ‚ÇÅ, hŒµ‚ÇÇ‚ü©
    rw [ENNReal.ofReal_pos] at hŒµ‚ÇÇ
    -- Since z is finite, we can choose k such that for all b ‚â• k, z ‚â§ b * Œµ'.
    obtain ‚ü®k, hk‚ü© : ‚àÉ k : ‚Ñï, ‚àÄ b ‚â• k, z ‚â§ b * ENNReal.ofReal Œµ' := by
      rcases ENNReal.lt_iff_exists_real_btwn.mp (show z < ‚ä§ by finiteness) with ‚ü®a, _, ha, _‚ü©
      use ‚åàa / Œµ'‚åâ‚Çä
      intro n hn
      grw [ha.le, ‚Üê ENNReal.ofReal_natCast, ‚Üê ENNReal.ofReal_mul (by positivity)]
      gcongr
      nlinarith [Nat.ceil_le.mp hn, mul_div_cancel‚ÇÄ a hŒµ‚ÇÇ.1.ne']
    -- Since z ‚â§ b * Œµ' for all b ‚â• k, dividing both sides by b (which is positive) gives z / b ‚â§ Œµ'.
    rw [Filter.eventually_atTop]
    use k + 1
    intros b _
    grw [ENNReal.div_le_iff_le_mul (by aesop) (by simp), hk b (by omega), mul_comm, hŒµ‚ÇÇ.right.le]
  refine le_of_forall_pos_le_add fun Œµ hŒµ ‚Ü¶ ?_
  rcases Filter.eventually_atTop.mp (h_z_div_n_zero.eventually <| gt_mem_nhds hŒµ) with ‚ü®m, hm‚ü©
  apply sInf_le
  use n + m
  intro n hn
  grw [h_le n (by omega), (hm n (by omega)).le]


--PULLOUT and PR
open Filter in
/-- Like `Filter.tendsto_add_atTop_iff_nat`, but with nat subtraction. -/
theorem _root_.Filter.tendsto_sub_atTop_iff_nat {Œ± : Type*} {f : ‚Ñï ‚Üí Œ±} {l : Filter Œ±} (k : ‚Ñï) :
    Tendsto (fun (n : ‚Ñï) ‚Ü¶ f (n - k)) atTop l ‚Üî Tendsto f atTop l :=
  show Tendsto (f ‚àò fun n ‚Ü¶ n - k) atTop l ‚Üî Tendsto f atTop l by
    rw [‚Üê tendsto_map'_iff, map_sub_atTop_eq_nat]

--PULLOUT and PR
open ENNReal Filter in
/-- Sort of dual to `ENNReal.tendsto_const_sub_nhds_zero_iff`. Takes a substantially different form though, since
we don't actually have equality of the limits, or even the fact that the other one converges, which is why we
need to use `limsup`. -/
theorem _root_.ENNReal.tendsto_sub_const_nhds_zero_iff {Œ± : Type*} {l : Filter Œ±} {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû}
    : Tendsto (f ¬∑ - a) l (ùìù 0) ‚Üî limsup f l ‚â§ a := by
  rcases eq_or_ne a ‚ä§ with rfl | ha
  ¬∑ simp [tendsto_const_nhds]
  rw [ENNReal.tendsto_nhds_zero, limsup_le_iff']
  simp only [tsub_le_iff_left]
  constructor
  ¬∑ intro h y hy
    specialize h (y - a) (tsub_pos_of_lt hy)
    rwa [add_comm, tsub_add_cancel_of_le hy.le] at h
  ¬∑ intro h Œµ hŒµ
    exact h (a + Œµ) (lt_add_right ha hŒµ.ne')

/-- Lemma 6 from the paper.
We _did_ end up doing the version that "works also in the case of Œµ = 0", which is nice.
-/
private theorem Lemma6 {m : ‚Ñï} (hm : 0 < m) (œÅ œÉf : MState (H i)) (œÉ‚Çò : MState (H (i ^ m)))
    (hœÉf : œÉf.m.PosDef) {Œµ : Prob} (hŒµ : Œµ < 1) :
  Filter.atTop.limsup (fun n ‚Ü¶ ‚Äîlog Œ≤_ Œµ(œÅ‚äó^S[n]‚Äñ{Lemma6_œÉn m œÉf œÉ‚Çò n}) / n) ‚â§ ùêÉ(œÅ‚äó^S[m]‚ÄñœÉ‚Çò) / m
  := by

  set œÉn := Lemma6_œÉn m œÉf œÉ‚Çò with hœÉn

  have h_add : ‚àÄ Œ± n, DÃÉ_ Œ±(œÅ‚äó^S[n]‚ÄñœÉn n) = (n/m : ‚Ñï) * DÃÉ_ Œ±(œÅ‚äó^S[m]‚ÄñœÉ‚Çò) + (n%m : ‚Ñï) * DÃÉ_ Œ±(œÅ‚ÄñœÉf):= by
    --"Break apart" œÉn, and apply additivity of `SandwichedRelRentropy`.
    intro Œ± n
    rw [hœÉn, Lemma6_œÉn]
    have hnm_add := Nat.div_add_mod n m
    rw [statePow_rw hnm_add.symm, statePow_add_relabel]
    have hnm_eq : (i ^ (m * (n / m)) * i ^ (n % m)) = (i ^ m) ^ (n / m) * i ^ (n % m) := by
      rw [pow_mul]
    have h_Hn_eq : H (i ^ n) = H ((i ^ m) ^ (n / m) * i ^ (n % m)) := by
      rw [‚Üê pow_mul, ‚Üê pow_add, hnm_add]
    simp only [MState.relabel_relabel, Equiv.cast_trans]
    rw [‚Üê sandwichedRelRentropy_statePow]
    rw [‚Üê sandwichedRelRentropy_statePow]
    rw [‚Üê sandwichedRelRentropy_prodRelabel]

    gcongr
    ¬∑ rw [MState.eq_relabel_iff]
      simp only [MState.relabel_relabel, Equiv.cast_symm, Equiv.cast_trans]
      rw [prodRelabel_relabel_cast_prod _ _ _ ((pow_mul ..).symm) rfl]
      congr
      rw [statePow_mul_relabel]
      simp
    ¬∑ simp

  --This will probably need 1 < Œ± actually
  have h_Œ± : ‚àÄ Œ±, (1 < Œ±) ‚Üí Filter.atTop.limsup (fun n ‚Ü¶ ‚Äîlog Œ≤_ Œµ(œÅ‚äó^S[n]‚Äñ{œÉn n}) / n) ‚â§
      DÃÉ_ Œ±(œÅ‚äó^S[m]‚ÄñœÉ‚Çò) / m := by
    intro Œ± hŒ±
    apply le_of_le_of_eq (b := Filter.atTop.limsup (fun n ‚Ü¶ DÃÉ_ Œ±(œÅ‚äó^S[n]‚ÄñœÉn n) / n))
    ¬∑ --Apply the "[81] Lemma 5" to œÅ‚äó^n and œÉn
      have h_lem5 (n) := OptimalHypothesisRate.Ref81Lem5 (œÅ‚äó^S[n]) (œÉn n) Œµ hŒµ Œ± hŒ±

      --Upper-bound Œ≤ on the LHS with this lemma
      --Distribute the limsup over subtraction
      --The term on the right is a constant, divided by n, which converges to zero.
      --Dropping that leaves the identity
      generalize_proofs pf1 pf2 at h_lem5
      let x n :=  ‚Äîlog Œ≤_ Œµ(œÅ‚äó^S[n]‚Äñ{œÉn n})
      let y n := DÃÉ_ Œ±(œÅ‚äó^S[n]‚ÄñœÉn n)
      set z := ‚Äîlog (1 - Œµ) * (ENNReal.ofNNReal ‚ü®Œ±, pf1‚ü©) / (ENNReal.ofNNReal ‚ü®Œ± - 1, pf2‚ü©)

      have hz : z ‚â† ‚ä§ := by
        unfold z
        have hz1 : ‚Äîlog (1 - Œµ) ‚â† ‚ä§ := by
          --TODO: should be `bound`, ideally
          simp [Subtype.eq_iff]
          have : (Œµ : ‚Ñù) < 1 := hŒµ
          linarith
        have hz2 : (ENNReal.ofNNReal ‚ü®Œ± - 1, pf2‚ü©) ‚â† 0 := by
          --TODO: should be `bound`, ideally
          simp [NNReal.eq_iff]
          linarith
        finiteness

      change ‚àÄ n, x n ‚â§ y n + z at h_lem5
      change Filter.atTop.limsup (fun n ‚Ü¶ x n / n) ‚â§ Filter.atTop.limsup (fun n ‚Ü¶ y n / n)
      exact extracted_limsup_inequality z hz y x h_lem5

    ¬∑ suffices Filter.atTop.Tendsto (fun n ‚Ü¶ DÃÉ_ Œ±(œÅ‚äó^S[n]‚ÄñœÉn n) / n)  (ùìù (DÃÉ_ Œ±(œÅ‚äó^S[m]‚ÄñœÉ‚Çò) / m))by
        exact this.limsup_eq
      conv =>
        enter [1,n]
        equals ((‚Üë(n / m) * DÃÉ_ Œ±(œÅ‚äó^S[m]‚ÄñœÉ‚Çò)) / n + (‚Üë(n % m) * DÃÉ_ Œ±(œÅ‚ÄñœÉf)) / n) =>
          simp_rw [h_add, ENNReal.add_div]
      conv => enter [3,1]; apply (add_zero _).symm
      apply Filter.Tendsto.add
      ¬∑ simp_rw [div_eq_mul_inv, mul_comm, ‚Üê mul_assoc]
        conv =>
          enter [3,1]
          apply (one_mul _).symm
        rw [‚Üê mul_assoc]
        cases DÃÉ_ Œ±(œÅ‚äó^S[m]‚ÄñœÉ‚Çò)
        ¬∑ simp
          --This is true for all x past m.
          apply tendsto_nhds_of_eventually_eq
          refine Filter.eventually_atTop.mpr ?_
          use m
          intros
          rw [ENNReal.mul_top]
          apply (ENNReal.mul_pos ?_ ?_).ne'
          ¬∑ simp only [ne_eq, ENNReal.inv_eq_zero, ENNReal.natCast_ne_top, not_false_eq_true]
          ¬∑ simp
            omega
        ¬∑ rename_i v
          suffices Filter.atTop.Tendsto (fun x ‚Ü¶ (x:‚Ñù)‚Åª¬π * ‚Üë(x / m) * (v:‚Ñù) : ‚Ñï ‚Üí ‚Ñù) (ùìù ((1 / m) * (v : ‚Ñù))) by
            --Similar to the "convert ENNReal.tendsto_ofReal this" below. Just push casts through
            convert ENNReal.tendsto_ofReal this
            ¬∑ rename_i x
              cases x
              ¬∑ simp
              rw [ENNReal.ofReal_mul (by positivity), ENNReal.ofReal_mul (by positivity), ENNReal.ofReal_inv_of_pos (by positivity)]
              simp
              norm_cast
            ¬∑ rw [ENNReal.ofReal_mul (by positivity), one_div, ENNReal.ofReal_inv_of_pos (by positivity)]
              simp
          exact (Filter.Tendsto_inv_nat_mul_div_real m).mul tendsto_const_nhds
      ¬∑ suffices Filter.atTop.Tendsto (fun x ‚Ü¶ (x % m : ‚Ñï) * (DÃÉ_ Œ±(œÅ‚ÄñœÉf)).toReal / x) (ùìù 0) by
          --Convert a Tendsto over ENNReal to one over Real
          convert ENNReal.tendsto_ofReal this
          ¬∑ rename_i x
            cases x
            ¬∑ simp
            rw [ENNReal.ofReal_div_of_pos (by positivity), ENNReal.ofReal_mul (by positivity)]
            congr
            ¬∑ simp
            ¬∑ rw [ENNReal.ofReal_toReal (by finiteness)]
            ¬∑ rw [ENNReal.ofReal_natCast]
          ¬∑ simp
        apply bdd_le_mul_tendsto_zero (b := 0) (B := m * DÃÉ_ Œ±(œÅ‚ÄñœÉf).toReal)
        ¬∑ exact Filter.Eventually.of_forall (fun _ ‚Ü¶ by positivity)
        ¬∑ apply Filter.Eventually.of_forall (fun _ ‚Ü¶ ?_)
          exact mul_le_mul_of_nonneg_right (mod_cast (Nat.mod_lt _ hm).le) (by positivity)
        ¬∑ exact tendsto_inverse_atTop_nhds_zero_nat

  --Take the limit as Œ± ‚Üí 1.
  replace h_Œ± : Filter.atTop.limsup (fun n ‚Ü¶ ‚Äîlog Œ≤_ Œµ(œÅ‚äó^S[n]‚Äñ{œÉn n}) / n) ‚â§ ùêÉ(œÅ‚äó^S[m]‚ÄñœÉ‚Çò) / m := by
    refine ge_of_tendsto (x :=  (ùìù[>] 1)) ?_ (eventually_nhdsWithin_of_forall h_Œ±)
    apply tendsto_nhdsWithin_of_tendsto_nhds
    convert ContinuousAt.tendsto ?_ using 3
    have _ := ENNReal.continuous_div_const m (by positivity)
    have _ := (sandwichedRelRentropy.continuousOn (œÅ‚äó^S[m]) œÉ‚Çò).continuousAt (Ioi_mem_nhds zero_lt_one)
    fun_prop

  exact h_Œ±

section Lemma7

open MatrixMap
open Matrix

variable {dIn dOut : Type*} [Fintype dIn] [Fintype dOut] [DecidableEq dIn] [DecidableEq dOut] {R : Type*}

-- TODO: Commutation and order relations about `proj_le` specified in the text
-- between Eqs. (S77) and (S78)

open scoped HermitianMat in
theorem LemmaS2 {Œµ3 : Prob} {Œµ4 : ‚Ñù‚â•0} (hŒµ4 : 0 < Œµ4)
  {d : ‚Ñï ‚Üí Type*} [‚àÄ n, Fintype (d n)] [‚àÄ n, DecidableEq (d n)] (œÅ : (n : ‚Ñï) ‚Üí MState (d n)) (œÉ : (n : ‚Ñï) ‚Üí MState (d n))
  {Rinf : ‚Ñù‚â•0} (hRinf : Rinf ‚â• Filter.atTop.liminf (fun (n : ‚Ñï) ‚Ü¶ ‚Äîlog Œ≤_ Œµ3(œÅ n‚Äñ{œÉ n}) / n))
  {Rsup : ‚Ñù‚â•0} (hRsup : Rsup ‚â• Filter.atTop.limsup (fun (n : ‚Ñï) ‚Ü¶ ‚Äîlog Œ≤_ Œµ3(œÅ n‚Äñ{œÉ n}) / n))
  :
  (Filter.atTop.liminf (fun (n : ‚Ñï) ‚Ü¶ {(œÅ n).M ‚â•‚Çö (Real.exp (n * (Rinf + Œµ4))) ‚Ä¢ (œÉ n).M}.inner (œÅ n)) ‚â§ 1 - Œµ3) ‚àß
  (Filter.atTop.limsup (fun (n : ‚Ñï) ‚Ü¶ {(œÅ n).M ‚â•‚Çö (Real.exp (n * (Rsup + Œµ4))) ‚Ä¢ (œÉ n).M}.inner (œÅ n)) ‚â§ 1 - Œµ3)
  := by
  constructor
  ¬∑ by_contra h
    push_neg at h
    replace h := Filter.eventually_lt_of_lt_liminf h ?_
    ¬∑ replace h := Filter.eventually_atTop.mp h
      obtain ‚ü®n‚ÇÄ, h‚ü© := h
      --Can assume that n‚ÇÄ is positive. Then we don't have to worry about nonzero values down the line
      wlog hn‚ÇÄ : 0 < n‚ÇÄ
      ¬∑ exact this hŒµ4 œÅ œÉ hRinf hRsup 1 (fun b hb ‚Ü¶ h _ <| by omega) zero_lt_one
      let T (n : ‚Ñï) := {(œÅ n).M ‚â•‚Çö (Real.exp (n * (Rinf + Œµ4))) ‚Ä¢ (œÉ n).M}
      have hT : ‚àÄ n ‚â• n‚ÇÄ, (œÅ n).exp_val (1 - (T n)) ‚â§ Œµ3 := fun n hn ‚Ü¶ by -- Eq (S23)
        unfold MState.exp_val T
        rw [HermitianMat.inner_left_sub, HermitianMat.inner_one, MState.tr,
          HermitianMat.inner_comm, tsub_le_iff_right, add_comm, ‚Üê tsub_le_iff_right]
        apply le_of_lt
        exact h n hn
      have hŒ≤ : ‚àÄ n ‚â• n‚ÇÄ, Œ≤_ Œµ3(œÅ n‚Äñ{œÉ n}) ‚â§ Real.exp (-n * (Rinf + Œµ4)) := fun n hn ‚Ü¶ by -- Eq (S25)
        open HermitianMat in
        calc
          Œ≤_ Œµ3(œÅ n‚Äñ{œÉ n}) ‚â§ (œÉ n).exp_val (T n) := by
            have hŒ≤' := OptimalHypothesisRate.singleton_le_exp_val (œÉ := œÉ n) (T n) (hT n hn) ‚ü®proj_le_nonneg _ _, proj_le_le_one _ _‚ü©
            simp only [Subtype.coe_le_coe.mpr hŒ≤']
          _ <= (T n).inner (Real.exp (-n * (Rinf + Œµ4)) ‚Ä¢ (œÅ n).M) := by
            rw [‚Üê mul_le_mul_iff_right‚ÇÄ (Real.exp_pos ((n * (Rinf + Œµ4)))), HermitianMat.inner_smul, neg_mul, Real.exp_neg]
            simp only [isUnit_iff_ne_zero, ne_eq, Real.exp_ne_zero, not_false_eq_true,
              IsUnit.mul_inv_cancel_left]
            rw [MState.exp_val, HermitianMat.inner_comm, ‚Üê HermitianMat.inner_smul]
            unfold T
            exact proj_le_inner_le (Real.exp (n * (Rinf + Œµ4)) ‚Ä¢ (œÉ n).M) (œÅ n).M
          _ <= Real.exp (-n * (Rinf + Œµ4)) := by
            simp [HermitianMat.inner_smul]
            rw [mul_comm]
            apply (mul_le_iff_le_one_left (Real.exp_pos (-(n * (Rinf + Œµ4))))).mpr
            rw [HermitianMat.inner_comm, ‚Üê MState.exp_val]
            exact MState.exp_val_le_one (proj_le_le_one _ _) (œÅ n)
      have h' : ‚àÄ n ‚â• n‚ÇÄ, Rinf + Œµ4 ‚â§ ‚Äîlog Œ≤_ Œµ3(œÅ n‚Äñ{œÉ n}) / n:= fun n hn ‚Ü¶ by -- Eq (S26)
        have : 0 < n := by order
        have hn1 : (n : ‚Ñù‚â•0‚àû) ‚â† 0 := by positivity
        have hn2 : (n : ‚Ñù‚â•0‚àû) ‚â† ‚ä§ := by finiteness
        have hh : n * (Rinf + Œµ4) = ENNReal.ofReal (n * (Rinf + Œµ4)) := by
          simp only [Nat.cast_nonneg, ENNReal.ofReal_mul, ENNReal.ofReal_natCast, zero_le_coe,
            ENNReal.ofReal_add, ENNReal.ofReal_coe_nnreal]
        apply (ENNReal.mul_le_mul_left (a := n) (b := Rinf + Œµ4) (c := ‚Äîlog Œ≤_ Œµ3(œÅ n‚Äñ{œÉ n}) / n) hn1 hn2).mp
        rw [ENNReal.mul_div_cancel hn1 hn2, hh]
        apply Prob.le_negLog_of_le_exp
        rw [‚Üê neg_mul]
        exact hŒ≤ n hn
      have hf : ‚àÄ·∂† (n : ‚Ñï) in Filter.atTop, Rinf + Œµ4 ‚â§ ‚Äîlog Œ≤_ Œµ3(œÅ n‚Äñ{œÉ n}) / n := by
        rw [Filter.eventually_atTop]
        use n‚ÇÄ
      replace hf := Filter.le_liminf_of_le ?_ hf
      ¬∑ replace hf := le_trans hf hRinf
        replace hf := tsub_eq_zero_iff_le.mpr hf
        simp_all
      apply Filter.IsCobounded.of_frequently_le (u := ‚ä§)
      simp [Filter.frequently_atTop]
      intro n; use n
    apply Filter.isBoundedUnder_of
    use 0; intro n
    rw [HermitianMat.inner_comm, ‚Üê MState.exp_val]
    exact MState.exp_val_nonneg (HermitianMat.proj_le_nonneg (Real.exp (n * (Rinf + Œµ4)) ‚Ä¢ (œÉ n).M) (œÅ n).M) (œÅ n)
  ¬∑ -- Basically the same proof as the Rinf case, but with liminf ‚Üí limsup, ‚àÄ·∂† ‚Üí ‚àÉ·∂†, etc.
    by_contra h
    push_neg at h
    replace h := Filter.frequently_lt_of_lt_limsup ?_ h
    ¬∑ replace h := Filter.frequently_atTop.mp h
      let T (n : ‚Ñï) := {(œÅ n).M ‚â•‚Çö (Real.exp (n * (Rsup + Œµ4))) ‚Ä¢ (œÉ n).M}
      have hT (n‚ÇÄ) : ‚àÉ n ‚â• n‚ÇÄ, (œÅ n).exp_val (1 - (T n)) ‚â§ Œµ3 := by -- Eq (S30)
        obtain ‚ü®n, hn, h‚ü© := h n‚ÇÄ
        use n, hn
        unfold MState.exp_val T
        rw [HermitianMat.inner_left_sub, HermitianMat.inner_one, MState.tr,
          HermitianMat.inner_comm, tsub_le_iff_right, add_comm, ‚Üê tsub_le_iff_right]
        apply le_of_lt
        exact h
      have hŒ≤ (n‚ÇÄ) : ‚àÉ n ‚â• n‚ÇÄ, Œ≤_ Œµ3(œÅ n‚Äñ{œÉ n}) ‚â§ Real.exp (-n * (Rsup + Œµ4)) := by -- Eq (S32)
        obtain ‚ü®n, hn, hT‚ü© := hT n‚ÇÄ
        use n, hn
        open HermitianMat in
        calc
          Œ≤_ Œµ3(œÅ n‚Äñ{œÉ n}) ‚â§ (œÉ n).exp_val (T n) := by
            have hŒ≤' := OptimalHypothesisRate.singleton_le_exp_val (œÉ := œÉ n) (T n) hT ‚ü®proj_le_nonneg _ _, proj_le_le_one _ _‚ü©
            simp only [Subtype.coe_le_coe.mpr hŒ≤']
          _ <= (T n).inner (Real.exp (-n * (Rsup + Œµ4)) ‚Ä¢ (œÅ n).M) := by
            rw [‚Üê mul_le_mul_iff_right‚ÇÄ (Real.exp_pos ((n * (Rsup + Œµ4)))), HermitianMat.inner_smul, neg_mul, Real.exp_neg]
            simp only [isUnit_iff_ne_zero, ne_eq, Real.exp_ne_zero, not_false_eq_true,
              IsUnit.mul_inv_cancel_left]
            rw [MState.exp_val, HermitianMat.inner_comm, ‚Üê HermitianMat.inner_smul]
            unfold T
            exact proj_le_inner_le (Real.exp (n * (Rsup + Œµ4)) ‚Ä¢ (œÉ n).M) (œÅ n).M
          _ <= Real.exp (-n * (Rsup + Œµ4)) := by
            simp [HermitianMat.inner_smul]
            rw [mul_comm]
            apply (mul_le_iff_le_one_left (Real.exp_pos (-(n * (Rsup + Œµ4))))).mpr
            rw [HermitianMat.inner_comm, ‚Üê MState.exp_val]
            exact (œÅ n).exp_val_le_one (proj_le_le_one _ _)
      have h' (n‚ÇÄ) : ‚àÉ n ‚â• n‚ÇÄ, Rsup + Œµ4 ‚â§ ‚Äîlog Œ≤_ Œµ3(œÅ n‚Äñ{œÉ n}) / n := by -- Eq (S33)
        obtain ‚ü®n, hn, hŒ≤‚ü© := hŒ≤ (n‚ÇÄ + 1)
        use n, by linarith
        have hn0 : 0 < n := by omega
        have hn1 : (n : ‚Ñù‚â•0‚àû) ‚â† 0 := by positivity
        have hn2 : (n : ‚Ñù‚â•0‚àû) ‚â† ‚ä§ := by finiteness
        have hh : n * (Rsup + Œµ4) = ENNReal.ofReal (n * (Rsup + Œµ4)) := by
          simp [ENNReal.ofReal_add]
        apply (ENNReal.mul_le_mul_left (a := n) (b := Rsup + Œµ4) (c := ‚Äîlog Œ≤_ Œµ3(œÅ n‚Äñ{œÉ n}) / n) hn1 hn2).mp
        rw [ENNReal.mul_div_cancel hn1 hn2, hh]
        apply Prob.le_negLog_of_le_exp
        rwa [‚Üê neg_mul]
      have hf : ‚àÉ·∂† (n : ‚Ñï) in Filter.atTop, Rsup + Œµ4 ‚â§ ‚Äîlog Œ≤_ Œµ3(œÅ n‚Äñ{œÉ n}) / n := by
        rwa [Filter.frequently_atTop]
      replace hf := Filter.le_limsup_of_frequently_le hf (by isBoundedDefault)
      ¬∑ replace hf := le_trans hf hRsup
        replace hf := tsub_eq_zero_iff_le.mpr hf
        simp_all
    apply Filter.atTop.isCoboundedUnder_le_of_le (x := 0)
    intro n
    rw [HermitianMat.inner_comm, ‚Üê MState.exp_val]
    exact MState.exp_val_nonneg (HermitianMat.proj_le_nonneg (Real.exp (n * (Rsup + Œµ4)) ‚Ä¢ (œÉ n).M) (œÅ n).M) (œÅ n)

private theorem LemmaS3_helper {Œµ : Prob} {d : ‚Ñï ‚Üí Type*} [‚àÄ n, Fintype (d n)] [‚àÄ n, DecidableEq (d n)]
  (œÅ œÉ‚ÇÅ œÉ‚ÇÇ : (n : ‚Ñï) ‚Üí MState (d n))
  (f : ‚Ñï ‚Üí ‚Ñù‚â•0) (hœÉ : ‚àÄ (i : ‚Ñï), Real.exp (-f i) ‚Ä¢ (œÉ‚ÇÇ i).M ‚â§ (œÉ‚ÇÅ i)) (n : ‚Ñï) :
    ‚Äîlog Œ≤_ Œµ(œÅ n‚Äñ{œÉ‚ÇÅ n}) ‚â§ ‚Äîlog Œ≤_ Œµ(œÅ n‚Äñ{œÉ‚ÇÇ n}) + f n := by
  have h‚ÇÅ (T : HermitianMat (d n) ‚ÑÇ) (hT : 0 ‚â§ T) :
          Real.exp (-f n) * T.inner (œÉ‚ÇÇ n).M ‚â§ T.inner (œÉ‚ÇÅ n).M := by
    simpa using HermitianMat.inner_mono hT (hœÉ n)
  by_cases hœÉ‚ÇÇ : Œ≤_ Œµ(œÅ n‚Äñ{œÉ‚ÇÇ n}) = 0
  ¬∑ simp [hœÉ‚ÇÇ]
  replace hœÉ‚ÇÇ := Prob.zero_lt_coe hœÉ‚ÇÇ
  have hœÉ‚ÇÅ : (0 : ‚Ñù) < Œ≤_ Œµ(œÅ n‚Äñ{œÉ‚ÇÅ n}) := by
    refine OptimalHypothesisRate.rate_pos_of_smul_pos hœÉ‚ÇÇ (Real.exp_pos (-f n)) ?_
    exact hœÉ n --For some reason turning these two lines into one `exact` causes timeouts
  rw [‚Üê ENNReal.toReal_le_toReal (by finiteness) (by finiteness)]
  rw [ENNReal.toReal_add (by finiteness) (by finiteness)]
  simp only [Prob.negLog_pos_Real, ENNReal.coe_toReal, OptimalHypothesisRate,
    Set.mem_singleton_iff, iSup_iSup_eq_left] at hœÉ‚ÇÅ hœÉ‚ÇÇ ‚ä¢
  rw [‚Üê neg_le_neg_iff]
  simp only [neg_add_rev, neg_neg]
  rw [‚Üê Real.log_exp (-f n), ‚Üê Real.log_mul (by positivity) (by positivity)]
  apply Real.log_le_log (by positivity)
  simp only [Prob.coe_iInf]
  rw [Real.mul_iInf_of_nonneg (by positivity)]
  apply ciInf_mono
  ¬∑ use 0
    rintro a ‚ü®y, rfl‚ü©
    have := (œÉ‚ÇÇ n).exp_val_nonneg y.2.2.1
    positivity
  intro ‚ü®x, hx‚ÇÅ, hx‚ÇÇ, hx‚ÇÉ‚ü©
  simp only [MState.exp_val, ‚Üê HermitianMat.smul_inner]
  exact HermitianMat.inner_mono' hx‚ÇÇ (hœÉ n)

/-- Lemma S3 from the paper. What they denote as œÉ‚Çô and œÉ‚Çô', we denote as œÉ‚ÇÅ and œÉ‚ÇÇ. The `exp(-o(n))`
we express as a function `f : ‚Ñï ‚Üí ‚Ñù`, together with the fact that `f` is little-o of `n` (i.e. that
`f =o[.atTop] id`), and then writing `exp(-f)`. We also split LemmaS3 into two parts, the `lim inf` part
and the `lim sup` part. The theorem as written is true for any `f`, but we can restrict to nonnegative
`f` (so, `‚Ñï ‚Üí ‚Ñù‚â•0`) which is easier to work with and more natural in the subsequent proofs. -/
private theorem LemmaS3_inf {Œµ : Prob}
    {d : ‚Ñï ‚Üí Type*} [‚àÄ n, Fintype (d n)] [‚àÄ n, DecidableEq (d n)]
    (œÅ œÉ‚ÇÅ œÉ‚ÇÇ : (n : ‚Ñï) ‚Üí MState (d n))
    (f : ‚Ñï ‚Üí ‚Ñù‚â•0) (hf : (f ¬∑ : ‚Ñï ‚Üí ‚Ñù) =o[.atTop] (¬∑ : ‚Ñï ‚Üí ‚Ñù))
    (hœÉ : ‚àÄ i, Real.exp (-f i) ‚Ä¢ (œÉ‚ÇÇ i).M ‚â§ œÉ‚ÇÅ i)
    :
    Filter.atTop.liminf (fun (n : ‚Ñï) ‚Ü¶ ‚Äîlog Œ≤_ Œµ(œÅ n‚Äñ{œÉ‚ÇÅ n}) / n) ‚â§
      Filter.atTop.liminf (fun (n : ‚Ñï) ‚Ü¶ ‚Äîlog Œ≤_ Œµ(œÅ n‚Äñ{œÉ‚ÇÇ n}) / n)
    := by
  --Starting with `helper`, divide by n and take the limits. Since f is o(n),
  --the (f n) / n term will go to zero.
  trans Filter.atTop.liminf fun n ‚Ü¶ (‚Äîlog Œ≤_ Œµ(œÅ n‚Äñ{œÉ‚ÇÇ n}) + f n) / n
  ¬∑ refine Filter.liminf_le_liminf (.of_forall ?_)
    intro
    grw [LemmaS3_helper _ _ _ _ hœÉ]
  ¬∑ apply le_of_eq
    simp_rw [ENNReal.add_div]
    apply ENNReal.liminf_add_of_right_tendsto_zero
    convert Asymptotics.IsLittleO.tendsto_div_nhds_zero hf
    rw [‚Üê ENNReal.tendsto_toReal_iff_of_eventually_ne_top ?_ ENNReal.zero_ne_top]
    ¬∑ simp
    ¬∑ rw [Filter.eventually_atTop]
      use 1
      finiteness

private theorem LemmaS3_sup {Œµ : Prob}
    {d : ‚Ñï ‚Üí Type*} [‚àÄ n, Fintype (d n)] [‚àÄ n, DecidableEq (d n)]
    (œÅ œÉ‚ÇÅ œÉ‚ÇÇ : (n : ‚Ñï) ‚Üí MState (d n))
    (f : ‚Ñï ‚Üí ‚Ñù‚â•0) (hf : (f ¬∑ : ‚Ñï ‚Üí ‚Ñù) =o[.atTop] (¬∑ : ‚Ñï ‚Üí ‚Ñù))
    (hœÉ : ‚àÄ i, Real.exp (-f i) ‚Ä¢ (œÉ‚ÇÇ i).M ‚â§ œÉ‚ÇÅ i)
    :
    Filter.atTop.limsup (fun (n : ‚Ñï) ‚Ü¶ ‚Äîlog Œ≤_ Œµ(œÅ n‚Äñ{œÉ‚ÇÅ n}) / n) ‚â§
      Filter.atTop.limsup (fun (n : ‚Ñï) ‚Ü¶ ‚Äîlog Œ≤_ Œµ(œÅ n‚Äñ{œÉ‚ÇÇ n}) / n)
    := by
  --Starting with `helper`, divide by n and take the limits. Since f is o(n),
  --the (f n) / n term will go to zero.
  trans Filter.atTop.limsup fun n ‚Ü¶ (‚Äîlog Œ≤_ Œµ(œÅ n‚Äñ{œÉ‚ÇÇ n}) + f n) / n
  ¬∑ refine Filter.limsup_le_limsup (.of_forall ?_)
    dsimp
    intro x
    grw [LemmaS3_helper _ _ _ _ hœÉ]
  ¬∑ apply le_of_eq
    simp_rw [ENNReal.add_div]
    apply ENNReal.limsup_add_of_right_tendsto_zero
    convert Asymptotics.IsLittleO.tendsto_div_nhds_zero hf
    rw [‚Üê ENNReal.tendsto_toReal_iff_of_eventually_ne_top ?_ ENNReal.zero_ne_top]
    ¬∑ simp
    ¬∑ rw [Filter.eventually_atTop]
      use 1
      finiteness

-- This is not exactly how R_{1, Œµ} is defined in Eq. (17), but it should be equal due to
-- the monotonicity of log and Lemma 3.
private noncomputable def R1 (œÅ : MState (H i)) (Œµ : Prob) : ‚Ñù‚â•0‚àû :=
  Filter.atTop.liminf fun n ‚Ü¶ ‚Äîlog Œ≤_ Œµ(œÅ‚äó^S[n]‚ÄñIsFree) / n

private noncomputable def R2 (œÅ : MState (H i)) : ((n : ‚Ñï) ‚Üí IsFree (i := i ^ n)) ‚Üí ‚Ñù‚â•0‚àû :=
  fun œÉ ‚Ü¶ Filter.atTop.liminf fun n ‚Ü¶ ùêÉ(œÅ‚äó^S[n]‚ÄñœÉ n) / n

/-- Lemma 7 from the paper. We write `Œµ'` for their `\tilde{Œµ}`. -/
private theorem Lemma7 (œÅ : MState (H i)) {Œµ : Prob} (hŒµ : 0 < Œµ ‚àß Œµ < 1) (œÉ : (n : ‚Ñï) ‚Üí IsFree (i := i ^ n)) :
    (R2 œÅ œÉ ‚â• R1 œÅ Œµ) ‚Üí
    ‚àÄ Œµ' : Prob, (hŒµ' : 0 < Œµ' ‚àß Œµ' < Œµ) ‚Üí -- Œµ' is written as \tilde{Œµ} in the paper.
    ‚àÉ œÉ' : (n : ‚Ñï) ‚Üí IsFree (i := i ^ n),
    R2 œÅ œÉ' - R1 œÅ Œµ ‚â§ .ofNNReal (1 - Œµ' : Prob) * (R2 œÅ œÉ - R1 œÅ Œµ)
    := by
  --This proof naturally splits out into LemmaS62:
  --  `lim inf n‚Üí‚àû 1/n D(E_n(œÅ^‚äón)‚ÄñœÉ''_n) ‚àí R1,œµ ‚â§ (1 ‚àí Àúœµ)(R2 ‚àí R1,œµ).`
  --This is proved in appendix C.
  --Then we prove S61, and the conclusion is just `rw [S61] at S62`. But splitting it like
  --this requires first _defining_ the sequence œÉ''_n.

  --First deal with the easy case of R1 = R2.
  intro hR1R2 Œµ' ‚ü®hŒµ'‚ÇÅ, hŒµ'‚ÇÇ‚ü©
  rw [ge_iff_le, le_iff_lt_or_eq, or_comm] at hR1R2
  rcases hR1R2 with hR1R2|hR1R2
  ¬∑ rw [hR1R2]
    use œÉ
    simp
  --This leaves us with the stronger statement that R1 < R2 strictly.
  --Before proceeding, let's reduce to the case that they're finite.
  have hR1 : R1 œÅ Œµ ‚â† ‚ä§ := hR1R2.ne_top
  rcases eq_or_ne (R2 œÅ œÉ) ‚ä§ with hR2|hR2
  ¬∑ rw [hR2, ENNReal.top_sub hR1, ENNReal.mul_top', if_neg]
    ¬∑ simp
    ¬∑ have : Œµ'.val < 1 := hŒµ'‚ÇÇ.trans hŒµ.2
      rcases Œµ' with ‚ü®Œµ',hŒµ'‚ÇÅ,hŒµ'‚ÇÇ‚ü©
      simp only [Prob.toNNReal, Prob.coe_one_minus, ENNReal.coe_eq_zero]
      rw [Subtype.ext_iff, val_eq_coe, val_eq_coe, coe_zero, coe_mk]
      linarith +splitNe

  --Start giving the definitions from the paper. Define Œµ‚ÇÄ
  let Œµ‚ÇÄ : ‚Ñù := (R2 œÅ œÉ - R1 œÅ Œµ).toReal * (Œµ - Œµ') / (1 - Œµ)
  have hŒµ‚ÇÄ : 0 < Œµ‚ÇÄ :=
    have := sub_pos.mpr (show Œµ.val < 1 from hŒµ.2)
    have := sub_pos.mpr (show Œµ'.val < Œµ from hŒµ'‚ÇÇ)
    have : 0 < (SteinsLemma.R2 œÅ œÉ - SteinsLemma.R1 œÅ Œµ).toReal :=
      ENNReal.toReal_pos (tsub_pos_of_lt hR1R2).ne' (ENNReal.sub_ne_top hR2)
    by positivity

  -- m exists because R2 + Œµ‚ÇÄ is strictly above R2, which is the liminf.
  obtain ‚ü®m, hm‚ü© :=
    have h : R2 œÅ œÉ < R2 œÅ œÉ + .ofNNReal ‚ü®Œµ‚ÇÄ, hŒµ‚ÇÄ.le‚ü© :=
      ENNReal.lt_add_right hR2 (by simp [‚Üê NNReal.coe_eq_zero, hŒµ‚ÇÄ.ne'])
    (Filter.frequently_lt_of_liminf_lt (h := h)).exists

  --Define œÉ‚ÇÅ
  obtain ‚ü®œÉ‚ÇÅ, hœÉ‚ÇÅ_pos, hœÉ‚ÇÅ_free‚ü© := FreeStateTheory.free_fullRank i

  -- Define œÉÃÉ‚Çô in terms of œÉ‚Çò
  let ¬´œÉÃÉ¬ª (n) := Lemma6_œÉn m œÉ‚ÇÅ (œÉ m) n
  have ¬´œÉÃÉ_free¬ª (n) : IsFree (¬´œÉÃÉ¬ª (n)) := Lemma6_œÉn_IsFree hœÉ‚ÇÅ_free (fun n ‚Ü¶ (œÉ n).2) m n

  --Define œÉ‚ãÜ
  have œÉ_max_exists (n : ‚Ñï) := IsCompact_IsFree.exists_isMaxOn Set.Nonempty.of_subtype
      (f := fun œÉ ‚Ü¶ Œ≤_ Œµ(œÅ‚äó^S[n]‚Äñ{œÉ})) (hf := Continuous.continuousOn (by fun_prop))
  let ¬´œÉ‚ãÜ¬ª (n) := Classical.choose (œÉ_max_exists n)
  have ¬´œÉ‚ãÜ_free¬ª (n) : IsFree (¬´œÉ‚ãÜ¬ª n) := (œÉ_max_exists n).choose_spec.left
  have ¬´œÉ‚ãÜ_max¬ª (n) : IsMaxOn _ IsFree (¬´œÉ‚ãÜ¬ª n) := (œÉ_max_exists n).choose_spec.right

  --Finally define œÉ' as an even mixture of œÉÃÉ, œÉ‚ãÜ, and œÉ_full.
  --TODO: would be nice to write a `Mixable` thing for mixing `k` things according to a distribution,
  -- in this case `Distribution.uniform (Fin 3)`.
  let œÉ' := fun n ‚Ü¶ ‚ü®2/3, by norm_num‚ü© [‚ü®1/2, by norm_num‚ü© [¬´œÉÃÉ¬ª n ‚Üî ¬´œÉ‚ãÜ¬ª n] ‚Üî œÉ‚ÇÅ‚äó^S[n]]
  have œÉ'_free (n) : IsFree (œÉ' n) := by
    --by convexity of `IsFree` and that the three constituents are free
    unfold œÉ'
    apply IsFree.mix
    ¬∑ exact (¬´œÉÃÉ_free¬ª n).mix (¬´œÉ‚ãÜ_free¬ª n) _
    ¬∑ exact hœÉ‚ÇÅ_free.npow n
  have œÉ'_posdef (n) : (œÉ' n).m.PosDef := by
    --because œÉ‚ÇÅ is PosDef, so is œÉ‚ÇÅ‚äó^[n], and so is any convex mixture.
    unfold œÉ'
    apply MState.PosDef_mix_of_ne_one
    ¬∑ apply UnitalPretheory.PosDef.npow hœÉ‚ÇÅ_pos
    ¬∑ norm_num [‚Üê Prob.ne_iff]

  --Clean up the goal... a bit... still a mess!
  clear ¬´œÉÃÉ_free¬ª ¬´œÉ‚ãÜ_max¬ª ¬´œÉ‚ãÜ_free¬ª

  -- Œª_full, the minimum eigenvalue of œÉ_full
  let mineig := ‚®Ö i, œÉ‚ÇÅ.M.H.eigenvalues i
  obtain ‚ü®i_min, hi_min‚ü© := exists_eq_ciInf_of_finite (f := (HermitianMat.H œÉ‚ÇÅ.M).eigenvalues)

  have h_min_pos : 0 < mineig := by
    --because œÉ‚ÇÅ is PosDef, all eigenvalues are positive, so their minimum is positive
    unfold mineig
    rw [‚Üê hi_min]
    exact hœÉ‚ÇÅ_pos.eigenvalues_pos i_min

  have h_min_le_one : mineig ‚â§ 1 := by
    --all eigenvalues of a state are at most 1. (We might not actually need this fact.)
    unfold mineig
    rw [‚Üê hi_min]
    exact œÉ‚ÇÅ.eigenvalue_le_one i_min

  clear i_min hi_min

  -- The sequence c_n given in (S44). In order to handle when c = 0, I've replaced the
  -- (Real.log 3) / n term with (Real.log 3) / (max n 1). I expect this will work down the line.
  let c (n : ‚Ñï) := Real.log (1 / mineig) + (Real.log 3) / (max n 1)
  have hc (n) : 0 < c n := by
    have h‚ÇÅ : 0 ‚â§ Real.log (1 / mineig) := by bound
    positivity

  have hc_lim : Filter.atTop.Tendsto (fun n ‚Ü¶ (c n) / n) (ùìù 0) := by
    have h_const : Filter.atTop.Tendsto (fun n : ‚Ñï ‚Ü¶ Real.log (1 / mineig) / n) (ùìù 0) :=
        tendsto_const_nhds.div_atTop tendsto_natCast_atTop_atTop;
    -- We can split the limit into two parts: the constant term and the term involving log(3).
    have h_div : Filter.atTop.Tendsto (fun n : ‚Ñï ‚Ü¶ Real.log 3 / (max n 1 * n)) (ùìù 0) :=
      tendsto_const_nhds.div_atTop <| Filter.tendsto_atTop_mono (fun n ‚Ü¶ by
        norm_cast; nlinarith [le_max_left n 1, le_max_right n 1]) tendsto_natCast_atTop_atTop
    convert h_const.add h_div using 2 <;> ring

  -- The function f_n(Œª) in (S45)
  let f (n : ‚Ñï) (lam : ‚Ñù) := ‚åàReal.log lam / c n‚åâ * c n
  --(S46)
  have h_le_f (n) (lam) : Real.log lam ‚â§ f n lam := calc
    _ ‚â§ (‚åàReal.log lam / (c n)‚åâ) * c n := by
      rw [‚Üê mul_inv_le_iff‚ÇÄ (hc n)]
      apply Int.le_ceil _
    _ = f n lam := by
      rfl
  have h_f_le (n) (lam) : f n lam < Real.log lam + c n := calc
    f n lam = ‚åàReal.log lam / c n‚åâ * c n := by
      rfl
    _ < (Real.log lam / c n + 1) * c n := by
      specialize hc n
      gcongr
      exact Int.ceil_lt_add_one _
    _ ‚â§ Real.log lam + c n := by
      specialize hc n
      field_simp
      rfl

  --Define œÉ'' first as the (unnormalized) cfc image of œÉ' under `Œª ‚Üí exp (f n Œª)`.
  let œÉ''_unnormalized (n) : HermitianMat (H (i ^ n)) ‚ÑÇ := --TODO: Define a HermitianMat.cfc function that behaves nicely
    (œÉ' n).M.cfc fun e ‚Ü¶ Real.exp (f n e)

  have œÉ''_unnormalized_PosDef (n) : Matrix.PosDef (œÉ''_unnormalized n).val := by
    dsimp [œÉ''_unnormalized]
    rw [HermitianMat.cfc_PosDef]
    intro
    positivity

  have œÉ''_tr_bounds (n) : 1 ‚â§ (œÉ''_unnormalized n).trace ‚àß (œÉ''_unnormalized n).trace ‚â§ Real.exp (c n) := by
    sorry

  --Then œÉ'' is the normalized version, which will work because œÉ''_unnormalized is PosDef
  let œÉ'' (n) : MState (H (i ^ n)) := {
    --TODO make this its own definition
    M := (œÉ''_unnormalized n).trace‚Åª¬π ‚Ä¢ (œÉ''_unnormalized n)
    zero_le := sorry
    tr := sorry
  }

  have œÉ'_le_œÉ'' (n) : Real.exp (-c n) ‚Ä¢ (œÉ' n).M ‚â§ œÉ'' n := by
    sorry
  have œÉ''_le_œÉ' (n) : œÉ'' n ‚â§ Real.exp (c n) ‚Ä¢ (œÉ' n).M := by
    sorry

  have qRel_œÉ''_le_œÉ' (n) : ùêÉ(œÅ‚äó^S[n]‚ÄñœÉ'' n) ‚â§ ùêÉ(œÅ‚äó^S[n]‚ÄñœÉ' n) + ENNReal.ofReal (c n) := by
    sorry

  have qRel_œÉ'_le_œÉ'' (n) : ùêÉ(œÅ‚äó^S[n]‚ÄñœÉ' n) ‚â§ ùêÉ(œÅ‚äó^S[n]‚ÄñœÉ'' n) + ENNReal.ofReal (c n) := by
    sorry

  -- Definition of the pinching map w.r.t. œÉ'' in Eq. (S55)
  let ‚Ñ∞ (n) := pinching_map (œÉ'' n)

  -- Number of distinct eigenvalues of œÉ'' in Eq. (S56) is
  -- Fintype.card (spectrum ‚Ñù (œÉ'' n).m), which is d‚Çô in the paper.
  have hdle : ‚àÄ n, Fintype.card (spectrum ‚Ñù (œÉ'' n).m) ‚â§ n + 1 := by
    sorry
  have hdpos : ‚àÄ n, 0 < Fintype.card (spectrum ‚Ñù (œÉ'' n).m) := by
    sorry

  -- Eq (S59) has a minus sign, which gets complicated when one of the relative entropies is infinite.
  -- However, I don't think we need this version with the minus sign
  -----
  -- have rel_ent_pinching (n) : ùêÉ(œÅ‚äó^S[n]‚Äñ‚Ñ∞ n (œÅ‚äó^S[n])) = ùêÉ(œÅ‚äó^S[n]‚ÄñœÉ'' n) - ùêÉ(‚Ñ∞ n (œÅ‚äó^S[n])‚ÄñœÉ'' n) := by
  --   unfold ‚Ñ∞
  --   rw [pinching_pythagoras (œÅ‚äó^S[n]) (œÉ'' n)]
  --   have hDfin : ùêÉ((pinching_map (œÉ'' n)) (œÅ‚äó^S[n])‚ÄñœÉ'' n) ‚â† ‚àû := by
  --     sorry
  --   rw [‚Üê ENNReal.coe_toNNReal hDfin]
  --   simp only [ENNReal.addLECancellable_iff_ne, ne_eq, ENNReal.coe_ne_top, not_false_eq_true,
  --     AddLECancellable.add_tsub_cancel_right]
  have qRel_pinching_pythagoras (n) : ùêÉ(œÅ‚äó^S[n]‚ÄñœÉ'' n) = ùêÉ(œÅ‚äó^S[n]‚Äñ‚Ñ∞ n (œÅ‚äó^S[n])) + ùêÉ(‚Ñ∞ n (œÅ‚äó^S[n])‚ÄñœÉ'' n) := by
    exact pinching_pythagoras (œÅ‚äó^S[n]) (œÉ'' n)

  -- Eq. (S60)
  have qRel_ent_bound (n) : ùêÉ(œÅ‚äó^S[n]‚Äñ‚Ñ∞ n (œÅ‚äó^S[n])) ‚â§ ENNReal.ofReal (Real.log (n + 1)) := calc
    ùêÉ(œÅ‚äó^S[n]‚Äñ‚Ñ∞ n (œÅ‚äó^S[n])) ‚â§ ENNReal.ofReal (Real.log (Fintype.card (spectrum ‚Ñù (œÉ'' n).m))) :=
      qRelativeEnt_op_le (by simp [hdpos n]) (pinching_bound ..)
    _ ‚â§ ENNReal.ofReal (Real.log (n + 1)) := by
      grw [hdle n]
      ¬∑ exact_mod_cast le_rfl
      ¬∑ simp [hdpos n]

  -- Eq. (S61)
  have hliminf : Filter.atTop.liminf (fun n ‚Ü¶ ùêÉ(œÅ‚äó^S[n]‚ÄñœÉ' n) / n) =
                 Filter.atTop.liminf (fun n ‚Ü¶ ùêÉ(‚Ñ∞ n (œÅ‚äó^S[n])‚ÄñœÉ'' n) / n) := by
    trans Filter.atTop.liminf fun n ‚Ü¶ ùêÉ(œÅ‚äó^S[n]‚ÄñœÉ'' n) / n
    ¬∑ have hg : Filter.atTop.Tendsto (fun n ‚Ü¶ ENNReal.ofReal (c n) / n) (ùìù 0) := by
        rw [‚Üê ENNReal.tendsto_toReal_iff_of_eventually_ne_top ?_ ENNReal.zero_ne_top]
        ¬∑ simpa [ENNReal.toReal_ofReal (hc _).le]
        ¬∑ rw [Filter.eventually_atTop]
          use 1
          intros
          finiteness
      apply le_antisymm
      ¬∑ nth_rw 2 [‚Üê ENNReal.liminf_add_of_right_tendsto_zero hg]
        conv =>
          enter [2, 1, n]
          rw [Pi.add_apply, ‚Üê ENNReal.add_div]
        apply Filter.liminf_le_liminf (Œ≤ := ‚Ñù‚â•0‚àû)
        rw [Filter.eventually_atTop]
        use 1
        intro n _
        exact ENNReal.div_le_div (qRel_œÉ'_le_œÉ'' n) (by rfl)
      -- A copy of the ¬∑ above with œÉ' and œÉ'' swapped
      ¬∑ nth_rw 2 [‚Üê ENNReal.liminf_add_of_right_tendsto_zero hg]
        conv =>
          enter [2, 1, n]
          rw [Pi.add_apply, ‚Üê ENNReal.add_div]
        apply Filter.liminf_le_liminf (Œ≤ := ‚Ñù‚â•0‚àû)
        rw [Filter.eventually_atTop]
        use 1
        intro n _
        exact ENNReal.div_le_div (qRel_œÉ''_le_œÉ' n) (by rfl)
    ¬∑ simp only [qRel_pinching_pythagoras, ENNReal.add_div, ‚Üê Pi.add_apply]
      conv =>
        lhs
        apply ENNReal.liminf_add_of_left_tendsto_zero
        tactic =>
          apply tendsto_of_tendsto_of_tendsto_of_le_of_le
            (g := (0 : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû)) (h := fun n ‚Ü¶ ENNReal.ofReal (Real.log (n + 1)) / n)
          ¬∑ exact tendsto_const_nhds
          ¬∑  -- Basically that lim_n‚Üí‚àû log n / n = 0
            rw [‚Üê Filter.tendsto_sub_atTop_iff_nat 1]
            apply Filter.Tendsto.congr' (f‚ÇÅ := fun (n : ‚Ñï) ‚Ü¶ ENNReal.ofReal (Real.log n / (n - 1)))
            ¬∑ simp only [Filter.EventuallyEq, ‚Üê ENNReal.ofReal_natCast, Filter.eventually_atTop]
              use 2; intros b hb
              convert ENNReal.ofReal_div_of_pos (y := b - 1) (by rify at b hb; linarith)
              ¬∑ norm_cast
                omega
              ¬∑ norm_cast; symm; apply Int.subNatNat_of_le
                omega
            refine Filter.Tendsto.comp (g := fun r ‚Ü¶ ENNReal.ofReal (Real.log r / (r - 1)))
              ?_ tendsto_natCast_atTop_atTop
            rw [‚Üê ENNReal.ofReal_zero]
            apply ENNReal.tendsto_ofReal
            convert Real.tendsto_pow_log_div_mul_add_atTop 1 (-1) 1 (zero_ne_one.symm) using 3
            ¬∑ simp
            ¬∑ ring
          ¬∑ positivity
          ¬∑ intro n
            exact ENNReal.div_le_div (qRel_ent_bound n) le_rfl

  -- Eq. (S62)
  have hliminfR : Filter.atTop.liminf (fun n ‚Ü¶ ùêÉ(‚Ñ∞ n (œÅ‚äó^S[n])‚ÄñœÉ'' n) / n) - R1 œÅ Œµ ‚â§
      ‚Üë(1 - Œµ') * (R2 œÅ œÉ - R1 œÅ Œµ) := by
    sorry

  use fun n ‚Ü¶ ‚ü®œÉ' n, œÉ'_free n‚ü©
  rw [R2, hliminf]
  exact hliminfR

/-- Lemma 7 gives us a way to repeatedly "improve" a sequence œÉ to one with a smaller gap between R2 and R1.
The paper paints this as pretty much immediate from Lemma7, but we need to handle the case where R2 is below
R1. -/
private noncomputable def Lemma7_improver (œÅ : MState (H i)) {Œµ : Prob} (hŒµ : 0 < Œµ ‚àß Œµ < 1) {Œµ' : Prob} (hŒµ' : 0 < Œµ' ‚àß Œµ' < Œµ) :
    --The parameters above are the "fixed" parameters that we'll improve
    --It takes one sequence of free states, `(n : ‚Ñï) ‚Üí IsFree (i := i ^ n)`, and gives a new one
    ((n : ‚Ñï) ‚Üí IsFree (i := i ^ n)) ‚Üí ((n : ‚Ñï) ‚Üí IsFree (i := i ^ n)) :=
  fun œÉ ‚Ü¶
    if h : R2 œÅ œÉ ‚â• R1 œÅ Œµ then
      (Lemma7 œÅ hŒµ œÉ h Œµ' hŒµ').choose
    else
     œÉ --The gap was already 0 (or even, negative!) so leave it unchanged.

/-- The Lemma7_improver does its job at shrinking the gap. -/
theorem Lemma7_gap (œÅ : MState (H i)) {Œµ : Prob} (hŒµ : 0 < Œµ ‚àß Œµ < 1) {Œµ' : Prob} (hŒµ' : 0 < Œµ' ‚àß Œµ' < Œµ) :
    ‚àÄ œÉ,
      letI œÉ' := Lemma7_improver œÅ hŒµ hŒµ' œÉ;
      R2 œÅ œÉ' - R1 œÅ Œµ ‚â§ .ofNNReal (1 - Œµ' : Prob) * (R2 œÅ œÉ - R1 œÅ Œµ) := by
  intro œÉ
  dsimp [SteinsLemma.Lemma7_improver]
  split_ifs with h
  ¬∑ exact (SteinsLemma.Lemma7 œÅ hŒµ œÉ h Œµ' hŒµ').choose_spec
  ¬∑ push_neg at h
    rw [tsub_eq_zero_of_le h.le]
    exact zero_le _

end Lemma7

/-- Theorem 1 in https://arxiv.org/pdf/2408.02722v3 -/
theorem GeneralizedQSteinsLemma {i : Œπ} (œÅ : MState (H i)) {Œµ : Prob} (hŒµ : 0 < Œµ ‚àß Œµ < 1) :
    Filter.atTop.Tendsto (fun n ‚Ü¶ ‚Äîlog Œ≤_ Œµ(œÅ‚äó^S[n]‚ÄñIsFree) / n) (ùìù (ùëÖ·µ£‚àû œÅ)) := by

  --It suffices to show limsup LHS ‚â§ RHS and liminf LHS ‚â• RHS.
  refine tendsto_of_le_liminf_of_limsup_le ?_ ?_
  ¬∑ -- the "key part" of the "opposite inequality".
    --We need to pick an Œµ' (a \tilde{Œµ} in the paper). The only constraint(?) is that it's strictly
    --less than Œµ. We take Œµ' := Œµ/2.
     --TODO: Should we have an HDiv Prob Nat instance?
    let Œµ' : Prob := ‚ü®Œµ/2, by constructor <;> linarith [Œµ.zero_le_coe, Œµ.coe_le_one]‚ü©
    have hŒµ' : 0 < Œµ' ‚àß Œµ' < Œµ := by constructor <;> change (_ : ‚Ñù) < (_ : ‚Ñù) <;> simpa [Œµ'] using hŒµ.1

    --Take some initial sequence œÉ‚ÇÅ. We need to pick it so that `R2 œÅ œÉ‚ÇÅ` is finite, 