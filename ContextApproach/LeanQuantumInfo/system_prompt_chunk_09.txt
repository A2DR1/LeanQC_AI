# Lean 4 Code Generation System Prompt (Chunked Version)

You are an expert Lean 4 theorem prover specializing in quantum information theory. Convert natural language prompts into precise Lean 4 code using the Lean-QuantumInfo repository as reference.

## Your Role
Convert natural language descriptions of mathematical concepts, theorems, and proofs into formal Lean 4 code following the exact patterns, definitions, and conventions from the Lean-QuantumInfo repository.

## Key Repository Patterns

### Probability & Distributions
```lean
def Prob := { p : ‚Ñù // 0 ‚â§ p ‚àß p ‚â§ 1 }
def Distribution (Œ± : Type u) [Fintype Œ±] : Type u :=
  { f : Œ± ‚Üí Prob // Finset.sum Finset.univ (fun i ‚Ü¶ (f i : ‚Ñù)) = 1 }
```

### Quantum States
```lean
structure MState (d : Type*) [Fintype d] :=
  m : Matrix d d ‚ÑÇ
  pos : m.PosSemidef
  tr : m.trace = 1

structure Bra (d : ‚Ñï) :=
  vec : Fin d ‚Üí ‚ÑÇ
  normalized' : ‚àë i, ‚Äñvec i‚Äñ^2 = 1
```

### Entropy Functions
```lean
def shannon_entropy (p : Distribution Œ±) : ‚Ñù :=
  -‚àë x, (p.val x).toReal * Real.log (p.val x).toReal

def von_neumann_entropy (œÅ : MState d) : ‚Ñù :=
  -‚àë i, (eigenvalues œÅ.m i).toReal * Real.log (eigenvalues œÅ.m i).toReal
```

## Response Format
1. **Analysis**: Explain the mathematical concept
2. **Lean Code**: Complete implementation with imports
3. **Explanation**: Key components and mathematical meaning
4. **Dependencies**: Required imports and related definitions

## Guidelines
- Use Unicode: `‚Ñù`, `‚Ñï`, `‚ÑÇ`, `‚Üí`, `‚Üî`, `‚àß`, `‚à®`, `‚àÄ`, `‚àÉ`
- Include docstrings: `/-- ... -/`
- Type annotations: `[Fintype Œ±]`, `[DecidableEq Œ±]`
- Use `sorry` for incomplete proofs
- Follow repository naming conventions
- Reference existing definitions when possible

## Repository Content Reference

The following is a portion of the Lean-QuantumInfo repository content. Use this as reference for code generation:

---

_subset_of_mem_Icc B.H hl hr

@[fun_prop]
protected theorem cfc_continuous {f : ‚Ñù ‚Üí ‚Ñù} (hf : Continuous f) :
    Continuous (cfc ¬∑ f : HermitianMat d ùïú ‚Üí HermitianMat d ùïú) := by
  unfold cfc
  suffices Continuous (fun A : HermitianMat d ùïú ‚Ü¶ _root_.cfc f (toMat A)) by
    fun_prop
  --Why is this so messy? Well `Continuous.cfc` only works on _compact_ sets of spectra,
  --but for operators with finite spectrum (like matrices), we obviously want it to work
  --for any functions. So we start by saying that `cfc ¬∑ f` is continuous if it works
  --on any open cover, use open intervals, then we can take the closures of these to get
  --closed intervals, and then these are valid compact sets.
  have h_compact_cover := LocallyCompactSpace.local_compact_nhds (X := HermitianMat d ùïú)
  apply continuous_of_continuousOn_iUnion_of_isOpen (Œπ := HermitianMat d ùïú √ó {x : ‚Ñù // 0 < x})
    (s := fun ab ‚Ü¶ Metric.ball ab.1 ab.2)
  ¬∑ rintro ‚ü®A, r, hr‚ü©
    apply ContinuousOn.mono ?_ (ball_subset_Icc A r)
    obtain ‚ü®a, b, hab‚ü© := spectrum_subset_of_mem_Icc (A - r ‚Ä¢ 1) (A + r ‚Ä¢ 1)
    open Matrix.Norms.Frobenius in
    exact ContinuousOn.cfc isCompact_Icc f (by fun_prop) hab (fun x _ ‚Ü¶ x.H)
  ¬∑ simp
  ¬∑ ext x
    simp only [Set.mem_iUnion, Set.mem_univ, iff_true]
    use ‚ü®x, 1‚ü©
    simp

/-! Here we give HermitianMat versions of many cfc theorems, like `cfc_id`, `cfc_sub`, `cfc_comp`,
etc. We need these because (as above) `HermitianMat.cfc` is different from `_root_.cfc`. -/

@[simp]
nonrec theorem cfc_id : cfc A id = A := by
  simp [HermitianMat.ext_iff, cfc_id]

@[simp]
nonrec theorem cfc_id' : cfc A (¬∑) = A :=
  cfc_id A

nonrec theorem cfc_add : cfc A (f + g) = cfc A f + cfc A g := by
  rw [HermitianMat.ext_iff]
  exact cfc_add (hf := herm_cont) (hg := herm_cont)

nonrec theorem cfc_sub : cfc A (f - g) = cfc A f - cfc A g := by
  rw [HermitianMat.ext_iff]
  exact cfc_sub (hf := herm_cont) (hg := herm_cont)

nonrec theorem cfc_neg : cfc A (-f) = -cfc A f := by
  rw [HermitianMat.ext_iff]
  exact cfc_neg f A.toMat

/-- We don't have a direct analog of `cfc_mul`, since we can't generally multiply
to HermitianMat's to get another one, so the theorem statement wouldn't be well-typed.
But, we can say that the matrices are always equal. See `cfc_conj` for the coe-free
analog to multiplication. -/
theorem coe_cfc_mul : (cfc A (f * g)).toMat = cfc A f * cfc A g := by
  simp only [cfc_toMat]
  exact cfc_mul (hf := herm_cont) (hg := herm_cont)

nonrec theorem cfc_comp : cfc A (g ‚àò f) = cfc (cfc A f) g := by
  rw [HermitianMat.ext_iff]
  exact cfc_comp (hf := herm_cont) (hg := herm_cont)

nonrec theorem cfc_conj : (cfc A f).conj (cfc A g) = cfc A (f * g^2) := by
  rw [HermitianMat.ext_iff, conj]
  simp only [cfc_toMat, val_eq_coe, mk_toMat, conjTranspose_cfc]
  rw [‚Üê cfc_mul (hf := herm_cont) (hg := herm_cont)]
  rw [‚Üê cfc_mul (hf := herm_cont) (hg := herm_cont)]
  rw [Pi.mul_def, Pi.pow_def]
  congr! 2; ring

@[simp]
nonrec theorem cfc_const : (cfc A (fun _ ‚Ü¶ r)) = r ‚Ä¢ 1 := by
  rw [HermitianMat.ext_iff]
  simp only [cfc_toMat, selfAdjoint.val_smul, val_eq_coe, selfAdjoint.val_one]
  rw [cfc_const r A.toMat]
  exact Algebra.algebraMap_eq_smul_one r

@[simp]
nonrec theorem cfc_const_mul_id : cfc A (fun x => r * x) = r ‚Ä¢ A := by
  rw [HermitianMat.ext_iff]
  simp only [cfc_toMat, selfAdjoint.val_smul, val_eq_coe]
  exact cfc_const_mul_id r A.toMat

@[simp]
nonrec theorem cfc_const_mul : cfc A (fun x => r * f x) = r ‚Ä¢ cfc A f := by
  rw [‚Üê cfc_const_mul_id, ‚Üê cfc_comp]
  rfl

@[simp]
nonrec theorem cfc_apply_zero : cfc (0 : HermitianMat d ùïú) f = f 0 ‚Ä¢ 1 := by
  simp [HermitianMat.ext_iff, Algebra.algebraMap_eq_smul_one]

@[simp]
nonrec theorem cfc_apply_one : cfc (1 : HermitianMat d ùïú) f = f 1 ‚Ä¢ 1 := by
  simp [HermitianMat.ext_iff, Algebra.algebraMap_eq_smul_one]

variable {f g} in
nonrec theorem cfc_congr (hfg : Set.EqOn f g (spectrum ‚Ñù A.toMat)) :
    cfc A f = cfc A g := by
  rw [HermitianMat.ext_iff]
  exact cfc_congr hfg

variable {f g A} in
/-- Version of `cfc_congr` specialized to PSD matrices. -/
nonrec theorem cfc_congr_of_zero_le (hA : 0 ‚â§ A) (hfg : Set.EqOn f g (Set.Ici 0)) :
    cfc A f = cfc A g := by
  refine cfc_congr A (hfg.mono ?_)
  exact fun i hi ‚Ü¶ spectrum_nonneg_of_nonneg hA hi

open ComplexOrder

variable {f g A} in
/-- Version of `cfc_congr` specialized to positive definite matrices. -/
nonrec theorem cfc_congr_of_posDef (hA : A.toMat.PosDef) (hfg : Set.EqOn f g (Set.Ioi 0)) :
    cfc A f = cfc A g := by
  refine cfc_congr A (hfg.mono ?_)
  rw [A.H.spectrum_real_eq_range_eigenvalues]
  rintro _ ‚ü®i, rfl‚ü©
  exact hA.eigenvalues_pos i

@[simp]
theorem cfc_diagonal (g : d ‚Üí ‚Ñù) :
    cfc (HermitianMat.diagonal g) f = HermitianMat.diagonal (f ‚àò g) := by
  ext1
  exact Matrix.cfc_diagonal g f

theorem cfc_eigenvalues (A : HermitianMat d ùïú) :
    ‚àÉ (e : d ‚âÉ d), (A.cfc f).H.eigenvalues = f ‚àò A.H.eigenvalues ‚àò e :=
  A.H.cfc_eigenvalues f

theorem zero_le_cfc : 0 ‚â§ A.cfc f ‚Üî ‚àÄ i, 0 ‚â§ f (A.H.eigenvalues i) := by
  rw [cfc, ‚Üê Subtype.coe_le_coe]
  dsimp
  rw [cfc_nonneg_iff (hf := herm_cont), A.H.spectrum_real_eq_range_eigenvalues]
  grind

variable {A f} in
theorem zero_le_cfc_of_zero_le (hA : 0 ‚â§ A) (hf : ‚àÄ i ‚â• 0, 0 ‚â§ f i) :
    0 ‚â§ A.cfc f := by
  rw [zero_le_cfc]
  intro i
  rw [zero_le_iff, A.H.posSemidef_iff_eigenvalues_nonneg] at hA
  exact hf _ (hA i)

theorem cfc_PosDef : (A.cfc f).toMat.PosDef ‚Üî ‚àÄ i, 0 < f (A.H.eigenvalues i) := by
  rw [(A.cfc f).H.posDef_iff_eigenvalues_pos]
  obtain ‚ü®e, he‚ü© := A.cfc_eigenvalues f
  rw [he]
  refine ‚ü®fun h i ‚Ü¶ ?_, fun h i ‚Ü¶ h (e i)‚ü©
  convert h (e.symm i)
  simp

/-- Matrix power of a positive semidefinite matrix, as given by the elementwise
  real power of the diagonal in a diagonalized form.

  Note that this has the usual `Real.rpow` caveats, such as 0 to the power -1 giving 0. -/
def rpow (p : ‚Ñù) : HermitianMat d ùïú :=
  cfc A (Real.rpow ¬∑ p)

instance instRPow : Pow (HermitianMat d ùïú) ‚Ñù :=
  ‚ü®rpow‚ü©

theorem pow_eq_rpow (p : ‚Ñù) : A ^ p = A.rpow p :=
  rfl

theorem pow_eq_cfc (p : ‚Ñù) : A ^ p = cfc A (¬∑ ^ p) :=
  rfl

theorem diagonal_pow (f : d ‚Üí ‚Ñù) (p : ‚Ñù) :
    (diagonal f) ^ p = diagonal fun i => (f i) ^ p := by
  simp [pow_eq_cfc]
  rfl

@[simp]
theorem pow_one : A ^ (1 : ‚Ñù) = A := by
  simp [pow_eq_cfc]

@[simp]
theorem reindex_pow (A : HermitianMat d ‚ÑÇ) (e : d ‚âÉ d‚ÇÇ) (p : ‚Ñù) :
    A.reindex e ^ p = (A ^ p).reindex e := by
  apply A.cfc_reindex

variable {A} in
theorem coe_rpow_add (hA : 0 ‚â§ A) {p q : ‚Ñù} (hpq : p + q ‚â† 0) :
    (A ^ (p + q)).toMat = (A ^ p).toMat * (A ^ q).toMat := by
  simp only [pow_eq_cfc, ‚Üê coe_cfc_mul, ‚Üê HermitianMat.ext_iff]
  exact cfc_congr_of_zero_le hA (fun i hi ‚Ü¶ Real.rpow_add' hi hpq)

variable {A} in
theorem rpow_mul (hA : 0 ‚â§ A) {p q : ‚Ñù} :
    (A ^ (p * q)) = ((A ^ p) ^ q) := by
  simp only [pow_eq_cfc, ‚Üê cfc_comp]
  exact cfc_congr_of_zero_le hA (fun i hi ‚Ü¶ Real.rpow_mul hi p q)

variable {A} in
theorem conj_rpow (hA : 0 ‚â§ A) {p q : ‚Ñù}
  (hq : q ‚â† 0) (hpq : p + 2 * q ‚â† 0) :
    (A ^ p).conj (A ^ q) = A ^ (p + 2 * q) := by
  simp only [pow_eq_cfc, cfc_conj]
  refine cfc_congr_of_zero_le hA (fun i hi ‚Ü¶ ?_)
  rw [pow_two, Real.rpow_add' hi hpq, two_mul, Real.rpow_add' hi (by simpa)]
  rfl

theorem pow_half_mul {d ùïú : Type*} [Fintype d] [DecidableEq d] [RCLike ùïú]
  {A : HermitianMat d ùïú} (hA : 0 ‚â§ A) :
    (A ^ (1/2 : ‚Ñù)).toMat * (A ^ (1/2 : ‚Ñù)).toMat = A := by
  rw [‚Üê coe_rpow_add hA]
  ¬∑ norm_num
  ¬∑ norm_num

/-- Matrix logarithm (base e) of a Hermitian matrix, as given by the elementwise
  real logarithm of the diagonal in a diagonalized form, using `Real.log`

  Note that this means that the nullspace of the image includes all of the nullspace of the
  original matrix. This contrasts to the standard definition, which is only defined for positive
  *definite* matrices, and the nullspace of the image is exactly the (Œª=1)-eigenspace of the
  original matrix. It coincides with the standard definition if A is positive definite. -/
def log : HermitianMat d ùïú :=
  cfc A Real.log

@[simp]
theorem reindex_log (e : d ‚âÉ d‚ÇÇ) : (A.reindex e).log = A.log.reindex e :=
  cfc_reindex A Real.log e

end CFC


================================================================================
FILE: QuantumInfo/ForMathlib/HermitianMat/Inner.lean
TYPE: Lean 4
SIZE: 28791 characters
================================================================================

import QuantumInfo.ForMathlib.HermitianMat.Order

import Mathlib.Analysis.Convex.Contractible

/-! # Inner product of Hermitian Matrices

For general matrices there are multiple reasonable notions of "inner product" (Hilbert‚ÄìSchmidt inner product,
Frobenius inner product), and so Mathlib avoids giving a canonical `InnerProductSpace` instance. But for the
particular case of Hermitian matrices, these all coincide, so we can put a canonical `InnerProductSpace`
instance.

This _does_ however induce a `Norm` on `HermitianMat` as well, the Frobenius norm, and this is less obviously
a uniquely correct choice. It is something that one essentially has to live with, with the way that Mathlib
currently structures the instances. (Thankfully, all norms induce the same _topology and bornology_ on
finite-dimensional matrices.)

Some care to be taken so that the topology induced by the InnerProductSpace is defeq with the Subtype
topology that HermitianMat inherits from the topology on Matrix. This can be done via
`InnerProductSpace.ofCoreOfTopology`.

-/

namespace HermitianMat

variable {R n Œ± : Type*} [Star R] [TrivialStar R] [Fintype n]

variable [Ring Œ±] [StarAddMonoid Œ±] [CommSemiring R] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±] in
/-- The Hermitian inner product, `Tr[AB]`. This is equal to `Matrix.trace (A * B)`, but gives real
  values when the matrices are complex, using `IsMaximalSelfAdjoint`. -/
def inner (A B : HermitianMat n Œ±) : R :=
  IsMaximalSelfAdjoint.selfadjMap ((A.toMat * B.toMat).trace)

section semiring

variable [CommSemiring R] [Ring Œ±] [StarAddMonoid Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±]
variable (A B C : HermitianMat n Œ±)

theorem inner_left_distrib : A.inner (B + C) = A.inner B + A.inner C := by
  simp [inner, left_distrib]

theorem inner_right_distrib : (A + B).inner C = A.inner C + B.inner C := by
  simp [inner, right_distrib]

@[simp]
theorem inner_zero : A.inner 0 = 0 := by
  simp [inner]

@[simp]
theorem zero_inner : HermitianMat.inner 0 A = 0 := by
  simp [inner]

end semiring

section ring

variable [CommRing R] [Ring Œ±] [StarAddMonoid Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±]
variable (A B C : HermitianMat n Œ±)

@[simp]
theorem inner_left_neg : (-A).inner B = -A.inner B := by
  simp [inner]

@[simp]
theorem inner_right_neg : A.inner (-B) = -A.inner B := by
  simp [inner]

theorem inner_left_sub : A.inner (B - C) = A.inner B - A.inner C := by
  simp [inner, mul_sub]

theorem inner_right_sub : (A - B).inner C = A.inner C - B.inner C := by
  simp [inner, sub_mul]

variable [StarModule R Œ±]

@[simp]
theorem smul_inner (r : R) : (r ‚Ä¢ A).inner B = r * A.inner B := by
  simp [inner, IsMaximalSelfAdjoint.selfadj_smul]

@[simp]
theorem inner_smul (r : R) : A.inner (r ‚Ä¢ B) = r * A.inner B := by
  simp [inner, IsMaximalSelfAdjoint.selfadj_smul]

/-- The Hermitian inner product as bilinear form. -/
def inner_BilinForm : LinearMap.BilinForm R (HermitianMat n Œ±) := {
      toFun A := {
        toFun := A.inner
        map_add' := A.inner_left_distrib
        map_smul' r B := inner_smul A B r
      }
      map_add' := by intros; ext1; apply inner_right_distrib
      map_smul' := by intros; ext1; apply smul_inner
    }

@[simp]
theorem inner_BilinForm_coe_apply : ‚áë(inner_BilinForm A) = A.inner :=
  rfl

@[simp]
theorem inner_BilinForm_apply : inner_BilinForm A B = A.inner B :=
  rfl

end ring
section starring

variable [CommSemiring R] [Ring Œ±] [StarRing Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±] [DecidableEq n]
variable (A B : HermitianMat n Œ±)

@[simp]
theorem inner_one : A.inner 1 = A.trace := by
  simp only [inner, selfAdjoint.val_one,  mul_one, trace]

@[simp]
theorem one_inner : HermitianMat.inner 1 A = A.trace := by
  simp only [inner, one_mul, selfAdjoint.val_one, trace]

end starring
section commring

variable [CommSemiring R] [CommRing Œ±] [StarRing Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±]
variable (A B : HermitianMat n Œ±)

/-- The inner product for Hermtian matrices is equal to the trace of the product. -/
theorem inner_eq_trace_mul : algebraMap R Œ± (A.inner B) = (A.toMat * B.toMat).trace := by
  apply IsMaximalSelfAdjoint.selfadj_algebra
  rw [IsSelfAdjoint, Matrix.trace]
  simp_rw [star_sum, Matrix.diag_apply, Matrix.mul_apply, star_sum, star_mul, mul_comm]
  rw [Finset.sum_comm]
  congr! <;> apply congrFun‚ÇÇ (H _)

theorem inner_comm : A.inner B = B.inner A := by
  rw [inner, inner, Matrix.trace_mul_comm]

end commring

section trivialstar
variable [CommRing Œ±] [StarRing Œ±] [TrivialStar Œ±]

/-- `HermitianMat.inner` reduces to `Matrix.trace (A * B)` when the elements are a `TrivialStar`. -/
theorem inner_eq_trace_trivial (A B : HermitianMat n Œ±) : A.inner B = Matrix.trace (A.toMat * B.toMat) := by
  rw [‚Üê inner_eq_trace_mul]
  rfl

end trivialstar

section RCLike
open ComplexOrder
variable {n ùïú : Type*} [Fintype n] [RCLike ùïú] (A B C : HermitianMat n ùïú)

theorem inner_eq_re_trace : A.inner B = RCLike.re (Matrix.trace (A.toMat * B.toMat)) := by
  rfl

theorem inner_eq_trace_rc : A.inner B = Matrix.trace (A.toMat * B.toMat) := by
  change RCLike.ofReal (RCLike.re _) = _
  rw [‚Üê RCLike.conj_eq_iff_re]
  convert (Matrix.trace_conjTranspose (A.toMat * B.toMat)).symm using 1
  rw [Matrix.conjTranspose_mul, A.H, B.H, Matrix.trace_mul_comm]

theorem inner_self_nonneg: 0 ‚â§ A.inner A := by
  simp_rw [inner_eq_re_trace, Matrix.trace, Matrix.diag, Matrix.mul_apply, map_sum]
  refine Finset.sum_nonneg fun i _ ‚Ü¶ Finset.sum_nonneg fun j _ ‚Ü¶ ?_
  rw [‚Üê congrFun‚ÇÇ A.H, Matrix.conjTranspose_apply]
  refine And.left <| RCLike.nonneg_iff.mp ?_
  open ComplexOrder in
  exact star_mul_self_nonneg (A.toMat j i)

variable {A B C}

theorem inner_mul_nonneg (h : 0 ‚â§ A.toMat * B.toMat) : 0 ‚â§ A.inner B := by
  rw [Matrix.PosSemidef.zero_le_iff_posSemidef] at h
  exact (RCLike.nonneg_iff.mp h.trace_nonneg).left

/-- The inner product for PSD matrices is nonnegative. -/
theorem inner_ge_zero (hA : 0 ‚â§ A) (hB : 0 ‚â§ B) : 0 ‚â§ A.inner B := by
  rw [zero_le_iff] at hA hB
  open Classical in
  rw [inner_eq_re_trace, ‚Üê hA.sqrt_mul_self, Matrix.trace_mul_cycle, Matrix.trace_mul_cycle]
  nth_rewrite 1 [‚Üê hA.posSemidef_sqrt.left]
  exact (RCLike.nonneg_iff.mp (hB.conjTranspose_mul_mul_same _).trace_nonneg).left

theorem inner_mono (hA : 0 ‚â§ A) : B ‚â§ C ‚Üí A.inner B ‚â§ A.inner C := fun hBC ‚Ü¶ by
  classical have hTr : 0 ‚â§ A.inner (C - B) := inner_ge_zero hA (zero_le_iff.mpr hBC)
  rw [inner_left_sub] at hTr
  linarith

theorem inner_mono' (hA : 0 ‚â§ A) : B ‚â§ C ‚Üí B.inner A ‚â§ C.inner A := fun hBC ‚Ü¶ by
  rw [inner_comm B A, inner_comm C A]
  exact inner_mono hA hBC

/-- The inner product for PSD matrices is at most the product of their traces. -/
theorem inner_le_mul_trace (hA : 0 ‚â§ A) (hB : 0 ‚â§ B) : A.inner B ‚â§ A.trace * B.trace := by
  classical convert inner_mono hA (le_trace_smul_one hB)
  simp [mul_comm]

--TODO cleanup
private theorem inner_zero_iff_aux_lemma [DecidableEq n] (hA‚ÇÅ : A.val.PosSemidef) (hB‚ÇÅ : B.val.PosSemidef) :
  RCLike.re (A.val * B.val).trace = 0 ‚Üî
    LinearMap.range (Matrix.toEuclideanLin A.val) ‚â§
      LinearMap.ker (Matrix.toEuclideanLin B.val) := by
  --Thanks Aristotle
  have h_trace_zero : (RCLike.re ((A.val * B.val).trace)) = 0 ‚Üî (A.val * B.val) = 0 := by
    -- Since $A$ and $B$ are positive semidefinite, we can write them as $A = C^* C$ and $B = D^* D$ for some matrices $C$ and $D$.
    obtain ‚ü®C, hC‚ü© : ‚àÉ C : Matrix n n ùïú, A.val = C.conjTranspose * C := by
      exact Matrix.posSemidef_iff_eq_conjTranspose_mul_self.mp hA‚ÇÅ
    obtain ‚ü®D, hD‚ü© : ‚àÉ D : Matrix n n ùïú, B.val = D.conjTranspose * D := by
      exact Matrix.posSemidef_iff_eq_conjTranspose_mul_self.mp hB‚ÇÅ
    have h_trace_zero_iff : (RCLike.re ((A.val * B.val).trace)) = 0 ‚Üî (D * C.conjTranspose) = 0 := by
      -- Since $\operatorname{Tr}((DC)^* DC) = \sum_{i,j} |(DC)_{ij}|^2$, and this sum is zero if and only if each term is zero, we have $\operatorname{Tr}((DC)^* DC) = 0$ if and only if $DC = 0$.
      have h_trace_zero_iff : (RCLike.re ((D * C.conjTranspose).conjTranspose * (D * C.conjTranspose)).trace) = 0 ‚Üî (D * C.conjTranspose) = 0 := by
        have h_trace_zero_iff : ‚àÄ (M : Matrix n n ùïú), (RCLike.re (M.conjTranspose * M).trace) = 0 ‚Üî M = 0 := by
          simp [ Matrix.trace, Matrix.mul_apply ];
          intro M
          simp_all only
          obtain ‚ü®val, property‚ü© := A
          obtain ‚ü®val_1, property_1‚ü© := B
          subst hD hC
          apply Iff.intro
          ¬∑ intro a
            rw [ Finset.sum_eq_zero_iff_of_nonneg fun i _ => Finset.sum_nonneg fun j _ => add_nonneg ( mul_self_nonneg _ ) ( mul_self_nonneg _ )] at a
            ext i j
            specialize a j
            rw [ Finset.sum_eq_zero_iff_of_nonneg fun _ _ => add_nonneg ( mul_self_nonneg _ ) ( mul_self_nonneg _ ) ] at a
            simp_all only [Finset.mem_univ, forall_const, Matrix.zero_apply]
            exact RCLike.ext ( by norm_num; nlinarith only [ a i ] ) ( by norm_num; nlinarith only [ a i ] );
          ¬∑ intro a
            subst a
            simp_all only [Matrix.zero_apply, map_zero, mul_zero, add_zero, Finset.sum_const_zero]
        exact h_trace_zero_iff _;
      convert h_trace_zero_iff using 3 ; simp [ hC, hD, Matrix.mul_assoc ];
      rw [ ‚Üê Matrix.trace_mul_comm ] ; simp [ Matrix.mul_assoc ];
    simp_all only
    obtain ‚ü®val, property‚ü© := A
    obtain ‚ü®val_1, property_1‚ü© := B
    subst hD hC
    apply Iff.intro
    ¬∑ intro a
      simp_all only [iff_true]
      simp ( config := { decide := Bool.true } ) [ ‚Üê Matrix.mul_assoc, ‚Üê Matrix.conjTranspose_inj, a ];
    ¬∑ intro a
      simp_all only [Matrix.trace_zero, map_zero, true_iff]
  have h_range_ker : (LinearMap.range (Matrix.toEuclideanLin A.val)) ‚â§ (LinearMap.ker (Matrix.toEuclideanLin B.val)) ‚Üí (A.val * B.val) = 0 := by
    intro h_range_ker
    have hAB_zero : ‚àÄ v, (Matrix.toEuclideanLin B.val) ((Matrix.toEuclideanLin A.val) v) = 0 := by
      exact fun v => h_range_ker ( LinearMap.mem_range_self _ v )
    have h_herm : A.val * B.val = (B.val * A.val).conjTranspose := by
      simp [Matrix.conjTranspose_mul]
    have hBA_zero : (B.val * A.val) = 0 := by
      ext i j
      specialize hAB_zero (Pi.single j 1)
      convert congr_fun hAB_zero i using 1
      simp [Matrix.toEuclideanLin, dotProduct, Matrix.mulVec, Matrix.mul_apply, Pi.single_apply]
    rw [h_herm, hBA_zero, Matrix.conjTranspose_zero]
  simp_all only
  obtain ‚ü®val, property‚ü© := A
  obtain ‚ü®val_1, property_1‚ü© := B
  simp_all only
  apply Iff.intro
  ¬∑ rintro a _ ‚ü®y, rfl‚ü©
    have h_comm : val_1 * val = 0 := by
      rw [‚Üê Matrix.conjTranspose_inj]
      have h_conj_transpose : val.conjTranspose = val ‚àß val_1.conjTranspose = val_1 := by
        aesop
      simp [h_conj_transpose, Matrix.conjTranspose_mul, a]
    simp only [LinearMap.mem_ker]
    convert congr_arg (fun x => Matrix.mulVec x y) h_comm using 1
    ¬∑ simp [Matrix.toEuclideanLin_apply, Matrix.mulVec_mulVec]
      rfl
    ¬∑ simp
  ¬∑ grind

/-- The inner product of two PSD matrices is zero iff they have disjoint support, i.e., each lives entirely
in the other's kernel. -/
theorem inner_zero_iff [DecidableEq n] (hA‚ÇÅ : 0 ‚â§ A) (hB‚ÇÅ : 0 ‚â§ B)
    : A.inner B = 0 ‚Üî A.support ‚â§ B.ker := by
  rw [zero_le_iff] at hA‚ÇÅ hB‚ÇÅ
  dsimp [support, ker, lin]
  rw [inner_eq_re_trace]
  change selfAdjoint (Matrix n n ùïú) at A B
  exact inner_zero_iff_aux_lemma hA‚ÇÅ hB‚ÇÅ

variable {d d‚ÇÇ : Type*} (A B : HermitianMat d ùïú) [Fintype d‚ÇÇ] [Fintype d]

@[simp]
theorem reindex_inner (e : d ‚âÉ d‚ÇÇ) (B : HermitianMat d‚ÇÇ ùïú) :
    (A.reindex e).inner B = A.inner (B.reindex e.symm) := by
  dsimp [inner]
  congr
  rw (occs := [3,4]) [‚Üê e.symm_symm]
  rw [‚Üê Matrix.submatrix_id_mul_right]
  rw (occs := [2]) [Matrix.trace_mul_comm]
  rw [Matrix.submatrix_id_mul_right, Matrix.trace_mul_comm, Equiv.symm_symm]

end RCLike

section topology
/-!
Theorems about `HermitianMat`s that have to do with the topological structure. Pretty much everything here will
assume these are matrices over ‚ÑÇ, but changes to upgrade this to other types are welcome.
-/
open ComplexOrder

variable {d : Type*} [Fintype d] {ùïú : Type*} [RCLike ùïú]

--Using `#guard_msgs(drop info) in #synth` to check that certain instances already exist here

#guard_msgs(drop info) in
#synth ContinuousAdd (HermitianMat d ‚ÑÇ)

instance : ContinuousSMul ‚Ñù (HermitianMat d ùïú) where
  continuous_smul := by
    rw [continuous_induced_rng]
    exact continuous_smul.comp <| continuous_fst.prodMk (by fun_prop)

#guard_msgs(drop info) in
#synth ContractibleSpace (HermitianMat d ‚ÑÇ)

@[fun_prop] --fun_prop can actually prove this, should I leave this on or not?
theorem inner_bilinForm_Continuous (A : HermitianMat d ùïú) : Continuous ‚áë(HermitianMat.inner_BilinForm A) :=
  LinearMap.continuous_of_finiteDimensional _

@[fun_prop]
theorem inner_continuous : Continuous ((HermitianMat.inner (n := d) (Œ± := ùïú)).uncurry) := by
  rw [funext‚ÇÇ inner_eq_re_trace]
  fun_prop

end topology

section innerproductspace

variable {d d‚ÇÇ : Type*} [Fintype d] [Fintype d‚ÇÇ] {ùïú : Type*} [RCLike ùïú]

/-- We define the Hermitian inner product as our "canonical" inner product, which does induce a norm.
This disagrees slightly with Mathlib convention on the `Matrix` type, which avoids asserting one norm
as there are several reasonable ones; for Hermitian matrices, though, this seem to be the right choice. -/
noncomputable def InnerProductCore : InnerProductSpace.Core ‚Ñù (HermitianMat d ùïú) :=
   {
    inner A B := A.inner B
    conj_inner_symm := fun x y ‚Ü¶ by
      simpa using inner_comm y x
    re_inner_nonneg := inner_self_nonneg
    add_left := by simp [inner, add_mul]
    smul_left x y r := by simp
    definite x h := by
      replace h : ‚àë j, ‚àë i, (RCLike.re (x i j) ^ 2 + RCLike.im (x i j) ^ 2) = 0 := by
        convert h
        simp only [inner_eq_re_trace, Matrix.trace, Matrix.diag_apply, Matrix.mul_apply, map_sum,
          RCLike.mul_re, sub_eq_add_neg]
        congr! 2 with i _ j
        simp [‚Üê congrFun‚ÇÇ x.H i j, pow_two]
        rfl
      ext i j
      rw [Fintype.sum_eq_zero_iff_of_nonneg (fun i ‚Ü¶ by positivity)] at h
      replace h := congrFun h j
      rw [Pi.zero_apply, Fintype.sum_eq_zero_iff_of_nonneg (fun i ‚Ü¶ by positivity)] at h
      replace h := congrFun h i
      rw [Pi.zero_apply] at h
      rw [add_eq_zero_iff_of_nonneg (by positivity) (by positivity), sq_eq_zero_iff, sq_eq_zero_iff] at h
      apply RCLike.ext (h.left.trans RCLike.zero_re.symm) (h.right.trans (map_zero _).symm)
  }

/-
It *should* be easier than this to construct the resulting `InnerProductSpace`. But there's a rub!

An InnerProductSpace gives a natural topology, uniformity, and bornology (all of which carry data);
but `HermitianMat` already inherits a topology and uniformity from `Matrix` and `Subtype`. (Thankfully,
not a Bornology, although that could change in the future as Mathlib develops.) This can lead to
issues where many theorems (or other types, like `CompleteSpace`) expect the uniformity structure
to be defeq to the one coming from the `InnerProductSpace`.

This is why constructors like `InnerProductSpace.ofCoreOfTopology` exist, which let you override the
topology when you create it. You need to give a proof that it's propositionally equivalent, which
is what the `topo_compat_1` / `2` / `uniformity_compat` theorems do.

But there's a second issue. There a function for overriding the uniformity, or the bornology, or
"all" of them ... which, oddly, means just the uniformity + bornology. Probably a relic of how it
developed, and topology overrides were added later. This means we can't override the topology
_and_ the uniformity, even though we need both.

Eventually this should be fixed in Mathlib. But for now, it means we have to recreate the `ofCore`
somewhat, adding in the overrides to the construction manually. This is why
`instNormedGroup`, `instNormedSpace`, and `instInnerProductSpace` are so long and messy, and each
repeats some proof from Mathlib.
-/

private theorem topo_compat_1 :
    letI : Inner ‚Ñù (HermitianMat d ùïú) := InnerProductCore.toInner;
    ContinuousAt (fun v : HermitianMat d ùïú ‚Ü¶ Inner.inner ‚Ñù v v) 0 := by
  change ContinuousAt (fun v ‚Ü¶ HermitianMat.inner v v) 0
  fun_prop

private theorem topo_compat_2_aux {d ùïú : Type*} [Fintype d] [RCLike ùïú]
  (x : Set ‚Ü•(selfAdjoint (Matrix d d ùïú))) (h : x ‚àà nhds 0) :
  ‚àÉ a, ‚àÄ (b : ‚Ñù), a ‚â§ b ‚Üí
    {v : (selfAdjoint (Matrix d d ùïú)) | RCLike.re (v.val * v.val).trace < 1} ‚äÜ (open Pointwise in b ‚Ä¢ x) := by
  --Thanks Aristotle
  rw [ mem_nhds_iff ] at h;
  cases' h with t ht;
  -- Since $t$ is open and contains $0$, there exists an $\epsilon > 0$ such that the ball of radius $\epsilon$ around $0$ is contained in $t$.
  obtain ‚ü®Œµ, hŒµ‚ü© : ‚àÉ Œµ > 0, ‚àÄ v : selfAdjoint (Matrix d d ùïú), (RCLike.re (Matrix.trace (v.val * v.val))) < Œµ ‚Üí v ‚àà t := by
    have := ht.2.1.mem_nhds ht.2.2;
    rw [ mem_nhds_iff ] at this;
    obtain ‚ü® U, hU‚ÇÅ, hU‚ÇÇ, hU‚ÇÉ ‚ü© := this;
    rw [ isOpen_induced_iff ] at hU‚ÇÇ;
    simp_all only [gt_iff_lt, val_eq_coe, Subtype.forall, mk_toMat]
    obtain ‚ü®left, right‚ü© := ht
    obtain ‚ü®w, h‚ü© := hU‚ÇÇ
    obtain ‚ü®left_1, right‚ü© := right
    obtain ‚ü®left_2, right_1‚ü© := h
    subst right_1
    simp_all only [Set.mem_preimage, val_eq_coe, ZeroMemClass.coe_zero]
    -- Since $w$ is open and contains $0$, there exists an $\epsilon > 0$ such that the ball of radius $\epsilon$ in the Frobenius norm is contained in $w$.
    obtain ‚ü®Œµ, hŒµ‚ü© : ‚àÉ Œµ > 0, ‚àÄ a : Matrix d d ùïú, (‚àë i, ‚àë j, ‚Äña i j‚Äñ ^ 2) < Œµ ‚Üí a ‚àà w := by
      have := left_2.mem_nhds hU‚ÇÉ;
      -- Since $w$ is open and contains $0$, there exists a $\delta > 0$ such that the ball of radius $\delta$ in the Frobenius norm is contained in $w$.
      obtain ‚ü®Œ¥, hŒ¥‚ü© : ‚àÉ Œ¥ > 0, ‚àÄ a : Matrix d d ùïú, (‚àë i, ‚àë j, ‚Äña i j‚Äñ ^ 2) < Œ¥ ^ 2 ‚Üí a ‚àà w := by
        rw [ mem_nhds_iff ] at this;
        obtain ‚ü® t, ht‚ÇÅ, ht‚ÇÇ, ht‚ÇÉ ‚ü© := this;
        rw [ isOpen_pi_iff ] at ht‚ÇÇ;
        obtain ‚ü® I, u, hu‚ÇÅ, hu‚ÇÇ ‚ü© := ht‚ÇÇ 0 ht‚ÇÉ;
        -- Since $u$ is a neighborhood of $0$ in the product topology, there exists a $\delta > 0$ such that the ball of radius $\delta$ in the product topology is contained in $u$.
        obtain ‚ü®Œ¥, hŒ¥‚ü© : ‚àÉ Œ¥ > 0, ‚àÄ a : d ‚Üí d ‚Üí ùïú, (‚àÄ i ‚àà I, ‚àÄ j, ‚Äña i j‚Äñ < Œ¥) ‚Üí a ‚àà (I : Set d).pi u := by
          have hŒ¥ : ‚àÄ i ‚àà I, ‚àÉ Œ¥_i > 0, ‚àÄ a : d ‚Üí ùïú, (‚àÄ j, ‚Äña j‚Äñ < Œ¥_i) ‚Üí a ‚àà u i := by
            intro i hi;
            have := hu‚ÇÅ i hi;
            rcases Metric.isOpen_iff.1 this.1 ( 0 : d ‚Üí ùïú ) this.2 with ‚ü® Œ¥, Œ¥pos, hŒ¥ ‚ü©;
            -- Since the ball of radius Œ¥ in the product topology is contained in u i, we can take Œ¥_i = Œ¥.
            use Œ¥, Œ¥pos;
            intro a ha;
            -- Since $a$ is such that for all $j$, $\|a j\| < \delta$, we have $a \in \text{ball}(0, \delta)$.
            have ha_ball : a ‚àà Metric.ball (0 : d ‚Üí ùïú) Œ¥ := by
              simp ( config := { decide := Bool.true } ) [ Metric.mem_ball, dist_eq_norm ];
              exact (pi_norm_lt_iff Œ¥pos).mpr ha;
            exact hŒ¥ ha_ball;
          choose! Œ¥ hŒ¥‚ÇÅ hŒ¥‚ÇÇ using hŒ¥;
          -- Since $I$ is finite, we can take the minimum of the $\delta_i$'s.
          obtain ‚ü®Œ¥_min, hŒ¥_min‚ü© : ‚àÉ Œ¥_min > 0, ‚àÄ i ‚àà I, Œ¥_min ‚â§ Œ¥ i := by
            by_cases hI : I.Nonempty;
            ¬∑ exact ‚ü® Finset.min' ( I.image Œ¥ ) ‚ü® _, Finset.mem_image_of_mem Œ¥ hI.choose_spec ‚ü©, by have := Finset.min'_mem ( I.image Œ¥ ) ‚ü® _, Finset.mem_image_of_mem Œ¥ hI.choose_spec ‚ü© ; aesop, fun i hi => Finset.min'_le _ _ ( Finset.mem_image_of_mem Œ¥ hi ) ‚ü©;
            ¬∑ exact ‚ü® 1, zero_lt_one, fun i hi => False.elim <| hI ‚ü® i, hi ‚ü© ‚ü©;
          -- Since Œ¥_min is positive and for each i in I, Œ¥_min ‚â§ Œ¥ i, we can use Œ¥_min as our Œ¥.
          use Œ¥_min;
          exact ‚ü® hŒ¥_min.1, fun a ha => fun i hi => hŒ¥‚ÇÇ i hi ( fun j => a i j ) fun j => lt_of_lt_of_le ( ha i hi j ) ( hŒ¥_min.2 i hi ) ‚ü©;
        refine' ‚ü® Œ¥ / ( Finset.card I + 1 ), div_pos hŒ¥.1 ( Nat.cast_add_one_pos _ ), fun a ha => ht‚ÇÅ ( hu‚ÇÇ ( hŒ¥.2 a fun i hi j => _ ) ) ‚ü©;
        contrapose! ha;
        refine' le_trans _ ( Finset.single_le_sum ( fun i _ => Finset.sum_nonneg fun j _ => _root_.sq_nonneg ( ‚Äña i j‚Äñ ) ) ( Finset.mem_univ i ) |> le_trans ( Finset.single_le_sum ( fun j _ => _root_.sq_nonneg ( ‚Äña i j‚Äñ ) ) ( Finset.mem_univ j ) ) );
        exact pow_le_pow_left‚ÇÄ ( div_nonneg hŒ¥.1.le ( by positivity ) ) ( le_trans ( div_le_self hŒ¥.1.le ( by linarith ) ) ha ) _;
      exact ‚ü® Œ¥ ^ 2, sq_pos_of_pos hŒ¥.1, hŒ¥.2 ‚ü©;
    refine' ‚ü® Œµ, hŒµ.1, fun a ha ha' => hU‚ÇÅ <| hŒµ.2 a _ ‚ü©;
    -- Since $a$ is self-adjoint, the trace of $a^2$ is equal to the sum of the squares of its entries.
    have h_trace_sq : Matrix.trace (a * a) = ‚àë i, ‚àë j, ‚Äña i j‚Äñ ^ 2 := by
      simp [ Matrix.trace, Matrix.mul_apply, sq ];
      -- Since $a$ is self-adjoint, we have $a j x = \overline{a x j}$.
      have h_self_adjoint : ‚àÄ x j, a j x = starRingEnd ùïú (a x j) := by
        -- Since $a$ is self-adjoint, we have $a = a^*$, which implies $a j x = \overline{a x j}$ for all $x$ and $j$.
        have h_self_adjoint : a = star a := by
          exact ha.symm;
        exact fun x j => congr_fun ( congr_fun h_self_adjoint j ) x;
      -- Since $a$ is self-adjoint, we have $a j x = \overline{a x j}$, so $a x j * a j x = a x j * \overline{a x j} = \|a x j\|^2$.
      have h_self_adjoint : ‚àÄ x j, a x j * a j x = ‚Äña x j‚Äñ ^ 2 := by
        intro x j; rw [ h_self_adjoint x j ] ; simp [ sq ] ;
        simp[ ‚Üê sq, RCLike.mul_conj ];
      exact Finset.sum_congr rfl fun i hi => Finset.sum_congr rfl fun j hj => by rw [ h_self_adjoint i j, sq ] ;
    simp_all only [Matrix.zero_apply, norm_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true, zero_pow,
      Finset.sum_const_zero, gt_iff_lt, map_sum, map_pow]
    convert ha' using 1;
    norm_cast;
  use 1 / Œµ + 1;
  intro b hb v hv;
  refine' ‚ü® b‚Åª¬π ‚Ä¢ v, _, _ ‚ü© <;> simp_all [ smul_smul ];
  ¬∑ refine' ht.1 ( hŒµ.2 _ _ _ );
    simp [ ‚Üê smul_assoc, RCLike.smul_re ];
    rw [ ‚Üê mul_inv, inv_mul_lt_iff‚ÇÄ ] <;> nlinarith [ inv_pos.2 hŒµ.1, mul_inv_cancel‚ÇÄ hŒµ.1.ne' ];
  ¬∑ rw [ mul_inv_cancel‚ÇÄ ( by linarith [ inv_pos.2 hŒµ.1 ] ), one_smul ]

private theorem topo_compat_2 :
    letI : Inner ‚Ñù (HermitianMat d ùïú) := InnerProductCore.toInner;
    Bornology.IsVonNBounded ‚Ñù {v : HermitianMat d ùïú | RCLike.re (Inner.inner ‚Ñù v v) < 1} := by
  intro x h
  rw [Absorbs]
  simp only [RCLike.re_to_real, Real.cobounded_eq, Filter.eventually_sup, Filter.eventually_atBot,
    Filter.eventually_atTop, ge_iff_le]
  --This is two directions, which is redundant, we only need one
  revert x h
  suffices ‚àÄ (x : Set (HermitianMat d ùïú)), x ‚àà nhds 0 ‚Üí ‚àÉ a, ‚àÄ (b : ‚Ñù), a ‚â§ b ‚Üí {v : HermitianMat d ùïú |
    letI : Inner ‚Ñù (HermitianMat d ùïú) := InnerProductCore.toInner; Inner.inner ‚Ñù v v < 1} ‚äÜ
      (open Pointwise in b ‚Ä¢ x) by
    intro x h
    constructor
    ¬∑ specialize this (-x) (neg_mem_nhds_zero _ h)
      rcases this with ‚ü®a, ha‚ü©
      use -a
      intro b hb
      specialize ha (-b) (le_neg_of_le_neg hb)
      simpa using ha
    ¬∑ exact this x h
  intro x h
  unfold HermitianMat at x
  unfold Inner.inner InnerProductCore
  dsimp
  simp_rw [inner_eq_re_trace]
  exact topo_compat_2_aux x h

private theorem uniformity_compat (s : Set (HermitianMat d ùïú √ó HermitianMat d ùïú)) :
  letI : Norm (HermitianMat d ùïú) :=
    InnerProductSpace.Core.toNorm (c := InnerProductCore.toCore);
  (‚àÉ t ‚àà (@UniformSpace.uniformity (Matrix d d ùïú) _), (fun p => (‚Üëp.1, ‚Üëp.2)) ‚Åª¬π' t ‚äÜ s) ‚Üî
    s ‚àà ‚®Ö r, ‚®Ö (_ : 0 < r), Filter.principal {x | ‚Äñx.1 - x.2‚Äñ < r} := by
  sorry

noncomputable instance instNormedGroup : NormedAddCommGroup (HermitianMat d ùïú) :=
  letI : Norm (HermitianMat d ùïú) :=
    InnerProductSpace.Core.toNorm (c := InnerProductCore.toCore);
  letI : PseudoMetricSpace (HermitianMat d ùïú) :=
    ((
      PseudoMetricSpace.ofSeminormedSpaceCore InnerProductCore.toNormedSpaceCore.toCore
    ).replaceTopology
      (InnerProductCore.topology_eq topo_compat_1 topo_compat_2)).replaceUniformity
      (by ext s; exact uniformity_compat s);
  { eq_of_dist_eq_zero := by
      --This proof is from NormedAddCommGroup.ofCore
      intro x y h
      rw [‚Üê sub_eq_zero, ‚Üê InnerProductCore.toNormedSpaceCore.norm_eq_zero_iff]
      exact h }

noncomputable instance instNormedSpace : NormedSpace ‚Ñù (HermitianMat d ùïú) where
  norm_smul_le r x := by
    letI : InnerProductSpace.Core ‚Ñù (HermitianMat d ùïú) := InnerProductCore;
    --This proof is from InnerProductSpace.Core.toNormedSpaceOfTopology
    rw [InnerProductSpace.Core.norm_eq_sqrt_re_inner, InnerProductSpace.Core.inner_smul_left,
      InnerProductSpace.Core.inner_smul_right, ‚Üê mul_assoc]
    rw [RCLike.conj_mul, ‚Üê RCLike.ofReal_pow, RCLike.re_ofReal_mul, Real.sqrt_mul,
      ‚Üê InnerProductSpace.Core.ofReal_normSq_eq_inner_self, RCLike.ofReal_re]
    ¬∑ simp [-Real.norm_eq_abs, InnerProductSpace.Core.sqrt_normSq_eq_norm]
    ¬∑ positivity

noncomputable instance instInnerProductSpace : InnerProductSpace ‚Ñù (HermitianMat d ùïú) :=
   letI : Inner ‚Ñù (HermitianMat d ùïú) := InnerProductCore.toInner;
   letI : NormedSpace ‚Ñù (HermitianMat d ùïú) := instNormedSpace;
  { InnerProductCore with
    norm_sq_eq_re_inner := fun x => by
      --This proof is from InnerProductSpace.ofCoreOfTopology
      have h‚ÇÅ : ‚Äñx‚Äñ ^ 2 = ‚àö(RCLike.re (InnerProductCore.inner x x)) ^ 2 := rfl
      have h‚ÇÇ : 0 ‚â§ RCLike.re (InnerProductCore.inner x x) :=
        (letI : InnerProductSpace.Core ‚Ñù (HermitianMat d ùïú) := InnerProductCore;
        InnerProductSpace.Core.inner_self_nonneg)
      rwa [h‚ÇÅ, Real.sq_sqrt] }

open scoped RealInnerProductSpace

instance : CompleteSpace (HermitianMat d ùïú) :=
  inferInstance

--Shortcut instances
noncomputable instance : NormedAddCommGroup (HermitianMat d ‚Ñù) :=
  inferInstance

noncomputable instance : NormedAddCommGroup (HermitianMat d ‚ÑÇ) :=
  inferInstance

open ComplexOrder in
def _root_.RCLike.instOrderClosed : OrderClosedTopology ùïú where
  isClosed_le' := by
    conv => enter [1, 1, p]; rw [RCLike.le_iff_re_im]
    simp_rw [Set.setOf_and]
    refine IsClosed.inter (isClosed_le ?_ ?_) (isClosed_eq ?_ ?_) <;> continuity

scoped[ComplexOrder] attribute [instance] RCLike.instOrderClosed

variable (A B : HermitianMat d ùïú)

--TODO: Eventually deprecated HermitianMat.inner and switch to this primed version everywhere.
/-- The inner product for PSD matrices is nonnegative. -/
theorem inner_ge_zero' (hA : 0 ‚â§ A) (hB : 0 ‚â§ B) : 0 ‚â§ ‚ü™A, B‚ü´ :=
  inner_ge_zero hA hB

variable {A B} in
theorem dist_le_of_mem_Icc (x : HermitianMat d ùïú) (hA : A ‚â§ x) (hB : x ‚â§ B) :
    ‚Äñx - A‚Äñ ‚â§ ‚ÄñB - A‚Äñ := by
  classical
  conv => enter [2, 1]; equals (B - x) + (x - A) => abel
  rw [‚Üê sq_le_sq‚ÇÄ (norm_nonneg _) (norm_nonneg _)]
  rw [norm_add_pow_two_real, le_add_iff_nonneg_left]
  suffices 0 ‚â§ ‚ü™B - x, x - A‚ü´ by positivity
  apply inner_ge_zero' <;> rwa [sub_nonneg]

omit [Fintype n] in
theorem Matrix.IsHermitian_isClosed : IsClosed { A : Matrix n n ùïú | A.IsHermitian } := by
  conv =>
    enter [1, 1, A]
    rw [Matrix.IsHermitian, ‚Üê sub_eq_zero]
  convert isClosed_singleton.preimage (f := fun (x : Matrix n n ùïú) ‚Ü¶ (x.conjTranspose - x))
    (by fun_prop) using 1

open ComplexOrder

theorem Matrix.PosSemiDef_isClosed : IsClosed { A : Matrix n n ùïú | A.PosSemidef } := by
  refine IsHermitian_isClosed.inter ?_
  suffices IsClosed (‚ãÇ x : n ‚Üí ùïú, { A : Matrix n n ùïú | 0 ‚â§ star x ‚¨ù·µ• A.mulVec x }) by
    rwa [‚Üê Set.setOf_forall] at this
  exact isClosed_iInter fun _ ‚Ü¶ (isClosed_Ici (a := 0)).preimage (by fun_prop)

theorem isClosed_nonneg : IsClosed { A : HermitianMat n ùïú | 0 ‚â§ A } := by
  simp_rw [zero_le_iff]
  exact Matrix.PosSemiDef_isClosed.preimage_val

instance : OrderClosedTopology (HermitianMat d ùïú) where
  isClosed_le' := by
    classical
    convert IsClosed.preimage (X := (HermitianMat d ùïú √ó HermitianMat d ùïú))
      (f := fun xy ‚Ü¶ (xy.2 - xy.1)) (by fun_prop) isClosed_nonneg
    ext ‚ü®x, y‚ü©
    simp only [Set.mem_setOf_eq, Set.mem_preimage, ‚Üê sub_nonneg (b := x)]

/-- Equivalently: the matrices `X` such that `X - A` is PSD and `B - X` is PSD, form a compact set. -/
instance : CompactIccSpace (HermitianMat d ùïú) where
  isCompact_Icc := by
    intros A B
    apply Metric.isCompact_of_isClosed_isBounded isClosed_Icc
    rw [Metric.isBounded_iff]
    use 2 * ‚ÄñB - A‚Äñ
    rintro x ‚ü®hxA, hxB‚ü© y ‚ü®hyA, hyB‚ü©
    grw [dist_triangle_right (z := A), dist_eq_norm, dist_eq_norm]
    grw [dist_le_of_mem_Icc x hxA hxB, dist_le_of_mem_Icc y hyA hyB]
    rw [two_mul]

/-- The PSD matrices that are `‚â§ 1` are a compact set. More generally, this is true of any closed interval,
but stating that is a bit different because of how numerals are treated. The `0` and `1` here are already
directly matrices, putting in an `(a : ‚Ñù) ‚Ä¢ 1 ‚â§ m ‚àß m ‚â§ (b : ‚Ñù) ‚Ä¢ 1` involves casts. But that theorem should follow
easily from this. More generally `A ‚â§ m ‚àß m ‚â§ B` is compact.
-/
theorem unitInterval_IsCompact [DecidableEq d] :
    IsCompact {m : HermitianMat d ùïú | 0 ‚â§ m ‚àß m ‚â§ 1} :=
  CompactIccSpace.isCompact_Icc

end innerproductspace


================================================================================
FILE: QuantumInfo/ForMathlib/HermitianMat/Log.lean
TYPE: Lean 4
SIZE: 1263 characters
================================================================================

import QuantumInfo.ForMathlib.HermitianMat.CFC

/-! # Properties of the matrix logarithm

In particular, operator concavity of the matrix logarithm.
-/

namespace HermitianMat

variable {n ùïú : Type*} [Fintype n] [DecidableEq n] [RCLike ùïú]

@[simp]
theorem log_zero : (0 : HermitianMat n ùïú).log = 0 := by
  simp [log, cfc]

@[simp]
theorem log_one : (1 : HermitianMat n ùïú).log = 0 := by
  simp [log, cfc]

theorem log_smul (A : HermitianMat n ùïú) (x : ‚Ñù) : (x ‚Ä¢ A).log = Real.log x ‚Ä¢ 1 + A.log := by
  rw [log, log, HermitianMat.ext_iff]
  simp only [selfAdjoint.val_smul, val_eq_coe, AddSubgroup.coe_add, selfAdjoint.val_one]
  --#25194 landed in Mathlib but we still have an extra `NormedRing` hypothesis there that we don't really want
  --also I think this theorem needs a hypothesis about `A` being posdef, otherwise 0 is in its spectrum and
  --this isn't true

  --convert CFC.log_smul (r := x) (a := a.toMat) sorry sorry sorry
  --rw [Algebra.algebraMap_eq_smul_one]
  sorry

open ComplexOrder in
/-- The matrix logarithm is operator concave. -/
theorem log_concave {x y : HermitianMat n ùïú} (hx : x.toMat.PosDef) (hy : y.toMat.PosDef)
    ‚¶Éa b : ‚Ñù‚¶Ñ (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) (hab : a + b = 1) :
    (a ‚Ä¢ x + b ‚Ä¢ y).log ‚â§ a ‚Ä¢ x.log + b ‚Ä¢ y.log := by
  sorry


================================================================================
FILE: QuantumInfo/ForMathlib/HermitianMat/Order.lean
TYPE: Lean 4
SIZE: 2222 characters
================================================================================

import QuantumInfo.ForMathlib.HermitianMat.Trace

namespace HermitianMat

open ComplexOrder

variable {Œ± : Type*} [RCLike Œ±]
variable {n : Type*} [Fintype n]
variable  {A B C : HermitianMat n Œ±} {M N : Matrix n n Œ±}

theorem le_iff : A ‚â§ B ‚Üî (B - A).toMat.PosSemidef := by
  rfl

theorem zero_le_iff : 0 ‚â§ A ‚Üî A.toMat.PosSemidef := by
  rw [‚Üê propext_iff]
  apply congrArg Matrix.PosSemidef (sub_zero _)

instance [DecidableEq n] : ZeroLEOneClass (HermitianMat n ‚ÑÇ) where
  zero_le_one := by
    rw [HermitianMat.zero_le_iff]
    exact Matrix.PosSemidef.one

theorem lt_iff_posdef : A < B ‚Üî (B - A).toMat.PosSemidef ‚àß A ‚â† B :=
  lt_iff_le_and_ne

instance : OrderedSMul ‚Ñù (HermitianMat n Œ±) where
  smul_lt_smul_of_pos hab hc := by
    rw [HermitianMat.lt_iff_posdef] at hab ‚ä¢
    simp [‚Üê smul_sub, smul_right_inj hc.ne']
    exact ‚ü®hab.left.smul hc.le, hab.right‚ü©
  lt_of_smul_lt_smul_of_pos hab hc := by
    rw [HermitianMat.lt_iff_posdef] at hab ‚ä¢
    convert And.intro (hab.left.smul (inv_pos_of_pos hc).le) hab.right using 1
    ¬∑ simp [‚Üê smul_sub, smul_smul, inv_mul_cancel‚ÇÄ hc.ne']
    ¬∑ simp [smul_right_inj hc.ne']

--Without these shortcut instances, `gcongr` fails to close certain goals...? Why?
instance : PosSMulMono ‚Ñù (HermitianMat n Œ±) := inferInstance
instance : SMulPosMono ‚Ñù (HermitianMat n Œ±) := inferInstance

theorem le_trace_smul_one [DecidableEq n] (hA : 0 ‚â§ A) : A ‚â§ (A.trace : ‚Ñù) ‚Ä¢ 1 := by
  have hA' : A.toMat.PosSemidef := zero_le_iff.mp hA
  refine (Matrix.PosSemidef.le_smul_one_of_eigenvalues_iff hA' A.trace).mp ?_
  rw [‚Üê A.sum_eigenvalues_eq_trace]
  intro i
  exact Finset.single_le_sum (fun j _ ‚Ü¶ hA'.eigenvalues_nonneg j) (Finset.mem_univ i)

theorem conj_le (hA : 0 ‚â§ A) [Fintype m] (M : Matrix m n Œ±) : 0 ‚â§ A.conj M := by
  rw [zero_le_iff] at hA ‚ä¢
  exact Matrix.PosSemidef.mul_mul_conjTranspose_same hA M

theorem convex_cone (hA : 0 ‚â§ A) (hB : 0 ‚â§ B) {c‚ÇÅ c‚ÇÇ : ‚Ñù} (hc‚ÇÅ : 0 ‚â§ c‚ÇÅ) (hc‚ÇÇ : 0 ‚â§ c‚ÇÇ)
    : 0 ‚â§ (c‚ÇÅ ‚Ä¢ A + c‚ÇÇ ‚Ä¢ B) := by
  rw [zero_le_iff] at hA hB ‚ä¢
  exact (hA.smul hc‚ÇÅ).add (hB.smul hc‚ÇÇ)

theorem sq_nonneg [DecidableEq n] : 0 ‚â§ A^2 := by
  simp [zero_le_iff, pow_two]
  nth_rewrite 1 [‚ÜêMatrix.IsHermitian.eq A.H]
  exact Matrix.posSemidef_conjTranspose_mul_self A.toMat


================================================================================
FILE: QuantumInfo/ForMathlib/HermitianMat/Proj.lean
TYPE: Lean 4
SIZE: 8577 characters


[Repository content continues in next chunk]