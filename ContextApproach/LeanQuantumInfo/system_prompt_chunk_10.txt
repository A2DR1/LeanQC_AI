# Lean 4 Code Generation System Prompt (Chunked Version)

You are an expert Lean 4 theorem prover specializing in quantum information theory. Convert natural language prompts into precise Lean 4 code using the Lean-QuantumInfo repository as reference.

## Your Role
Convert natural language descriptions of mathematical concepts, theorems, and proofs into formal Lean 4 code following the exact patterns, definitions, and conventions from the Lean-QuantumInfo repository.

## Key Repository Patterns

### Probability & Distributions
```lean
def Prob := { p : ‚Ñù // 0 ‚â§ p ‚àß p ‚â§ 1 }
def Distribution (Œ± : Type u) [Fintype Œ±] : Type u :=
  { f : Œ± ‚Üí Prob // Finset.sum Finset.univ (fun i ‚Ü¶ (f i : ‚Ñù)) = 1 }
```

### Quantum States
```lean
structure MState (d : Type*) [Fintype d] :=
  m : Matrix d d ‚ÑÇ
  pos : m.PosSemidef
  tr : m.trace = 1

structure Bra (d : ‚Ñï) :=
  vec : Fin d ‚Üí ‚ÑÇ
  normalized' : ‚àë i, ‚Äñvec i‚Äñ^2 = 1
```

### Entropy Functions
```lean
def shannon_entropy (p : Distribution Œ±) : ‚Ñù :=
  -‚àë x, (p.val x).toReal * Real.log (p.val x).toReal

def von_neumann_entropy (œÅ : MState d) : ‚Ñù :=
  -‚àë i, (eigenvalues œÅ.m i).toReal * Real.log (eigenvalues œÅ.m i).toReal
```

## Response Format
1. **Analysis**: Explain the mathematical concept
2. **Lean Code**: Complete implementation with imports
3. **Explanation**: Key components and mathematical meaning
4. **Dependencies**: Required imports and related definitions

## Guidelines
- Use Unicode: `‚Ñù`, `‚Ñï`, `‚ÑÇ`, `‚Üí`, `‚Üî`, `‚àß`, `‚à®`, `‚àÄ`, `‚àÉ`
- Include docstrings: `/-- ... -/`
- Type annotations: `[Fintype Œ±]`, `[DecidableEq Œ±]`
- Use `sorry` for incomplete proofs
- Follow repository naming conventions
- Reference existing definitions when possible

## Repository Content Reference

The following is a portion of the Lean-QuantumInfo repository content. Use this as reference for code generation:

---

==================================================
FILE: QuantumInfo/ForMathlib/HermitianMat/Reindex.lean
TYPE: Lean 4
SIZE: 2787 characters
================================================================================

import QuantumInfo.ForMathlib.HermitianMat.Basic
import QuantumInfo.ForMathlib.ContinuousLinearMap
import QuantumInfo.ForMathlib.LinearEquiv

/-!
Much like `Matrix.reindex` and `Matrix.submatrix`, we can reindex a Hermitian matrix to get another
Hermitian matrix; however, this only makes sense when both permutations are the same, accordingly,
`HermitianMat.reindex` only takes one `Equiv` argument (as opposed to `Matrix.reindex`'s two).

This file then gives relevant lemmas for simplifying this.
-/
namespace HermitianMat

variable {d d‚ÇÇ d‚ÇÉ d‚ÇÑ ùïú : Type*} [RCLike ùïú]

variable (A B : HermitianMat d ùïú) (e : d ‚âÉ d‚ÇÇ)

@[simps]
def reindex (e : d ‚âÉ d‚ÇÇ) : HermitianMat d‚ÇÇ ùïú :=
  ‚ü®A.toMat.reindex e e, A.H.submatrix e.symm‚ü©

/-! Our simp-normal form for expressions involving `HermitianMat.reindex` is that we try to push
the reindexing as far out as possible, so that it can be absorbed by `HermitianMat.trace`, or
cancelled our in a `HermitianMat.inner`. In places where it commutes (like `HermitianMat.inner`)
we push it to the right side. -/

@[simp]
theorem reindex_refl (A : HermitianMat d ‚ÑÇ) :
    A.reindex (.refl _) = A := by
  rfl

@[simp]
theorem reindex_reindex (A : HermitianMat d ‚ÑÇ) (e : d ‚âÉ d‚ÇÇ) (f : d‚ÇÇ ‚âÉ d‚ÇÉ) :
    (A.reindex e).reindex f = A.reindex (e.trans f) := by
  ext1; simp; rfl

@[simp]
theorem reindex_add :
    A.reindex e + B.reindex e = (A + B).reindex e := by
  simp [HermitianMat.ext_iff, Matrix.submatrix_add]

@[simp]
theorem reindex_sub  :
    A.reindex e - B.reindex e = (A - B).reindex e := by
  simp [HermitianMat.ext_iff, Matrix.submatrix_sub]

@[simp]
theorem reindex_conj [Fintype d‚ÇÇ] [Fintype d] (B : Matrix d‚ÇÉ d‚ÇÇ ùïú) :
    (A.reindex e).conj B = A.conj (B.submatrix id e) := by
  ext1
  simp only [conj, reindex_coe, Matrix.reindex_apply, mk_toMat]
  rw [‚Üê Matrix.submatrix_id_mul_right, Matrix.mul_assoc]
  rw [‚Üê Matrix.submatrix_id_mul_left, ‚Üê Matrix.mul_assoc]
  simp

variable [Fintype d]

@[simp]
theorem conj_submatrix (A : HermitianMat d ‚ÑÇ) (B : Matrix d‚ÇÇ d‚ÇÑ ‚ÑÇ)
  (e : d‚ÇÉ ‚âÉ d‚ÇÇ) (f : d ‚Üí d‚ÇÑ) :
    A.conj (B.submatrix e f) = (A.conj (B.submatrix id f)).reindex e.symm := by
  ext1
  simp [conj, ‚Üê Matrix.submatrix_mul_equiv (e‚ÇÇ := .refl d)]

variable [Fintype d‚ÇÇ] [DecidableEq d] [DecidableEq d‚ÇÇ]

theorem ker_reindex :
    (A.reindex e).ker = A.ker.comap (LinearEquiv.euclidean_of_relabel ùïú e) := by
  dsimp only [reindex, ker, lin]
  simp only [ContinuousLinearMap.ker_mk, mk_toMat]
  rw [Matrix.reindex_toEuclideanLin, LinearEquiv.ker_comp, LinearMap.ker_comp]
  rfl

@[simp]
theorem ker_reindex_le_iff :
    (A.reindex e).ker ‚â§ (B.reindex e).ker ‚Üî A.ker ‚â§ B.ker := by
  rw [ker_reindex, ker_reindex]
  apply Submodule.comap_le_comap_iff_of_surjective
  exact LinearEquiv.surjective (LinearEquiv.euclidean_of_relabel ùïú e)

end HermitianMat


================================================================================
FILE: QuantumInfo/ForMathlib/HermitianMat/Trace.lean
TYPE: Lean 4
SIZE: 5455 characters
================================================================================

import QuantumInfo.ForMathlib.HermitianMat.Reindex

/-! # Trace of Hermitian Matrices

While the trace of a Hermitian matrix is, in informal math, typically just "the same as" a trace of
a matrix that happens to be Hermitian - it is a real number, not a complex number. Or more generally,
it is a self-adjoint element of the base `StarAddMonoid`.

Working directly with `Matrix.trace` then means that there would be constant casts between rings,
chasing imaginary parts and inequalities and so on. By defining `HermitianMat.trace` as its own
operation, we encapsulate the mess and give a clean interface.

The `IsMaximalSelfAdjoint` class is used so that (for example) for matrices over ‚Ñ§ or ‚Ñù,
`HermitianMat.trace` works as well and is in fact defeq to `Matrix.trace`. For ‚ÑÇ or `RCLike`,
it uses the real part.
-/

namespace HermitianMat

variable {R n m Œ± : Type*} [Star R] [TrivialStar R] [Fintype n] [Fintype m]

section star
variable [AddGroup Œ±] [StarAddMonoid Œ±] [CommSemiring R] [Semiring Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±]

/-- The trace of the matrix. This requires a `IsMaximalSelfAdjoint R Œ±` instance, and then maps from
  `HermitianMat n Œ±` to `R`. This means that the trace of (say) a `HermitianMat n ‚Ñ§` gives values in ‚Ñ§,
  but that the trace of a `HermitianMat n ‚ÑÇ` gives values in ‚Ñù. The fact that traces are "automatically"
  real reduces coercions down the line. -/
def trace (A : HermitianMat n Œ±) : R :=
  IsMaximalSelfAdjoint.selfadjMap (A.toMat.trace)

/-- `HermitianMat.trace` reduces to `Matrix.trace` in the algebra.-/
theorem trace_eq_trace (A : HermitianMat n Œ±) : algebraMap R Œ± A.trace = Matrix.trace A.toMat := by
  rw [HermitianMat.trace, Matrix.trace, map_sum, map_sum]
  congr! 1
  exact IsMaximalSelfAdjoint.selfadj_algebra (Matrix.IsHermitian.apply A.H _ _)

variable [StarModule R Œ±] in
@[simp]
theorem trace_smul (A : HermitianMat n Œ±) (r : R) : (r ‚Ä¢ A).trace = r * A.trace := by
  simp [trace, IsMaximalSelfAdjoint.selfadj_smul]

end star
section semiring
variable [CommSemiring R] [Ring Œ±] [StarAddMonoid Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±]

@[simp]
theorem trace_zero : (0 : HermitianMat n Œ±).trace = 0 := by
  simp [trace]

@[simp]
theorem trace_add (A B : HermitianMat n Œ±) : (A + B).trace = A.trace + B.trace := by
  simp [trace]

end semiring
section ring

variable [CommRing R] [Ring Œ±] [StarAddMonoid Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±]
@[simp]
theorem trace_neg (A : HermitianMat n Œ±) : (-A).trace = -A.trace := by
  simp [trace]

@[simp]
theorem trace_sub (A B : HermitianMat n Œ±) : (A - B).trace = A.trace - B.trace := by
  simp [trace]

end ring
section starring

variable [CommRing R] [CommRing Œ±] [StarRing Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±]

--PULLOUT
theorem _root_.Matrix.IsHermitian.isSelfAdjoint_trace {A : Matrix n n Œ±} (hA : A.IsHermitian) :
    IsSelfAdjoint A.trace := by
  simp [Matrix.trace, IsSelfAdjoint, ‚Üê Matrix.star_apply, show star A = A from hA]

variable (A : HermitianMat m Œ±) (B : HermitianMat n Œ±)

@[simp]
theorem trace_kronecker [FaithfulSMul R Œ±] : (A ‚äó‚Çñ B).trace = A.trace * B.trace := by
  apply FaithfulSMul.algebraMap_injective R Œ±
  simp only [trace, kronecker_coe]
  rw [Matrix.trace_kronecker A.toMat B.toMat]
  simp only [map_mul]
  have hA := A.H.isSelfAdjoint_trace
  have hB := B.H.isSelfAdjoint_trace
  open IsMaximalSelfAdjoint in
  rw [selfadj_algebra hA, selfadj_algebra hB, selfadj_algebra (hA.mul hB)]

end starring

section trivialstar

variable [Star Œ±] [TrivialStar Œ±] [CommSemiring Œ±]

/-- `HermitianMat.trace` reduces to `Matrix.trace` when the elements are a `TrivialStar`. -/
@[simp]
theorem trace_eq_trace_trivial (A : HermitianMat n ‚Ñù) : A.trace = Matrix.trace A.toMat := by
  rw [‚Üê trace_eq_trace]
  rfl

end trivialstar

section RCLike

variable {n m ùïú : Type*} [Fintype n] [Fintype m] [RCLike ùïú]

--strictly speaking this works over any division ring, not just ‚Ñù + RCLike
instance FiniteDimensional : FiniteDimensional ‚Ñù (HermitianMat n ùïú) :=
  FiniteDimensional.finiteDimensional_submodule (selfAdjoint.submodule ‚Ñù (Matrix n n ùïú))

theorem trace_eq_re_trace (A : HermitianMat n ùïú) : A.trace = RCLike.re A.toMat.trace := by
  rfl

/-- `HermitianMat.trace` reduces to `Matrix.trace` when the elements are `RCLike`. -/
@[simp]
theorem trace_eq_trace_rc (A : HermitianMat n ùïú) : ‚ÜëA.trace = A.toMat.trace := by
  rw [trace, Matrix.trace, map_sum, RCLike.ofReal_sum]
  congr 1
  exact Matrix.IsHermitian.coe_re_diag A.H

theorem trace_diagonal {T : Type*} [Fintype T] [DecidableEq T] (f : T ‚Üí ‚Ñù) :
    (diagonal f).trace = ‚àë i, f i := by
  rw [trace_eq_re_trace]
  simp [HermitianMat.diagonal, Matrix.trace]

theorem sum_eigenvalues_eq_trace [DecidableEq n] (A : HermitianMat n ùïú) :
    ‚àë i, A.H.eigenvalues i = A.trace := by
  convert congrArg RCLike.re A.H.sum_eigenvalues_eq_trace
  rw [RCLike.ofReal_re]

--Proving that traces are 0 or 1 is common enough that we have a convenience lemma here for turning
--statements about HermitianMat traces into Matrix traces.
theorem trace_eq_zero_iff (A : HermitianMat n ùïú) : A.trace = 0 ‚Üî A.toMat.trace = 0 := by
  rw [‚Üê trace_eq_trace_rc]
  use mod_cast id, mod_cast id

theorem trace_eq_one_iff (A : HermitianMat n ùïú) : A.trace = 1 ‚Üî A.toMat.trace = 1 := by
  rw [‚Üê trace_eq_trace_rc]
  use mod_cast id, mod_cast id

@[simp]
theorem trace_reindex (A : HermitianMat n ‚ÑÇ) (e : n ‚âÉ m) :
    (A.reindex e).trace = A.trace := by
  simp [reindex, trace_eq_re_trace]

end RCLike


================================================================================
FILE: QuantumInfo/ForMathlib/HermitianMat.lean
TYPE: Lean 4
SIZE: 389 characters
================================================================================

import QuantumInfo.ForMathlib.HermitianMat.Basic
import QuantumInfo.ForMathlib.HermitianMat.CFC
import QuantumInfo.ForMathlib.HermitianMat.Inner
import QuantumInfo.ForMathlib.HermitianMat.Log
import QuantumInfo.ForMathlib.HermitianMat.Order
import QuantumInfo.ForMathlib.HermitianMat.Proj
import QuantumInfo.ForMathlib.HermitianMat.Reindex
import QuantumInfo.ForMathlib.HermitianMat.Trace


================================================================================
FILE: QuantumInfo/ForMathlib/IsMaximalSelfAdjoint.lean
TYPE: Lean 4
SIZE: 1599 characters
================================================================================

import Mathlib.Analysis.Matrix

/- We want to have `HermitianMat.trace` give ùïú when ùïú is already a TrivialStar field, but give the "clean" type
otherwise -- for instance, ‚Ñù when the input field is ‚ÑÇ. This typeclass lets us do so. -/
class IsMaximalSelfAdjoint (R : outParam Type*) (Œ± : Type*) [Star Œ±] [Star R] [CommSemiring R]
    [Semiring Œ±] [TrivialStar R] [Algebra R Œ±] where
  selfadjMap : Œ± ‚Üí+ R
  selfadj_smul : ‚àÄ (r : R) (a : Œ±), selfadjMap (r ‚Ä¢ a) = r * (selfadjMap a)
  selfadj_algebra : ‚àÄ {a : Œ±}, IsSelfAdjoint a ‚Üí algebraMap _ _ (selfadjMap a) = a

/-- Every `TrivialStar` `CommSemiring` is its own maximal self adjoints. -/
instance instTrivialStar_IsMaximalSelfAdjoint {R} [Star R] [TrivialStar R] [CommSemiring R] : IsMaximalSelfAdjoint R R where
  selfadjMap := AddMonoidHom.id R
  selfadj_smul _ __ := rfl
  selfadj_algebra {_} _ := rfl

/-- ‚Ñù is the maximal self adjoint elements over RCLike -/
instance instRCLike_IsMaximalSelfAdjoint {Œ±} [RCLike Œ±] : IsMaximalSelfAdjoint ‚Ñù Œ± where
  selfadjMap := RCLike.re
  selfadj_smul := RCLike.smul_re
  selfadj_algebra := RCLike.conj_eq_iff_re.mp

namespace IsMaximalSelfAdjoint

-- In particular instances we care about, simplify selfadjMap should it appear.
-- It _seems_ like `selfadjMap 1 = 1`, always, but I can't find a proof. But these lemmas
-- take care of proving that anyway.

@[simp]
theorem trivial_selfadjMap {R} [Star R] [TrivialStar R] [CommSemiring R] : (selfadjMap : R ‚Üí+ R) = .id R := by
  rfl

@[simp]
theorem RCLike_selfadjMap {Œ±} [RCLike Œ±] : (selfadjMap : Œ± ‚Üí+ ‚Ñù) = RCLike.re := by
  rfl

end IsMaximalSelfAdjoint


================================================================================
FILE: QuantumInfo/ForMathlib/Isometry.lean
TYPE: Lean 4
SIZE: 13046 characters
================================================================================

import Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus
import Mathlib.LinearAlgebra.Matrix.Permutation

open scoped Matrix

variable {d d‚ÇÇ d‚ÇÉ R : Type*}
variable [Fintype d] [DecidableEq d] [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ] [Fintype d‚ÇÉ] [DecidableEq d‚ÇÉ]

variable [CommRing R] [StarRing R]

variable {ùïú : Type*} [RCLike ùïú] {A B : Matrix d d ùïú}

/-- An isometry is a matrix `A` such that `AA·¥¥ = 1`. Compare with a unitary, which
requires `AA·¥¥ = A·¥¥A = 1`. It is common to claim that, in a finite-dimensional vector
space, a two-sided isometry (`A.Isometry ‚àß A·¥¥.Isometry`) must be square and therefore unitary;
this is does not work out so well here, since a `Matrix m n R` can be a two-sided isometry,
but cannot be a `unitary` since the rows and columns are index by different labels. -/
def Matrix.Isometry (A : Matrix d d‚ÇÇ R) : Prop :=
  A·¥¥ * A = 1

omit [Fintype d‚ÇÉ] [DecidableEq d‚ÇÇ] in
theorem Matrix.submatrix_one_isometry {e : d‚ÇÇ ‚Üí d} {f : d‚ÇÉ ‚Üí d} (he : e.Bijective) (hf : f.Injective) :
    (submatrix (Œ± := R) 1 e f).Isometry := by
  -- Since $e$ is injective and $f$ is bijective, the submatrix of the identity matrix formed by $e$ and $f$ is a permutation matrix.
  have h_perm : ‚àÄ i j, (Matrix.submatrix (1 : Matrix d d R) e f) i j = if e i = f j then 1 else 0 := by
    -- By definition of the identity matrix, the entry (i, j) in the submatrix is 1 if e i = f j and 0 otherwise.
    simp [Matrix.submatrix, Matrix.one_apply];
  ext i j
  -- Since $e$ is injective and $f$ is bijective, the product $A * A·¥¥$ will have 1s on the diagonal and 0s elsewhere, which is the identity matrix.
  change ‚àë k, (Matrix.conjTranspose (Matrix.submatrix (1 : Matrix d d R) e f)) i k *
    (Matrix.submatrix (1 : Matrix d d R) e f) k j = if i = j then 1 else 0
  simp_all only [Multiset.bijective_iff_map_univ_eq_univ, submatrix_apply, conjTranspose_apply, one_apply]
  symm; split <;> symm
  next h =>
    subst h
    simp_all only [implies_true, mul_ite, ‚ÜìreduceIte, star_one, mul_one, star_zero, mul_zero,
      Finset.sum_boole]
    have h_unique : ‚àÄ i, ‚àÉ! x, e x = f i := by
      intro i
      obtain ‚ü®x, hx‚ü© : ‚àÉ x, e x = f i := by
        replace he := congr_arg Multiset.toFinset he; rw [ Finset.ext_iff ] at he; specialize he ( f i ) ; aesop;
      use x
      simp_all only [true_and]
      intro y a
      have := Fintype.bijective_iff_injective_and_card e
      aesop
    obtain ‚ü® x, hx ‚ü© := h_unique i;
    rw [ show ( Finset.univ.filter fun y => e y = f i ) = { x } from Finset.eq_singleton_iff_unique_mem.2 ‚ü® by aesop, fun y hy => hx.2 y <| Eq.symm <| Finset.mem_filter.1 hy |>.2.symm ‚ü© ] ; simp ( config := { decide := Bool.true } );
  next h => -- Since $e$ is injective and $e i \neq e j$, there is no $x$ such that $e i = f x$ and $e j = f x$.
    have h_no_x : ‚àÄ x : d‚ÇÇ, ¬¨(e x = f i ‚àß e x = f j) := by
      exact fun x hx => h ( hf ( hx.1.symm.trans hx.2 ) );
    exact Finset.sum_eq_zero fun x hx => by specialize h_no_x x; aesop

omit [DecidableEq d‚ÇÇ] in
theorem Matrix.submatrix_one_id_left_isometry {e : d‚ÇÇ ‚Üí d} (he : e.Bijective) :
    (submatrix (1 : Matrix d d R) e id).Isometry :=
  submatrix_one_isometry he Function.injective_id

omit [Fintype d‚ÇÇ] in
theorem Matrix.submatrix_one_id_right_isometry {e : d‚ÇÇ ‚Üí d} (he : e.Injective) :
    (submatrix (1 : Matrix d d R) id e).Isometry :=
  submatrix_one_isometry Function.bijective_id he

theorem Matrix.mem_unitaryGroup_iff_isometry (A : Matrix d d R) :
    A ‚àà unitaryGroup d R ‚Üî A.Isometry ‚àß A·¥¥.Isometry := by
  rw [Isometry, Isometry, conjTranspose_conjTranspose]
  rfl

theorem Equiv.Perm.permMatrix_mem_unitaryGroup (e : Perm d) :
    e.permMatrix R ‚àà Matrix.unitaryGroup d R := by
  -- Since $e$ is a permutation, its permutation matrix $P_e$ is orthogonal, meaning $P_e * P_e^T = I$.
  have h_perm_ortho : (Equiv.Perm.permMatrix R e) * (Equiv.Perm.permMatrix R e)·µÄ = 1 := by
    ext i j; rw [ Matrix.mul_apply ] ; aesop;
  constructor
  ¬∑ simp_all only [Matrix.transpose_permMatrix]
    -- Since the conjugate transpose of a permutation matrix is the permutation matrix of the inverse permutation, we have:
    have h_conj_transpose : star (Equiv.Perm.permMatrix R e) = (Equiv.Perm.permMatrix R e)·µÄ := by
      ext i j; simp ( config := { decide := Bool.true } ) [ Equiv.Perm.permMatrix ] ; aesop;
    simp_all ( config := { decide := Bool.true } ) [ Matrix.mul_eq_one_comm ];
  ¬∑ simp_all only [Matrix.transpose_permMatrix]
    convert h_perm_ortho using 2;
    simp ( config := { decide := Bool.true } ) [ Matrix.star_eq_conjTranspose, Equiv.Perm.permMatrix ]

omit [Fintype d‚ÇÉ] [DecidableEq d‚ÇÇ] in
theorem Matrix.reindex_one_isometry (e : d ‚âÉ d‚ÇÇ) (f : d ‚âÉ d‚ÇÉ) :
    (reindex (Œ± := R) e f 1).Isometry := by
  -- Since $e$ and $f$ are bijections, the reindexing of the identity matrix by $e$ and $f$ is a permutation matrix, which is unitary.
  have h_perm : ‚àÄ (e : d ‚âÉ d‚ÇÇ) (f : d ‚âÉ d‚ÇÉ), (Matrix.reindex e f (1 : Matrix d d R)).Isometry := by
    intro e f
    simp [Matrix.Isometry];
  exact h_perm e f

omit [Fintype d] in
theorem Matrix.reindex_one_mem_unitaryGroup (e : d ‚âÉ d‚ÇÇ)  :
    reindex (Œ± := R) e e 1 ‚àà unitaryGroup d‚ÇÇ R := by
  -- The reindex of the identity matrix under an equivalence e is just the identity matrix on d‚ÇÇ.
  have h_reindex_id : Matrix.reindex e e (1 : Matrix d d R) = 1 := by
    -- By definition of reindex, the entry at (i, j) in the reindexed matrix is 1 if i = j and 0 otherwise.
    ext i j; simp [Matrix.reindex, Matrix.one_apply];
  -- Since the identity matrix is unitary, its conjugate transpose is also the identity matrix.
  simp [h_reindex_id];

omit [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ] [StarRing R] in
theorem Matrix.reindex_eq_conj (A : Matrix d d R) (e : d ‚âÉ d‚ÇÇ) : reindex e e A =
    (reindex (Œ± := R) e (.refl d) 1) * A * (reindex (Œ± := R) (.refl d) e 1) := by
  -- By definition of matrix multiplication and reindexing, we can show that the two matrices are equal.
  ext i j; simp [Matrix.mul_apply, Matrix.reindex];
  -- The inner sum simplifies to $A (e.symm i) x$ because $1 (e.symm i) x$ is $1$ if $x = e.symm i$ and $0$ otherwise.
  simp [Matrix.one_apply]

theorem Matrix.reindex_eq_conj_unitaryGroup' (A : Matrix d d R) (e : Equiv.Perm d) : reindex e e A =
    (‚ü®_, e‚Åª¬π.permMatrix_mem_unitaryGroup‚ü© : unitaryGroup d R) * A * (‚ü®_, e.permMatrix_mem_unitaryGroup‚ü© : unitaryGroup d R) := by
  ext i j;
  simp ( config := { decide := Bool.true } ) [ Matrix.mul_apply ];
  rw [ Finset.sum_eq_single ( e.symm j ) ] <;> aesop

theorem Matrix.IsHermitian.eigenvalue_ext (hA : A.IsHermitian)
  (h : ‚àÄ (v : d ‚Üí ùïú) (lam : ùïú), A *·µ• v = lam ‚Ä¢ v ‚Üí B *·µ• v = lam ‚Ä¢ v) :
    A = B := by
  -- Since A is Hermitian, it is diagonalizable, and its eigenvectors form a complete basis. Therefore, for any vector v, we have Av = Bv.
  have h_diag : ‚àÄ v : d ‚Üí ùïú, (A *·µ• v) = (B *·µ• v) := by
    -- Since A is Hermitian, it is diagonalizable, and its eigenvectors form a complete basis. Therefore, for any vector v, we can express it as a linear combination of eigenvectors.
    have h_diag : ‚àÄ v : d ‚Üí ùïú, ‚àÉ (c : d ‚Üí ùïú) (lam : d ‚Üí ùïú), v = ‚àë i, c i ‚Ä¢ (Matrix.IsHermitian.eigenvectorBasis hA i) ‚àß ‚àÄ i, A *·µ• (Matrix.IsHermitian.eigenvectorBasis hA i) = lam i ‚Ä¢ (Matrix.IsHermitian.eigenvectorBasis hA i) := by
      intro v
      obtain ‚ü®c, hc‚ü© : ‚àÉ c : d ‚Üí ùïú, v = ‚àë i, c i ‚Ä¢ (hA.eigenvectorBasis i) := by
        have h_diag : ‚àÄ v : EuclideanSpace ùïú d, ‚àÉ c : d ‚Üí ùïú, v = ‚àë i, c i ‚Ä¢ (hA.eigenvectorBasis i) := by
          intro v
          set c := fun i => inner‚Çõ‚Çó ùïú (hA.eigenvectorBasis i) v
          have hv : v = ‚àë i, c i ‚Ä¢ (hA.eigenvectorBasis i) := by
            exact Eq.symm (OrthonormalBasis.sum_repr' hA.eigenvectorBasis v)
          use c;
        exact h_diag v;
      refine' ‚ü® c, fun i => ( hA.eigenvalues i ), hc, fun i => _ ‚ü©;
      convert hA.mulVec_eigenvectorBasis i;
      ext; simp ( config := { decide := Bool.true } ) [ ];
      (expose_names; exact Eq.symm (RCLike.real_smul_eq_coe_mul (hA.eigenvalues i) (x i_1)));
    -- By linearity of A and B, we can distribute them over the sum.
    intros v
    obtain ‚ü®c, lam, hv, hlam‚ü© := h_diag v
    have hAv : A *·µ• v = ‚àë i, c i ‚Ä¢ lam i ‚Ä¢ (hA.eigenvectorBasis i) := by
      -- By linearity of matrix multiplication, we can distribute A over the sum.
      have hAv : A *·µ• (‚àë i, c i ‚Ä¢ (hA.eigenvectorBasis i)) = ‚àë i, c i ‚Ä¢ A *·µ• (hA.eigenvectorBasis i) := by
        simp ( config := { decide := Bool.true } ) [ funext_iff ];
        simp ( config := { decide := Bool.true } ) [ Matrix.mulVec, dotProduct, Finset.mul_sum _ _ _ ];
        exact fun _ => Finset.sum_comm.trans ( Finset.sum_congr rfl fun _ _ => Finset.sum_congr rfl fun _ _ => by ring );
      aesop
    have hBv : B *·µ• v = ‚àë i, c i ‚Ä¢ lam i ‚Ä¢ (hA.eigenvectorBasis i) := by
      have hBv : B *·µ• v = ‚àë i, c i ‚Ä¢ (B *·µ• (hA.eigenvectorBasis i)) := by
        -- By linearity of matrix multiplication, we can distribute $B$ over the sum.
        have hBv : B *·µ• v = B *·µ• (‚àë i, c i ‚Ä¢ (hA.eigenvectorBasis i)) := by
          rw [hv];
        simp ( config := { decide := Bool.true } ) [ hBv, funext_iff ];
        simp ( config := { decide := Bool.true } ) [ Matrix.mulVec, dotProduct, Finset.mul_sum _ _ _ ];
        exact fun _ => Finset.sum_comm.trans ( Finset.sum_congr rfl fun _ _ => Finset.sum_congr rfl fun _ _ => by ring );
      exact hBv.trans ( Finset.sum_congr rfl fun i _ => by rw [ h _ _ ( hlam i ) ] )
    rw [hAv, hBv];
  -- By the definition of matrix equality, if $A * v = B * v$ for all $v$, then $A = B$.
  apply Matrix.ext; intro i j; exact (by
  simpa using congr_fun ( h_diag ( Pi.single j 1 ) ) i)

set_option pp.proofs.withType true
/-- Generalizes `Matrix.IsHermitian.cfc.eq_1`, which gives a definition for the matrix CFC in terms of
`Matrix.IsHermitian.eigenvalues` and `Matrix.IsHermitian.eigenvectorUnitary`, to show that the CFC works
similarly for _any_ diagonalization by a two-sided isometry.
-/
theorem Matrix.IsHermitian.cfc_eq_any_isometry {n m ùïú : Type*}
  [RCLike ùïú] [Fintype n] [DecidableEq n] [Fintype m] [DecidableEq m]
  {A : Matrix n n ùïú} (hA : A.IsHermitian) {U : Matrix n m ùïú}
  (hU‚ÇÅ : U * U·¥¥ = 1) (hU‚ÇÇ : U·¥¥ * U = 1) {D : m ‚Üí ‚Ñù}
  (hUD : A = U * diagonal (RCLike.ofReal ‚àò D) * U·¥¥) (f : ‚Ñù ‚Üí ‚Ñù) :
    hA.cfc f = U * diagonal (RCLike.ofReal ‚àò f ‚àò D) * U·¥¥ := by
  sorry

/-- Generalizes `Matrix.IsHermitian.cfc.eq_1`, which gives a definition for the matrix CFC in terms of
`Matrix.IsHermitian.eigenvalues` and `Matrix.IsHermitian.eigenvectorUnitary`, to show that the CFC works
similarly for _any_ diagonalization.
-/
theorem Matrix.IsHermitian.cfc_eq_any_unitary {n ùïú : Type*} [RCLike ùïú] [Fintype n] [DecidableEq n]
  {A : Matrix n n ùïú} (hA : A.IsHermitian) {U : unitaryGroup n ùïú} {D : n ‚Üí ‚Ñù}
  (hUD : A = U.val * diagonal (RCLike.ofReal ‚àò D) * star U.val) (f : ‚Ñù ‚Üí ‚Ñù) :
    hA.cfc f = U.val * diagonal (RCLike.ofReal ‚àò f ‚àò D) * star U.val :=
  Matrix.IsHermitian.cfc_eq_any_isometry hA U.2.2 U.2.1 hUD f

private theorem Matrix.cfc_conj_isometry' (hA : A.IsHermitian) (f : ‚Ñù ‚Üí ‚Ñù) {u : Matrix d‚ÇÇ d ùïú}
  (hu‚ÇÅ : u.Isometry) (hu‚ÇÇ : u·¥¥.Isometry) :
    cfc f (u * A * u·¥¥) = u * (cfc f A) * u·¥¥ := by

  let D := hA.eigenvalues
  let U' := u * hA.eigenvectorUnitary.val
  have := IsHermitian.cfc_eq_any_isometry
    (A := u * A * u·¥¥) (D := D) (n := d‚ÇÇ) (m := d) (U := U') ?_ ?_ ?_ ?_ f; rotate_left
  ¬∑ simpa using isHermitian_conjTranspose_mul_mul u·¥¥ hA
  ¬∑ dsimp [U']
    rw [conjTranspose_mul, Matrix.mul_assoc]
    nth_rw 2 [‚Üê Matrix.mul_assoc]
    rw [show _ * _·¥¥ = 1 from hA.eigenvectorUnitary.2.2, Matrix.one_mul]
    simpa [Isometry] using hu‚ÇÇ
  ¬∑ dsimp [U']
    rw [conjTranspose_mul, Matrix.mul_assoc]
    nth_rw 2 [‚Üê Matrix.mul_assoc]
    rw [hu‚ÇÅ, Matrix.one_mul]
    exact hA.eigenvectorUnitary.2.1
  ¬∑ rw [hA.spectral_theorem]
    simp [U', Matrix.mul_assoc]
    rfl
  rw [Matrix.IsHermitian.cfc_eq, this]
  rw [hA.cfc_eq, Matrix.IsHermitian.cfc.eq_1]
  simp [U', D, Matrix.star_eq_conjTranspose, Matrix.mul_assoc]

theorem Matrix.cfc_conj_isometry (f : ‚Ñù ‚Üí ‚Ñù) {u : Matrix d‚ÇÇ d ùïú}
  (hu‚ÇÅ : u.Isometry) (hu‚ÇÇ : u·¥¥.Isometry) :
    cfc f (u * A * u·¥¥) = u * (cfc f A) * u·¥¥ := by
  by_cases hA : A.IsHermitian
  ¬∑ exact cfc_conj_isometry' hA f hu‚ÇÅ hu‚ÇÇ
  rw [cfc_apply_of_not_predicate, cfc_apply_of_not_predicate]
  ¬∑ simp
  ¬∑ exact hA
  ¬∑ contrapose! hA
    convert isHermitian_conjTranspose_mul_mul u hA
    have hu‚ÇÉ : u·¥¥ * u = 1 := by simpa [Isometry] using hu‚ÇÅ
    simp only [Matrix.mul_assoc, hu‚ÇÉ]
    simp [‚Üê Matrix.mul_assoc, hu‚ÇÉ]

theorem Matrix.cfc_conj_unitary (f : ‚Ñù ‚Üí ‚Ñù) (u : unitaryGroup d ùïú) :
    cfc f (u * A * u‚Åª¬π) = u * (cfc f A) * u‚Åª¬π := by
  have hu := u.prop
  rw [mem_unitaryGroup_iff_isometry] at hu
  exact Matrix.cfc_conj_isometry f hu.left hu.right

theorem Matrix.cfc_reindex (f : ‚Ñù ‚Üí ‚Ñù) (e : d ‚âÉ d‚ÇÇ) :
    cfc f (reindex e e A) = reindex e e (cfc f A) := by
  rw [reindex_eq_conj, reindex_eq_conj]
  convert Matrix.cfc_conj_isometry f (u := (Matrix.reindex e (Equiv.refl d) : Matrix d d ùïú ‚Üí Matrix d‚ÇÇ d ùïú) 1) ?_ ?_
  ¬∑ simp
  ¬∑ simp
  ¬∑ apply reindex_one_isometry
  ¬∑ rw [conjTranspose_reindex, conjTranspose_one]
    apply reindex_one_isometry


================================================================================
FILE: QuantumInfo/ForMathlib/Lieb.lean
TYPE: Lean 4
SIZE: 422 characters
================================================================================

import QuantumInfo.ForMathlib.HermitianMat

/-! Lieb's Inequality .. todo -/

variable {m n : Type*} [Fintype m] [Fintype n] {q r : ‚Ñù}

noncomputable section
open ComplexOrder
open Classical

theorem LiebConcavity (K : Matrix n m ‚ÑÇ) (hq : 0 ‚â§ q) (hr : 0 ‚â§ r) (hqr : q + r ‚â§ 1) :
  let F : (HermitianMat m ‚ÑÇ √ó HermitianMat n ‚ÑÇ) ‚Üí ‚Ñù :=
      fun (x,y) ‚Ü¶ ((x ^ q).conj K).inner (y ^ r);
    ConcaveOn ‚Ñù .univ F := by
  sorry


================================================================================
FILE: QuantumInfo/ForMathlib/LinearEquiv.lean
TYPE: Lean 4
SIZE: 2202 characters
================================================================================

import Mathlib.Analysis.InnerProductSpace.PiL2

variable {d d‚ÇÅ d‚ÇÇ d‚ÇÉ R ùïú : Type*} [RCLike ùïú]

namespace LinearEquiv

variable {R : Type*} [Semiring R]

variable (R) in
@[simps]
def of_relabel (e : d ‚âÉ d‚ÇÇ) : (d‚ÇÇ ‚Üí R) ‚âÉ‚Çó[R] (d ‚Üí R) := by
  refine' { e.symm.piCongrLeft (fun _ ‚Ü¶ R) with .. }
  <;> (intros; ext; simp [Equiv.piCongrLeft_apply])

variable (ùïú) in
@[simps!]
def euclidean_of_relabel (e : d ‚âÉ d‚ÇÇ) : EuclideanSpace ùïú d‚ÇÇ ‚âÉ‚Çó[ùïú] EuclideanSpace ùïú d :=
  of_relabel ùïú e

@[simp]
theorem of_relabel_refl : of_relabel R (.refl d) = LinearEquiv.refl R (d ‚Üí R) := by
  rfl

@[simp]
theorem euclidean_of_relabel_refl : euclidean_of_relabel ùïú (.refl d) =
    LinearEquiv.refl ùïú (EuclideanSpace ùïú d) := by
  rfl

end LinearEquiv

namespace Matrix

variable {R : Type*} [CommSemiring R]
variable [Fintype d] [DecidableEq d]
variable [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ]

theorem reindex_toLin' (e : d‚ÇÅ ‚âÉ d‚ÇÉ) (f : d‚ÇÇ ‚âÉ d) (M : Matrix d‚ÇÅ d‚ÇÇ R) :
    (M.reindex e f).toLin' = (LinearEquiv.of_relabel R e.symm) ‚àò‚Çó
      M.toLin' ‚àò‚Çó (LinearEquiv.of_relabel R f) := by
  ext
  simp [mulVec, dotProduct, Equiv.piCongrLeft_apply]

theorem reindex_toEuclideanLin (e : d‚ÇÅ ‚âÉ d‚ÇÉ) (f : d‚ÇÇ ‚âÉ d) (M : Matrix d‚ÇÅ d‚ÇÇ ùïú) :
    (M.reindex e f).toEuclideanLin = (LinearEquiv.euclidean_of_relabel ùïú e.symm) ‚àò‚Çó
      M.toEuclideanLin ‚àò‚Çó (LinearEquiv.euclidean_of_relabel ùïú f) :=
  reindex_toLin' e f M

theorem reindex_right_toLin' (e : d ‚âÉ d‚ÇÇ) (M : Matrix d‚ÇÉ d R) :
    (M.reindex (.refl d‚ÇÉ) e).toLin' = M.toLin' ‚àò‚Çó (LinearEquiv.of_relabel R e) := by
  rw [reindex_toLin']
  simp

theorem reindex_right_toEuclideanLin (e : d ‚âÉ d‚ÇÇ) (M : Matrix d‚ÇÉ d ùïú) :
    (M.reindex (.refl d‚ÇÉ) e).toEuclideanLin =
      M.toEuclideanLin ‚àò‚Çó (LinearEquiv.euclidean_of_relabel ùïú e) :=
  reindex_right_toLin' e M

theorem reindex_left_toLin' (e : d‚ÇÅ ‚âÉ d‚ÇÉ) (M : Matrix d‚ÇÅ d‚ÇÇ R) :
    (M.reindex e (.refl d‚ÇÇ)).toLin' = (LinearEquiv.of_relabel R e.symm) ‚àò M.toLin' := by
  rw [Matrix.reindex_toLin']
  simp

theorem reindex_left_toEuclideanLin (e : d‚ÇÅ ‚âÉ d‚ÇÉ) (M : Matrix d‚ÇÅ d‚ÇÇ ùïú) :
    (M.reindex e (.refl d‚ÇÇ)).toEuclideanLin =
      (LinearEquiv.euclidean_of_relabel ùïú e.symm) ‚àò M.toEuclideanLin := by
  rw [Matrix.reindex_toEuclideanLin]
  simp

end Matrix


================================================================================
FILE: QuantumInfo/ForMathlib/Matrix.lean
TYPE: Lean 4
SIZE: 38907 characters
================================================================================

import Mathlib.Algebra.Algebra.Spectrum.Quasispectrum
import Mathlib.Analysis.CStarAlgebra.Matrix
import Mathlib.Data.Multiset.Functor --Can't believe I'm having to import this
import Mathlib.LinearAlgebra.Matrix.Kronecker
import Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus
import Mathlib.LinearAlgebra.Matrix.PosDef

import Mathlib.Tactic.Bound

noncomputable section

open BigOperators

variable {n ùïú : Type*}
variable [RCLike ùïú] [DecidableEq n]

namespace Matrix

theorem zero_rank_eq_zero {A : Matrix n n ùïú} [Fintype n] (hA : A.rank = 0) : A = 0 := by
  have h : ‚àÄ v, A.mulVecLin v = 0 := by
    intro v
    rw [rank, Module.finrank_zero_iff] at hA
    have := hA.elim ‚ü®A.mulVecLin v, ‚ü®v, rfl‚ü©‚ü© ‚ü®0, ‚ü®0, by rw [mulVecLin_apply, mulVec_zero]‚ü©‚ü©
    simpa only [Subtype.mk.injEq] using this
  rw [‚Üê LinearEquiv.map_eq_zero_iff toLin']
  exact LinearMap.ext h

namespace IsHermitian

variable {A : Matrix n n ùïú} {B : Matrix n n ùïú}
variable (hA : A.IsHermitian) (hB : B.IsHermitian)

include hA in
omit [DecidableEq n] in
theorem smul_selfAdjoint {c : ùïú} (hc : _root_.IsSelfAdjoint c) : (c ‚Ä¢ A).IsHermitian := by
  exact IsSelfAdjoint.smul hc hA

include hA in
omit [DecidableEq n] in
theorem smul_im_zero {c : ùïú} (h : RCLike.im c = 0) : (c ‚Ä¢ A).IsHermitian :=
  hA.smul_selfAdjoint (RCLike.conj_eq_iff_im.mpr h)

include hA in
omit [DecidableEq n] in
theorem smul_real (c : ‚Ñù) : (c ‚Ä¢ A).IsHermitian := by
  convert hA.smul_im_zero (RCLike.ofReal_im c) using 1
  ext
  simp only [smul_apply, smul_eq_mul, RCLike.real_smul_eq_coe_mul]

def HermitianSubspace (n ùïú : Type*) [Fintype n] [RCLike ùïú] : Subspace ‚Ñù (Matrix n n ùïú) where
  carrier := { A : Matrix n n ùïú | A.IsHermitian }
  add_mem' _ _ := by simp_all only [Set.mem_setOf_eq, IsHermitian.add]
  zero_mem' := by simp only [Set.mem_setOf_eq, isHermitian_zero]
  smul_mem' c A := by
    simp only [Set.mem_setOf_eq]
    intro hA
    exact IsHermitian.smul_real hA c

variable [Fintype n]

include hA in
omit [DecidableEq n] in
@[simp]
theorem re_trace_eq_trace : RCLike.re (A.trace) = A.trace := by
  rw [trace, map_sum, RCLike.ofReal_sum, IsHermitian.coe_re_diag hA]

section eigenvalues

/-- The sum of the eigenvalues of a Hermitian matrix is equal to its trace. -/
theorem sum_eigenvalues_eq_trace : ‚àë i, hA.eigenvalues i = A.trace := by
  nth_rewrite 2 [hA.spectral_theorem]
  rw [trace_mul_comm, ‚Üê mul_assoc]
  simp [trace_diagonal]

/-- If all eigenvalues are equal to zero, then the matrix is zero. -/
theorem eigenvalues_zero_eq_zero (h : ‚àÄ i, hA.eigenvalues i = 0) : A = 0 := by
  suffices A.rank = 0 from zero_rank_eq_zero this
  simp only [hA.rank_eq_card_non_zero_eigs, h, ne_eq, not_true_eq_false, Fintype.card_eq_zero]

end eigenvalues

end IsHermitian

section Kronecker

open Kronecker

variable [CommRing R] [StarRing R]
variable (A : Matrix m m R) (B : Matrix n n R)

omit [DecidableEq n] in
theorem kroneckerMap_conjTranspose : (A ‚äó‚Çñ B)·¥¥ = (A·¥¥ ‚äó‚Çñ B·¥¥) := by
  ext; simp

variable {A : Matrix m m R} {B : Matrix n n R}
variable (hA : A.IsHermitian) (hB : B.IsHermitian)

include hA hB in
omit [DecidableEq n] in
theorem kroneckerMap_IsHermitian : (A ‚äó‚Çñ B).IsHermitian := by
  exact (hA ‚ñ∏ hB ‚ñ∏ kroneckerMap_conjTranspose A B : _ = _)

end Kronecker

namespace PosSemidef

open Kronecker
open scoped ComplexOrder

variable {m n ùïú : Type*}
variable [Fintype m] [Fintype n]
variable [RCLike ùïú] [dn : DecidableEq n]

section
variable {A : Matrix m m ùïú} {B : Matrix m m ùïú}
variable (hA : A.PosSemidef) (hB : B.PosSemidef)

include hA in
theorem diag_nonneg : ‚àÄi, 0 ‚â§ A.diag i := by
  intro i
  classical simpa [mulVec, dotProduct] using hA.2 (fun j ‚Ü¶ if i = j then 1 else 0)

include hA in
theorem trace_zero : A.trace = 0 ‚Üí A = 0 := by
  open Classical in
  intro h
  rw [‚Üê hA.isHermitian.sum_eigenvalues_eq_trace, RCLike.ofReal_eq_zero] at h
  rw [Finset.sum_eq_zero_iff_of_nonneg (fun i _ ‚Ü¶ hA.eigenvalues_nonneg i)] at h
  simp only [Finset.mem_univ, forall_const] at h
  exact hA.isHermitian.eigenvalues_zero_eq_zero h

include hA in
@[simp]
theorem trace_zero_iff : A.trace = 0 ‚Üî A = 0 :=
  ‚ü®trace_zero hA, (by simp [¬∑])‚ü©

--belongs somewhere else. compare with `Complex.normSq_eq_conj_mul_self`.
open ComplexConjugate in
theorem _root_.RCLike.normSq_eq_conj_mul_self {z : ùïú} : RCLike.normSq z = conj z * z := by
  rw [RCLike.ext_iff]
  simp [RCLike.normSq]
  ring_nf

omit dn in
open ComplexConjugate in
theorem outer_self_conj (v : n ‚Üí ùïú) : PosSemidef (vecMulVec v (conj v)) := by
  constructor
  ¬∑ ext
    simp [vecMulVec_apply, mul_comm]
  ¬∑ intro x
    simp_rw [dotProduct, Pi.star_apply, RCLike.star_def, mulVec, dotProduct,
      vecMulVec_apply, mul_assoc, ‚Üê Finset.mul_sum, ‚Üê mul_assoc, ‚Üê Finset.sum_mul]
    change
      0 ‚â§ (‚àë i : n, conj (x i) * v i) * ‚àë i : n, conj (v i) * x i
    have : (‚àë i : n, conj (x i) * v i) =
        (‚àë i : n, conj (conj (v i) * x i)) := by
          simp only [mul_comm (conj (x _)) (v _), map_mul,
          RingHomCompTriple.comp_apply, RingHom.id_apply]
    rw [this, ‚Üê map_sum, ‚Üê RCLike.normSq_eq_conj_mul_self, RCLike.ofReal_nonneg]
    exact RCLike.normSq_nonneg _

include hA hB in
theorem convex_cone {c‚ÇÅ c‚ÇÇ : ùïú} (hc‚ÇÅ : 0 ‚â§ c‚ÇÅ) (hc‚ÇÇ : 0 ‚â§ c‚ÇÇ) : (c‚ÇÅ ‚Ä¢ A + c‚ÇÇ ‚Ä¢ B).PosSemidef :=
  (hA.smul hc‚ÇÅ).add (hB.smul hc‚ÇÇ)

variable [dm : DecidableEq m]

/-- A standard basis matrix (with a positive entry) is positive semidefinite iff the entry is on the diagonal. -/
theorem stdBasisMatrix_iff_eq (i j : m) {c : ùïú} (hc : 0 < c) : (single i j c).PosSemidef ‚Üî i = j := by
  constructor
  ¬∑ intro ‚ü®hherm, _‚ü©
    rw [IsHermitian, ‚Üê ext_iff] at hherm
    replace hherm := hherm i j
    simp only [single, conjTranspose_apply, of_apply, true_and, RCLike.star_def, if_true] at hherm
    apply_fun (starRingEnd ùïú) at hherm
    have hcstar := RCLike.conj_eq_iff_im.mpr (RCLike.pos_iff.mp hc).right
    rw [starRingEnd_self_apply, hcstar, ite_eq_left_iff] at hherm
    contrapose! hherm
    have hcnezero : 0 ‚â† c := by
      by_contra hczero
      subst hczero
      exact (lt_self_iff_false 0).mp hc
    exact ‚ü®fun _ => hherm.symm, hcnezero‚ü©
  ¬∑ intro hij
    subst hij
    constructor
    ¬∑ ext x y
      simp only [conjTranspose_apply, RCLike.star_def, single, of_apply]
      split_ifs <;> try tauto
      ¬∑ exact RCLike.conj_eq_iff_im.mpr (RCLike.pos_iff.1 hc).2
      ¬∑ exact RingHom.map_zero (starRingEnd ùïú)
    ¬∑ intro x
      simp only [dotProduct, single, of_apply, mulVec]
      convert_to 0 ‚â§ (star x i) * c * (x i)
      ¬∑ simp only [Finset.mul_sum]
        rw [‚ÜêFintype.sum_prod_type']
        have h‚ÇÄ : ‚àÄ x_1 : m √ó m, x_1 ‚â† ‚ü®i, i‚ü© ‚Üí star x x_1.1 * ((if i = x_1.1 ‚àß i = x_1.2 then c else 0) * x x_1.2) = 0 := fun z hz => by
          have h‚ÇÅ : ¬¨(i = z.1 ‚àß i = z.2) := by
            rw [ne_eq, Prod.mk_inj] at hz
            by_contra hz'
            apply hz
            exact ‚ü®hz'.left.symm, hz'.right.symm‚ü©
          rw [ite_cond_eq_false _ _ (eq_false h‚ÇÅ)]
          ring
        rw [Fintype.sum_eq_single ‚ü®i, i‚ü© h‚ÇÄ]
        simp [mul_assoc]
      ¬∑ rw [mul_comm, ‚Üêmul_assoc]
        have hpos : 0 ‚â§ x i * star x i := by simp only [Pi.star_apply, RCLike.star_def,
          RCLike.mul_conj, RCLike.ofReal_nonneg, norm_nonneg, pow_nonneg]
        exact (mul_nonneg hpos (le_of_lt hc))

end

variable {A : Matrix m m ùïú} {B : Matrix n n ùïú}
variable (hA : A.PosSemidef) (hB : B.PosSemidef)

include hA hB in
theorem PosSemidef_kronecker : (A ‚äó‚Çñ B).PosSemidef := by
  open Classical in
  rw [hA.left.spectral_theorem, hB.left.spectral_theorem]
  rw [mul_kronecker_mul, mul_kronecker_mul]
  rw [star_eq_conjTranspose, star_eq_conjTranspose]
  rw [‚Üê kroneckerMap_conjTranspose]
  rw [diagonal_kronecker_diagonal]
  apply mul_mul_conjTranspose_same
  rw [posSemidef_diagonal_iff]
  rintro ‚ü®i‚ÇÅ, i‚ÇÇ‚ü©
  convert mul_nonneg (hA.eigenvalues_nonneg i‚ÇÅ) (hB.eigenvalues_nonneg i‚ÇÇ)
  rw [RCLike.nonneg_iff]
  simp

variable [dm : DecidableEq m]

lemma sqrt_eq {A B : Matrix m m ùïú} (h : A = B) (hA : A.PosSemidef) (hB : B.PosSemidef) :
    hA.sqrt = hB.sqrt := by
  congr!

lemma sqrt_eq' {A B : Matrix m m ùïú} (h : A = B) (hA : A.PosSemidef) :
    hA.sqrt = (h ‚ñ∏ hA).sqrt := by
  congr!

@[simp]
theorem sqrt_0 : (PosSemidef.zero (n := n) (R := ùïú)).sqrt = 0 :=
  (sqrt_eq_zero_iff PosSemidef.zero).mpr rfl

@[simp]
theorem sqrt_1 : (PosSemidef.one (n := n) (R := ùïú)).sqrt = 1 :=
  (sqrt_eq_one_iff PosSemidef.one).mpr rfl

omit [DecidableEq m]

include hA in
theorem zero_dotProduct_zero_iff : (‚àÄ x : m ‚Üí ùïú, 0 = star x ‚¨ù·µ• A.mulVec x) ‚Üî A = 0 := by
  constructor
  ¬∑ intro h
    ext i j
    have h‚ÇÇ := fun x ‚Ü¶ (PosSemidef.dotProduct_mulVec_zero_iff hA x).mp (h x).symm
    classical have : DecidableEq m := inferInstance
    convert congrFun (h‚ÇÇ (Pi.single j 1)) i using 1
    simp
  ¬∑ rintro rfl
    simp

theorem nonneg_smul {c : ùïú} (hA : A.PosSemidef) (hc : 0 ‚â§ c) : (c ‚Ä¢ A).PosSemidef := by
  constructor
  ¬∑ simp only [IsHermitian, conjTranspose_smul, RCLike.star_def]
    congr
    exact RCLike.conj_eq_iff_im.mpr (RCLike.nonneg_iff.mp hc).2
    exact hA.1
  ¬∑ intro x
    rw [smul_mulVec, dotProduct_smul, smul_eq_mul]
    exact Left.mul_nonneg hc (hA.2 x)

theorem pos_smul {c : ùïú} (hA : (c ‚Ä¢ A).PosSemidef) (hc : 0 < c) : A.PosSemidef := by
  have : 0 < 1/c := by
    rw [RCLike.pos_iff] at hc ‚ä¢
    aesop
  convert hA.nonneg_smul (c := 1/c) this.le
  rw [smul_smul, one_div, inv_mul_cancel‚ÇÄ hc.ne', one_smul]

theorem nonneg_smul_Real_smul {c : ‚Ñù} (hA : A.PosSemidef) (hc : 0 ‚â§ c) : (c ‚Ä¢ A).PosSemidef := by
  rw [(RCLike.real_smul_eq_coe_smul c A : c ‚Ä¢ A = (c : ùïú) ‚Ä¢ A)]
  exact nonneg_smul hA (RCLike.ofReal_nonneg.mpr hc)

theorem pos_Real_smul {c : ‚Ñù} (hA : (c ‚Ä¢ A).PosSemidef) (hc : 0 < c) : A.PosSemidef := by
  rw [(RCLike.real_smul_eq_coe_smul c A : c ‚Ä¢ A = (c : ùïú) ‚Ä¢ A)] at hA
  exact pos_smul hA (RCLike.ofReal_pos.mpr hc)

include dm in
theorem sqrt_nonneg_smul {c : ùïú} (hA : (c^2 ‚Ä¢ A).PosSemidef) (hc : 0 < c) :
    hA.sqrt = c ‚Ä¢ (hA.pos_smul (sq_pos_of_pos hc) : A.PosSemidef).sqrt := by
  apply Eq.symm
  apply (eq_sqrt_iff_sq_eq ?_ hA).mpr
  ¬∑ rw [pow_two, Algebra.mul_smul_comm, Algebra.smul_mul_assoc, sqrt_mul_self, pow_two, smul_smul]
  ¬∑ apply nonneg_smul ?_ hc.le
    apply posSemidef_sqrt

theorem zero_posSemidef_neg_posSemidef_iff : A.PosSemidef ‚àß (-A).PosSemidef ‚Üî A = 0 := by
  constructor
  ¬∑ intro ‚ü®hA, hNegA‚ü©
    have h0 : ‚àÄ x : m ‚Üí ùïú, 0 = star x ‚¨ù·µ• A.mulVec x := fun x ‚Ü¶ by
      have hNegA' := hNegA.right x
      rw [neg_mulVec, dotProduct_neg, le_neg, neg_zero] at hNegA'
      exact le_antisymm (hA.right x) hNegA'
    exact (zero_dotProduct_zero_iff hA).mp h0
  ¬∑ rintro rfl
    simp [PosSemidef.zero]

end PosSemidef


namespace PosDef
open scoped ComplexOrder

variable {n m ùïú : Type*}
variable [Fintype n] [RCLike ùïú] [DecidableEq n]
variable {A : Matrix n n ùïú}

theorem toLin_ker_eq_bot (hA : A.PosDef) : LinearMap.ker A.toLin' = ‚ä• := by
  ext v
  have := hA.right v
  grind [mulVec_zero, dotProduct_zero, LinearMap.mem_ker, toLin'_apply, Submodule.mem_bot]

theorem of_toLin_ker_eq_bot (hA : LinearMap.ker A.toLin' = ‚ä•) (hA‚ÇÇ : A.PosSemidef) : A.PosDef := by
  rwa [hA‚ÇÇ.posDef_iff_isUnit, ‚Üê Matrix.isUnit_toLin'_iff, LinearMap.isUnit_iff_ker_eq_bot]

theorem ker_range_antitone {d : Type*} [Fintype d] [DecidableEq d] {A B : Matrix d d ‚ÑÇ}
  (hA : A.IsHermitian) (hB : B.IsHermitian) :
    LinearMap.ker A.toEuclideanLin ‚â§ LinearMap.ker B.toEuclideanLin ‚Üî
    LinearMap.range B.toEuclideanLin ‚â§ LinearMap.range A.toEuclideanLin
     := by
  rw [Matrix.isHermitian_iff_isSymmetric] at hA hB
  exact ContinuousLinearMap.ker_le_ker_iff_range_le_range
    (T := Matrix.toEuclideanCLM.toFun B) (U := Matrix.toEuclideanCLM.toFun A) hB hA

end PosDef

namespace PosSemidef
section partialOrder
open scoped ComplexOrder

variable {n m ùïú : Type*}
variable [Fintype n] [Fintype m] [RCLike ùïú] [DecidableEq m]
variable {A : Matrix n n ùïú} {B : Matrix n n ùïú}
variable (hA : A.IsHermitian) (hB : B.IsHermitian)

/-- Loewner partial order of square matrices induced by positive-semi-definiteness:
`A ‚â§ B ‚Üî (B - A).PosSemidef` alongside properties that make it an "OrderedCancelAddCommMonoid"
TODO : Equivalence to CStarAlgebra.spectralOrder -/
instance loewnerOrder : PartialOrder (Matrix n n ùïú) where
  le A B := (B - A).PosSemidef
  le_refl A := by simp only [sub_self, PosSemidef.zero]
  le_trans A B C hAB hBC := by
    rw [‚Üêsub_add_sub_cancel _ B _]
    exact PosSemidef.add hBC hAB
  le_antisymm A B hAB hBA := by
    rw [‚Üêneg_sub] at hAB
    rw [‚Üêsub_eq_zero]
    exact zero_posSemidef_neg_posSemidef_iff.mp ‚ü®hBA, hAB‚ü©

instance instOrderedCancelAddCommMonoid : IsOrderedCancelAddMonoid (Matrix n n ùïú) where
  add_le_add_left A B hAB C := by
    dsimp [loewnerOrder]
    rwa [add_sub_add_left_eq_sub]
  le_of_add_le_add_left A B C hABAC:= by
    dsimp [loewnerOrder] at hABAC
    rwa [add_sub_add_left_eq_sub] at hABAC

theorem le_iff_sub_posSemidef : A ‚â§ B ‚Üî (B - A).PosSemidef := by rfl

theorem zero_le_iff_posSemidef : 0 ‚â§ A ‚Üî A.PosSemidef := by
  apply Iff.trans (le_iff_sub_posSemidef)
  rw [sub_zero]

/-- Basically, the instance states A ‚â§ B ‚Üî B = A + S·¥¥ * S  -/
instance instStarOrderedRing : StarOrderedRing (Matrix n n ùïú) :=
  StarOrderedRing.of_nonneg_iff'
    (add_le_add_left)
    (fun _ ‚Ü¶ zero_le_iff_posSemidef.trans posSemidef_iff_eq_conjTranspose_mul_self)

theorem le_iff_sub_nonneg : A ‚â§ B ‚Üî 0 ‚â§ B - A := Iff.trans le_iff_sub_posSemidef zero_le_iff_posSemidef.symm

theorem le_of_nonneg_imp {R : Type*} [AddCommGroup R] [PartialOrder R] [IsOrderedAddMonoid R]
    (f : Matrix n n ùïú ‚Üí+ R) (h : ‚àÄ A, A.PosSemidef ‚Üí 0 ‚â§ f A) :
    (A ‚â§ B ‚Üí f A ‚â§ f B) := by
  intro hAB
  rw [‚Üêsub_nonneg, ‚Üêmap_sub]
  exact h (B - A) <| le_iff_sub_posSemidef.mp hAB

theorem le_of_nonneg_imp' {R : Type*} [AddCommGroup R] [PartialOrder R] [IsOrderedAddMonoid R]
    {x y : R} (f : R ‚Üí+ Matrix n n ùïú) (h : ‚àÄ x, 0 ‚â§ x ‚Üí (f x).PosSemidef) :
    (x ‚â§ y ‚Üí f x ‚â§ f y) := by
  intro hxy
  rw [le_iff_sub_nonneg, ‚Üêmap_sub]
  rw [‚Üêsub_nonneg] at hxy
  exact zero_le_iff_posSemidef.mpr <| h (y - x) hxy

omit [DecidableEq m] in
theorem mul_mul_conjTranspose_mono (C : Matrix m n ùïú) :
  A ‚â§ B ‚Üí C * A * C.conjTranspose ‚â§ C * B * C.conjTranspose := fun hAB ‚Ü¶ by
    rw [le_iff_sub_posSemidef]
    have hDistrib : C * B * C·¥¥ - C * A * C·¥¥ = C * (B - A) * C·¥¥ := by
      ext i j
      simp only [sub_apply, mul_apply, conjTranspose_apply, RCLike.star_def, Finset.sum_mul,
        ‚ÜêFinset.sum_sub_distrib, mul_sub_left_distrib, mul_sub_right_distrib]
    rw [hDistrib]
    exact mul_mul_conjTranspose_same (le_iff_sub_posSemidef.mp hAB) C

omit [DecidableEq m] in
theorem conjTranspose_mul_mul_mono (C : Matrix n m ùïú) :
  A ‚â§ B ‚Üí C.conjTranspose * A * C ‚â§ C.conjTranspose * B * C := fun hAB ‚Ü¶ by
    rw [le_iff_sub_posSemidef]
    have hDistrib : C·¥¥ * B * C - C·¥¥ * A * C = C·¥¥ * (B - A) * C := by
      ext i j
      simp only [sub_apply, mul_apply, conjTranspose_apply, RCLike.star_def, Finset.sum_mul,
        ‚ÜêFinset.sum_sub_distrib, mul_sub_left_distrib, mul_sub_right_distrib]
    rw [hDistrib]
    exact conjTranspose_mul_mul_same (le_iff_sub_posSemidef.mp hAB) C

/-- Basically, the instance states 0 ‚â§ A ‚Üí ‚àÄ x ‚àà spectrum ‚Ñù A, 0 ‚â§ x  -/
instance instNonnegSpectrumClass : NonnegSpectrumClass ‚Ñù (Matrix n n ùïú) := by
  open Classical in
  apply NonnegSpectrumClass.of_spectrum_nonneg
  intro A hA x hx
  rw [(zero_le_iff_posSemidef.mp hA).1.spectrum_real_eq_range_eigenvalues, Set.mem_range] at hx
  obtain ‚ü®i, hi‚ü© := hx
  rw [‚Üêhi]
  exact (zero_le_iff_posSemidef.mp hA).eigenvalues_nonneg i

theorem nonneg_iff_eigenvalue_nonneg [DecidableEq n] : 0 ‚â§ A ‚Üî ‚àÄ x, 0 ‚â§ hA.eigenvalues x :=
  Iff.trans zero_le_iff_posSemidef hA.posSemidef_iff_eigenvalues_nonneg

theorem diag_monotone : Monotone (diag : Matrix n n ùïú ‚Üí (n ‚Üí ùïú)) := fun _ _ ‚Ü¶
  le_of_nonneg_imp (diagAddMonoidHom n ùïú) (fun _ ‚Ü¶ diag_nonneg)

theorem diag_mono : A ‚â§ B ‚Üí ‚àÄ i, A.diag i ‚â§ B.diag i := diag_monotone.imp

theorem trace_monotone : Monotone (@trace n ùïú _ _) := fun _ _ ‚Ü¶
  le_of_nonneg_imp (traceAddMonoidHom n ùïú) (fun _ ‚Ü¶ trace_nonneg)

theorem trace_mono : A ‚â§ B ‚Üí A.trace ‚â§ B.trace := trace_monotone.imp

variable [DecidableEq n]

theorem diagonal_monotone : Monotone (diagonal : (n ‚Üí ùïú) ‚Üí _) := fun _ _ ‚Ü¶
  le_of_nonneg_imp' (diagonalAddMonoidHom n ùïú) (fun _ ‚Ü¶ PosSemidef.diagonal)

theorem diagonal_mono {d‚ÇÅ d‚ÇÇ : n ‚Üí ùïú} : d‚ÇÅ ‚â§ d‚ÇÇ ‚Üí diagonal d‚ÇÅ ‚â§ diagonal d‚ÇÇ := diagonal_monotone.imp

theorem diagonal_le_iff {d‚ÇÅ d‚ÇÇ : n ‚Üí ùïú} : d‚ÇÅ ‚â§ d‚ÇÇ ‚Üî diagonal d‚ÇÅ ‚â§ diagonal d‚ÇÇ := ‚ü®diagonal_mono, by
  intro hd
  rw [le_iff_sub_posSemidef, diagonal_sub, posSemidef_diagonal_iff] at hd
  simp only [sub_nonneg] at hd
  exact hd‚ü©

theorem le_smul_one_of_eigenvalues_iff (hA : A.PosSemidef) (c : ‚Ñù) :
  (‚àÄ i, hA.1.eigenvalues i ‚â§ c) ‚Üî A ‚â§ c ‚Ä¢ (1 : Matrix n n ùïú) := by
  let U : Matrix n n ùïú := ‚ÜëhA.1.eigenvectorUnitary
  have hU : U.conjTranspose = star U := by simp only [star]
  have hU' : U * star U = 1 := by
    simp only [SetLike.coe_mem, unitary.mul_star_self_of_mem, U]
  have hc : c ‚Ä¢ (1 : Matrix n n ùïú) = U * (c ‚Ä¢ 1) * U.conjTranspose := by
    simp only [Algebra.mul_smul_comm, mul_one, hU, Algebra.smul_mul_assoc, hU']
  have hc' : c ‚Ä¢ (1 : Matrix n n ùïú) = diagonal (RCLike.ofReal ‚àò fun _ : n ‚Ü¶ c) := by
    ext i j
    simp only [smul_apply, one_apply, smul_ite, RCLike.real_smul_eq_coe_mul, mul_one, smul_zero,
      diagonal, Function.comp_apply, of_apply]
  have hAST : A = U * diagonal (RCLike.ofReal ‚àò hA.1.eigenvalues) * U.conjTranspose := by
    rw [hU]
    exact IsHermitian.spectral_theorem hA.1
  constructor
  ¬∑ intro h
    rw [hc, hc', hAST]
    apply mul_mul_conjTranspose_mono
    apply diagonal_mono
    intro i
    simp only [Function.comp_apply, algebraMap_le_algebraMap, h i]
  intro hAc i
  replace hAc := conjTranspose_mul_mul_mono U hAc
  have hU'CT : star U * U = 1 := by
    simp only [SetLike.coe_mem, unitary.star_mul_self_of_mem, U]
  have hcCT : U.conjTranspose * (c ‚Ä¢ 1) * U = c ‚Ä¢ (1 : Matrix n n ùïú) := by
    simp only [Algebra.mul_smul_comm, mul_one, hU, Algebra.smul_mul_assoc, hU'CT]
  have hASTCT : U.conjTranspose * A * U = diagonal (RCLike.ofReal ‚àò hA.1.eigenvalues) := by
    rw [hU]
    exact IsHermitian.star_mul_self_mul_eq_diagonal hA.1
  rw [hcCT, hc', hASTCT, ‚Üêdiagonal_le_iff] at hAc
  specialize hAc i
  simp only [Function.comp_apply, algebraMap_le_algebraMap] at hAc
  exact hAc

end partialOrder

end PosSemidef

-- noncomputable section frobenius_inner_product
-- open scoped ComplexOrder
-- variable {A : Matrix n n ùïú} {B : Matrix n n ùïú} {C : Matrix n n ùïú} [Fintype n]

-- /-- The InnerProductSpace on Matrix n n ùïú defined by the real part of the
--  Frobenius inner product. -/
-- def InnerProductCore : InnerProductSpace.Core (ùïú := ‚Ñù) (F := Matrix n n ùïú):=
--    {
--     inner A B := RCLike.re (A·¥¥ * B).trace
--     conj_inner_symm := fun x y ‚Ü¶ by
--       simpa [inner, starRingEnd_apply, ‚Üê trace_conjTranspose] using
--         RCLike.conj_re (x·¥¥ * y).trace
--     re_inner_nonneg := fun x ‚Ü¶
--       (RCLike.nonneg_iff.mp x.posSemidef_conjTranspose_mul_self.trace_nonneg).1
--     add_left := by simp [inner, add_mul]
--     smul_left x y r := by
--       simpa using RCLike.smul_re _ (x·¥¥ * y).trace
--     definite x h := by
--       ext i j
--       replace h : ‚àë j, ‚àë i, (RCLike.re (x i j) ^ 2 + RCLike.im (x i j) ^ 2) = 0 := by
--         simpa [trace, mul_apply, ‚Üê pow_two] using h
--       rw [Fintype.sum_eq_zero_iff_of_nonneg (fun i ‚Ü¶ by positivity)] at h
--       replace h := congrFun h j
--       rw [Pi.zero_apply, Fintype.sum_eq_zero_iff_of_nonneg (fun i ‚Ü¶ by positivity)] at h
--       replace h := congrFun h i
--       dsimp at h
--       rw [add_eq_zero_iff_of_nonneg (sq_nonneg _) (sq_nonneg _), sq_eq_zero_iff, sq_eq_zero_iff] at h
--       apply RCLike.ext (h.left.trans RCLike.zero_re.symm) (h.right.trans (map_zero _).symm)
--   }

-- def instNormed : NormedAddCommGroup (Matrix n n ùïú) :=
--   InnerProductCore.toNormedAddCommGroup

-- scoped[Frobenius] attribute [instance] Matrix.instNormed

-- open scoped Frobenius in
-- def instInnerProductSpace : InnerProductSpace ‚Ñù (Matrix n n ùïú) :=
--   InnerProductSpace.ofCore InnerProductCore

-- scoped[Frobenius] attribute [instance] Matrix.instInnerProductSpace

-- instance : Inner ‚Ñù (Matrix n n ùïú) :=
--   instInnerProductSpace.toInner

-- /-- The InnerProductSpace on Matrix n n ùïú defined by the Frobenius inner product. -/
-- def CInnerProductCore : InnerProductSpace.Core (ùïú := ‚ÑÇ) (F := Matrix n n ‚ÑÇ):=
--    {
--     inner A B := (A·¥¥ * B).trace
--     conj_inner_symm := fun x y ‚Ü¶ by
--       simp [inner, starRingEnd_apply, ‚Üê Matrix.trace_conjTranspose]
--     re_inner_nonneg := fun x ‚Ü¶
--       (RCLike.nonneg_iff.mp x.posSemidef_conjTranspose_mul_self.trace_nonneg).1
--     add_left := by simp [inner, add_mul]
--     smul_left x y r := by simp
--     definite x h := by
--       ext i j
--       replace h : ‚àë j, ‚àë i, ((x i j).re ^ 2 + (x i j).im ^ 2) = (0 : ‚ÑÇ) := by
--         convert h
--         simp only [Complex.ofReal_sum, Complex.ofReal_add, Complex.ofReal_pow, trace, diag_apply,
--           mul_apply, conjTranspose_apply, RCLike.star_def]
--         congr! 2
--         norm_cast
--         rw [Complex.conj_mul', ‚Üê Complex.sq_norm_sub_sq_re]
--         norm_cast
--         abel
--       rw [Complex.ofReal_eq_zero,
--         Fintype.sum_eq_zero_iff_of_nonneg (fun i ‚Ü¶ by positivity)] at h
--       replace h := congrFun h j
--       rw [Pi.zero_apply, Fintype.sum_eq_zero_iff_of_nonneg (fun i ‚Ü¶ by positivity)] at h
--       replace h := congrFun h i
--       dsimp at h
--       rw [add_eq_zero_iff_of_nonneg (sq_nonneg _) (sq_nonneg _), sq_eq_zero_iff, sq_eq_zero_iff] at h
--       apply RCLike.ext (h.left.trans RCLike.zero_re.symm) (h.right.trans (map_zero _).symm)
--   }

-- open scoped Frobenius in
-- def instCInnerProductSpace : InnerProductSpace ‚ÑÇ (Matrix n n ‚ÑÇ) :=
--   InnerProductSpace.ofCore CInnerProductCore

-- scoped[Frobenius] attribute [instance] Matrix.instCInnerProductSpace

-- instance : Inner ‚ÑÇ (Matrix n n ‚ÑÇ) :=
--   instCInnerProductSpace.toInner

--Makes the `Inner ‚Ñù` instance is globally accessible, but the norm instances
--require `open scoped Frobenius`. e.g.

-- open scoped Frobenius in
-- #synth InnerProductSpace ‚Ñù (Matrix (Fin 5) (Fin 5) ‚Ñù)

-- (no `open` ne