# Lean 4 Code Generation System Prompt (Chunked Version)

You are an expert Lean 4 theorem prover specializing in quantum information theory. Convert natural language prompts into precise Lean 4 code using the Lean-QuantumInfo repository as reference.

## Your Role
Convert natural language descriptions of mathematical concepts, theorems, and proofs into formal Lean 4 code following the exact patterns, definitions, and conventions from the Lean-QuantumInfo repository.

## Key Repository Patterns

### Probability & Distributions
```lean
def Prob := { p : ‚Ñù // 0 ‚â§ p ‚àß p ‚â§ 1 }
def Distribution (Œ± : Type u) [Fintype Œ±] : Type u :=
  { f : Œ± ‚Üí Prob // Finset.sum Finset.univ (fun i ‚Ü¶ (f i : ‚Ñù)) = 1 }
```

### Quantum States
```lean
structure MState (d : Type*) [Fintype d] :=
  m : Matrix d d ‚ÑÇ
  pos : m.PosSemidef
  tr : m.trace = 1

structure Bra (d : ‚Ñï) :=
  vec : Fin d ‚Üí ‚ÑÇ
  normalized' : ‚àë i, ‚Äñvec i‚Äñ^2 = 1
```

### Entropy Functions
```lean
def shannon_entropy (p : Distribution Œ±) : ‚Ñù :=
  -‚àë x, (p.val x).toReal * Real.log (p.val x).toReal

def von_neumann_entropy (œÅ : MState d) : ‚Ñù :=
  -‚àë i, (eigenvalues œÅ.m i).toReal * Real.log (eigenvalues œÅ.m i).toReal
```

## Response Format
1. **Analysis**: Explain the mathematical concept
2. **Lean Code**: Complete implementation with imports
3. **Explanation**: Key components and mathematical meaning
4. **Dependencies**: Required imports and related definitions

## Guidelines
- Use Unicode: `‚Ñù`, `‚Ñï`, `‚ÑÇ`, `‚Üí`, `‚Üî`, `‚àß`, `‚à®`, `‚àÄ`, `‚àÉ`
- Include docstrings: `/-- ... -/`
- Type annotations: `[Fintype Œ±]`, `[DecidableEq Œ±]`
- Use `sorry` for incomplete proofs
- Follow repository naming conventions
- Reference existing definitions when possible

## Repository Content Reference

The following is a portion of the Lean-QuantumInfo repository content. Use this as reference for code generation:

---


/-- A channel is *antidegradable to* another, if the other `IsDegradableTo` this one. -/
@[reducible]
def IsAntidegradableTo (Œõ : CPTPMap dIn dOut) (Œõ‚ÇÇ : CPTPMap dIn dOut‚ÇÇ) : Prop :=
  IsDegradableTo Œõ‚ÇÇ Œõ

/-- A channel is *degradable* if it `IsDegradableTo` its complementary channel. -/
def IsDegradable (Œõ : CPTPMap dIn dOut) : Prop :=
  IsDegradableTo Œõ Œõ.complementary

/-- A channel is *antidegradable* if it `IsAntidegradableTo` its complementary channel. -/
@[reducible]
def IsAntidegradable (Œõ : CPTPMap dIn dOut) : Prop :=
  IsAntidegradableTo Œõ Œõ.complementary

--Theorem (Wilde Exercise 13.5.7): Entanglement breaking channels are antidegradable.
end degradable

/-- `CPTPMap`s inherit a topology from their choi matrices. -/
instance instTop : TopologicalSpace (CPTPMap dIn dOut) :=
  TopologicalSpace.induced (CPTPMap.choi) instTopologicalSpaceMatrix

/-- The projection from `CPTPMap` to the Choi matrix is an embedding -/
theorem choi_IsEmbedding : Topology.IsEmbedding (CPTPMap.choi (dIn := dIn) (dOut := dOut)) where
  eq_induced := rfl
  injective _ _ := choi_ext

instance instT5MState : T3Space (CPTPMap dIn dOut) :=
  Topology.IsEmbedding.t3Space choi_IsEmbedding

end
end CPTPMap


================================================================================
FILE: QuantumInfo/Finite/CPTPMap/Dual.lean
TYPE: Lean 4
SIZE: 12081 characters
================================================================================

import QuantumInfo.Finite.CPTPMap.Bundled
import Mathlib.LinearAlgebra.Matrix.FiniteDimensional

/-! # Duals of matrix map

Definitions and theorems about the dual of a matrix map. -/

noncomputable section
open ComplexOrder

variable {dIn dOut : Type*} [Fintype dIn] [Fintype dOut]
variable {R : Type*} [CommRing R]
variable {ùïú : Type*} [RCLike ùïú]

--PULLOUT
theorem HermitianMat.toMat_add (x y : HermitianMat d ‚ÑÇ) : (x + y).toMat = x.toMat + y.toMat := by
  rfl

namespace MatrixMap

variable [DecidableEq dIn] [DecidableEq dOut] {M : MatrixMap dIn dOut ùïú}

--This should be definable with LinearMap.adjoint, but that requires InnerProductSpace stuff
--that is currently causing issues and pains (tried `open scoped Frobenius`).

/-- The dual of a map between matrices, defined by `Tr[A M(B)] = Tr[(dual M)(A) B]`. Sometimes
 called the adjoint of the map instead. -/
@[irreducible]
def dual (M : MatrixMap dIn dOut R) : MatrixMap dOut dIn R :=
  let iso1 := (Module.Basis.toDualEquiv <| Matrix.stdBasis R dIn dIn).symm
  let iso2 := (Module.Basis.toDualEquiv <| Matrix.stdBasis R dOut dOut)
  iso1 ‚àò‚Çó LinearMap.dualMap M ‚àò‚Çó iso2

/-- The defining property of a dual map: inner products are preserved on the opposite argument. -/
theorem Dual.trace_eq (M : MatrixMap dIn dOut R) (A : Matrix dIn dIn R) (B : Matrix dOut dOut R) :
    (M A * B).trace = (A * M.dual B).trace := by
  unfold dual
  dsimp [Matrix.trace]
  rw [LinearMap.dualMap_apply']
  simp_rw [Matrix.mul_apply]
  sorry

--all properties below should provable just from `inner_eq`, since the definition of `dual` itself
-- is pretty hair (and maybe could be improved...)

/-- The dual of a `IsHermitianPreserving` map also `IsHermitianPreserving`. -/
theorem IsHermitianPreserving.dual (h : M.IsHermitianPreserving) : M.dual.IsHermitianPreserving := by
  sorry

/-- The dual of a `IsPositive` map also `IsPositive`. -/
theorem IsPositive.dual (h : M.IsPositive) : M.dual.IsPositive := by
  intro x hx
  use IsHermitianPreserving.dual h.IsHermitianPreserving hx.1
  sorry

/-- The dual of TracePreserving map is *not* trace-preserving, it's *unital*, that is, M*(I) = I. -/
theorem dual_Unital (h : M.IsTracePreserving) : M.dual.Unital := by
  sorry

alias IsTracePreserving.dual := dual_Unital

--The dual of a CompletelyPositive map is always CP, more generally it's k-positive
-- see Lemma 3.1 of https://www.math.uwaterloo.ca/~krdavids/Preprints/CDPRpositivereal.pdf
theorem IsCompletelyPositive.dual (h : M.IsCompletelyPositive) : M.dual.IsCompletelyPositive := by
  sorry

@[simp]
theorem dual_dual : M.dual.dual = M := by
  rw [dual, dual]
  simp only [‚Üê LinearMap.dualMap_comp_dualMap]
  have h‚ÇÅ : (Matrix.stdBasis ùïú dOut dOut).toDualEquiv.symm.toLinearMap ‚àò‚Çó
      ((Matrix.stdBasis ùïú dOut dOut).toDualEquiv).toLinearMap.dualMap =
      (Module.evalEquiv ùïú (Matrix dOut dOut ùïú)).symm.toLinearMap := by
    sorry
  have h‚ÇÇ : (Matrix.stdBasis ùïú dIn dIn).toDualEquiv.symm.toLinearMap.dualMap ‚àò‚Çó
      (Matrix.stdBasis ùïú dIn dIn).toDualEquiv.toLinearMap =
      (Module.evalEquiv ùïú (Matrix dIn dIn ùïú)).toLinearMap := by
    ext x y
    simp
    generalize Matrix.stdBasis ùïú dIn dIn = L
    sorry
  rw [‚Üê Module.Dual.eval_comp_comp_evalEquiv_eq]
  rw [‚Üê Module.evalEquiv_toLinearMap]
  simp only [‚Üê LinearMap.comp_assoc, LinearEquiv.comp_coe, LinearEquiv.self_trans_symm, LinearEquiv.refl_toLinearMap,
    LinearMap.id_comp, h‚ÇÅ]
  simp only [LinearMap.comp_assoc, LinearEquiv.comp_coe, LinearEquiv.self_trans_symm, LinearEquiv.refl_toLinearMap,
    LinearMap.comp_id, h‚ÇÇ]

end MatrixMap

namespace CPTPMap

variable [DecidableEq dIn] [DecidableEq dOut]

def dual (M : CPTPMap dIn dOut) : CPUMap dOut dIn where
  toLinearMap := M.map.dual
  unital := M.TP.dual
  cp := .dual M.cp

theorem dual_pos (M : CPTPMap dIn dOut) {T : HermitianMat dOut ‚ÑÇ} (hT : 0 ‚â§ T) :
    0 ‚â§ M.dual T := by
  exact M.dual.pos_Hermitian hT

/-- The dual of a CPTP map preserves POVMs. Stated here just for two-element POVMs, that is, an
operator `T` between 0 and 1. -/
theorem dual.PTP_POVM (M : CPTPMap dIn dOut) {T : HermitianMat dOut ‚ÑÇ} (hT : 0 ‚â§ T ‚àß T ‚â§ 1) :
    (0 ‚â§ M.dual T ‚àß M.dual T ‚â§ 1) := by
  rcases hT with ‚ü®hT‚ÇÅ, hT‚ÇÇ‚ü©
  have hT_psd := HermitianMat.zero_le_iff.mp hT‚ÇÅ
  use M.dual.pos_Hermitian hT‚ÇÅ
  simpa using ContinuousOrderHomClass.map_monotone M.dual hT‚ÇÇ

/-- The defining property of a dual channel, as specialized to `MState.exp_val`. -/
theorem exp_val_Dual (‚Ñ∞ : CPTPMap dIn dOut) (œÅ : MState dIn) (T : HermitianMat dOut ‚ÑÇ) :
    (‚Ñ∞ œÅ).exp_val T  = œÅ.exp_val (‚Ñ∞.dual T) := by
  simp only [MState.exp_val, HermitianMat.inner_eq_re_trace,
    HermitianMat.val_eq_coe, RCLike.re_to_complex]
  congr 1
  apply MatrixMap.Dual.trace_eq

end CPTPMap

section hermDual

--PULLOUT to Bundled.lean. Also use this to improve the definitions in POVM.lean.
def HPMap.ofHermitianMat (f : HermitianMat dIn ‚ÑÇ ‚Üí‚Çó[‚Ñù] HermitianMat dOut ‚ÑÇ) : HPMap dIn dOut where
  toFun x := f (realPart x) + Complex.I ‚Ä¢ f (imaginaryPart x)
  map_add' x y := by
    simp only [map_add, AddSubgroup.coe_add, smul_add]
    abel
  map_smul' c m := by
    have h_expand : realPart (c ‚Ä¢ m) = c.re ‚Ä¢ realPart m - c.im ‚Ä¢ imaginaryPart m ‚àß
      imaginaryPart (c ‚Ä¢ m) = c.re ‚Ä¢ imaginaryPart m + c.im ‚Ä¢ realPart m := by
      simp only [Subtype.ext_iff, AddSubgroupClass.coe_sub, selfAdjoint.val_smul,
        AddSubgroup.coe_add, realPart, selfAdjointPart_apply_coe, invOf_eq_inv, star_smul, RCLike.star_def,
        smul_add, imaginaryPart, LinearMap.coe_comp, Function.comp_apply,
        skewAdjoint.negISMul_apply_coe, skewAdjointPart_apply_coe,
        ‚Üê Matrix.ext_iff, Matrix.add_apply, Matrix.smul_apply, smul_eq_mul, Complex.real_smul,
        Complex.ofReal_inv, Complex.ofReal_ofNat, Matrix.star_apply, RCLike.star_def,
        Matrix.sub_apply, Complex.ext_iff, Complex.add_re, Complex.mul_re, Complex.inv_re,
        Complex.normSq_ofNat, Complex.mul_im, Complex.conj_re, Complex.conj_im, Complex.ofReal_re,
        Complex.sub_re, Complex.sub_im, Complex.add_im, Complex.neg_re, Complex.neg_im]
      ring_nf
      simp
    ext
    simp only [h_expand, map_sub, map_smul, AddSubgroupClass.coe_sub,
      selfAdjoint.val_smul, map_add, AddSubgroup.coe_add, smul_add, Matrix.add_apply,
      Matrix.sub_apply, Matrix.smul_apply, Complex.real_smul, smul_eq_mul, RingHom.id_apply,
      Complex.ext_iff, Complex.add_re, Complex.sub_re, Complex.mul_re, Complex.ofReal_re,
      Complex.ofReal_im, Complex.I, Complex.mul_im, Complex.add_im, Complex.sub_im]
    ring_nf
    simp
  HP h := by
    apply Matrix.IsHermitian.add
    ¬∑ apply HermitianMat.H
    ¬∑ simp [IsSelfAdjoint.imaginaryPart h]

--PULLOUT
@[simp]
theorem HPMap.linearMap_ofHermitianMat (f : HermitianMat dIn ‚ÑÇ ‚Üí‚Çó[‚Ñù] HermitianMat dOut ‚ÑÇ) :
    LinearMapClass.linearMap (HPMap.ofHermitianMat f) = f := by
  ext1 ‚ü®x, hx‚ü©
  ext1
  simp only [ofHermitianMat, LinearMap.coe_coe]
  simp only [HPMap.instFunLike, HPMap.map, HermitianMat.val_eq_coe, HermitianMat.mk_toMat,
    LinearMap.coe_mk, AddHom.coe_mk]
  conv => enter [2, 1, 2, 1]; rw [‚Üê realPart_add_I_smul_imaginaryPart x]
  suffices imaginaryPart x = 0 by simp [this]
  simp [imaginaryPart, skewAdjoint.negISMul, show star x = x from hx]

--PULLOUT
@[simp]
theorem HPMap.ofHermitianMat_linearMap (f : HPMap dIn dOut ‚ÑÇ) :
    ofHermitianMat (LinearMapClass.linearMap f) = f := by
  ext : 2
  simp only [map, ofHermitianMat, instFunLike, LinearMap.coe_coe, HermitianMat.val_eq_coe,
    HermitianMat.mk_toMat, LinearMap.coe_mk, AddHom.coe_mk,
    ‚Üê map_smul, ‚Üê map_add, realPart_add_I_smul_imaginaryPart]

variable (f : HPMap dIn dOut) (A : HermitianMat dIn ‚ÑÇ)

--Can define one for HPMap's that has 'easier' definitional properties, uses the inner product structure,
--doesn't go through Module.Basis the same way. Requires the equivalence between ‚Ñù-linear maps of HermitianMats
--and ‚ÑÇ-linear maps of matrices.
def HPMap.hermDual : HPMap dOut dIn :=
  HPMap.ofHermitianMat (LinearMapClass.linearMap f).adjoint

@[simp]
theorem HPMap.hermDual_hermDual : f.hermDual.hermDual = f := by
  simp [hermDual]

open RealInnerProductSpace in
/-- The defining property of a dual map: inner products are preserved on the opposite argument. -/
theorem HPMap.inner_hermDual (B : HermitianMat dOut ‚ÑÇ) :
    ‚ü™f A, B‚ü´ = ‚ü™A, f.hermDual B‚ü´ := by
  change ‚ü™(LinearMapClass.linearMap f) A, B‚ü´ = ‚ü™A, (LinearMapClass.linearMap f.hermDual) B‚ü´
  rw [hermDual, ‚Üê LinearMap.adjoint_inner_right, HPMap.linearMap_ofHermitianMat]

/-- Version of `HPMap.inner_hermDual` that uses HermitiaMat.inner directly. TODO cleanup -/
theorem HPMap.inner_hermDual' (B : HermitianMat dOut ‚ÑÇ) :
    (f A).inner B = A.inner (f.hermDual B) :=
  HPMap.inner_hermDual f A B

open RealInnerProductSpace in
theorem inner_negPart_nonpos [DecidableEq dIn] : ‚ü™A, A‚Åª‚ü´ ‚â§ 0 := by
  sorry

open RealInnerProductSpace in
theorem inner_negPart_zero_iff [DecidableEq dIn] : ‚ü™A, A‚Åª‚ü´ = 0 ‚Üî 0 ‚â§ A := by
  sorry

open RealInnerProductSpace in
theorem inner_negPart_neg_iff [DecidableEq dIn] : ‚ü™A, A‚Åª‚ü´ < 0 ‚Üî ¬¨0 ‚â§ A := by
  simp [‚Üê inner_negPart_zero_iff, lt_iff_le_and_ne, inner_negPart_nonpos A]

--PULLOUT
open RealInnerProductSpace in
theorem HermitianMat.zero_le_iff_inner_pos (A : HermitianMat dIn ‚ÑÇ) :
    0 ‚â§ A ‚Üî ‚àÄ B, 0 ‚â§ B ‚Üí 0 ‚â§ ‚ü™A, B‚ü´ := by
  use fun h _ ‚Ü¶ inner_ge_zero h
  intro h
  contrapose! h
  classical
  use A‚Åª, negPart_le_zero A
  rwa [inner_negPart_neg_iff]

/-- The dual of a `IsPositive` map also `IsPositive`. -/
theorem MatrixMap.IsPositive.hermDual (h : MatrixMap.IsPositive f.map) : f.hermDual.map.IsPositive := by
  unfold IsPositive at h ‚ä¢
  intro x hx
  set xH : HermitianMat dOut ‚ÑÇ := ‚ü®x, hx.left‚ü© with hxH
  have hx' : x = xH := rfl; clear_value xH; subst x; clear hxH
  change Matrix.PosSemidef (f.hermDual xH).toMat
  rw [‚Üê HermitianMat.zero_le_iff] at hx ‚ä¢
  rw [HermitianMat.zero_le_iff_inner_pos]
  intro y hy
  rw [HermitianMat.zero_le_iff] at hy
  specialize h hy
  change Matrix.PosSemidef (f y).toMat at h
  rw [‚Üê HermitianMat.zero_le_iff] at h
  rw [HPMap.inner_hermDual, HPMap.hermDual_hermDual]
  apply HermitianMat.inner_ge_zero hx h

/-- The dual of TracePreserving map is *not* trace-preserving, it's *unital*, that is, M*(I) = I. -/
theorem HPMap.hermDual_Unital [DecidableEq dIn] [DecidableEq dOut] (h : MatrixMap.IsTracePreserving f.map) :
    f.hermDual.map.Unital := by
  suffices f.hermDual 1 = 1 by --todo: make this is an accessible 'constructor' for Unital
    rw [HermitianMat.ext_iff] at this
    exact this
  open RealInnerProductSpace in
  apply ext_inner_left ‚Ñù
  intro v
  rw [‚Üê HPMap.inner_hermDual]
  change HermitianMat.inner _ _ = HermitianMat.inner _ _
  rw [HermitianMat.inner_one, HermitianMat.inner_one] --TODO change to Inner.inner
  exact congr(Complex.re $(h v)) --TODO: HPMap with IsTracePreserving give the HermitianMat.trace version

alias MatrixMap.IsTracePreserving.hermDual := HPMap.hermDual_Unital

namespace PTPMap

variable [DecidableEq dIn] [DecidableEq dOut]

def hermDual (M : PTPMap dIn dOut) : PUMap dOut dIn where
  toHPMap := M.toHPMap.hermDual
  pos := by
    apply MatrixMap.IsPositive.hermDual --TODO: fix the implictness on IsPositive's arguments
    exact @M.pos
  unital := M.TP.hermDual

theorem hermDual_pos (M : PTPMap dIn dOut) {T : HermitianMat dOut ‚ÑÇ} (hT : 0 ‚â§ T) :
    0 ‚â§ M.hermDual T := by
  exact M.hermDual.pos_Hermitian hT

/-- The dual of a PTP map preserves POVMs. Stated here just for two-element POVMs, that is, an
operator `T` between 0 and 1. -/
theorem hermDual.PTP_POVM (M : PTPMap dIn dOut) {T : HermitianMat dOut ‚ÑÇ} (hT : 0 ‚â§ T ‚àß T ‚â§ 1) :
    (0 ‚â§ M.hermDual T ‚àß M.hermDual T ‚â§ 1) := by
  rcases hT with ‚ü®hT‚ÇÅ, hT‚ÇÇ‚ü©
  have hT_psd := HermitianMat.zero_le_iff.mp hT‚ÇÅ
  use M.hermDual.pos_Hermitian hT‚ÇÅ
  simpa using ContinuousOrderHomClass.map_monotone M.hermDual hT‚ÇÇ

/-- The defining property of a dual channel, as specialized to `MState.exp_val`. -/
theorem exp_val_hermDual (‚Ñ∞ : PTPMap dIn dOut) (œÅ : MState dIn) (T : HermitianMat dOut ‚ÑÇ) :
    (‚Ñ∞ œÅ).exp_val T  = œÅ.exp_val (‚Ñ∞.hermDual T) := by
  simp only [MState.exp_val]
  apply HPMap.inner_hermDual'

end PTPMap

end hermDual


================================================================================
FILE: QuantumInfo/Finite/CPTPMap/MatrixMap.lean
TYPE: Lean 4
SIZE: 11657 characters
================================================================================

import Mathlib.LinearAlgebra.TensorProduct.Matrix
import Mathlib.LinearAlgebra.PiTensorProduct
import Mathlib.Data.Set.Card
import Mathlib.Algebra.Module.LinearMap.Basic
import QuantumInfo.ForMathlib
import QuantumInfo.Finite.Braket
import QuantumInfo.Finite.MState

/-! # Linear maps of matrices

This file works with `MatrixMap`s, that is, linear maps from square matrices to square matrices.
Although this is just a shorthand for `Matrix A A R ‚Üí‚Çó[R] Matrix B B R`, there are several
concepts that specifically make sense in this context.

 * `toMatrix` is the rectangular "transfer matrix", where matrix multiplication commutes with map composition.
 * `choi_matrix` is the square "Choi matrix", see `MatrixMap.choi_PSD_iff_CP_map` for example usage
 * `kron` is the Kronecker product of matrix maps
 * `IsTracePreserving` states the trace of the output is always equal to the trace of the input.

We provide simp lemmas for relating these facts, prove basic facts e.g. composition and identity, and some facts
about `IsTracePreserving` maps.
-/

/-- A `MatrixMap` is a linear map between squares matrices of size A to size B, over R. -/
abbrev MatrixMap (A B R : Type*) [Semiring R] := Matrix A A R ‚Üí‚Çó[R] Matrix B B R

variable {A B C D E F R : Type*} [Fintype A] [Semiring R] [DecidableEq A]

namespace MatrixMap
section matrix

variable (A R) in
/-- Alias of LinearMap.id, but specifically as a MatrixMap. -/
@[reducible]
def id : MatrixMap A A R := LinearMap.id

/-- Choi matrix of a given linear matrix map. Note that this is defined even for things that
  aren't CPTP, it's just rarely talked about in those contexts. This is the inverse of
  `MatrixMap.of_choi_matrix`. Compare with `MatrixMap.toMatrix`, which gives the transfer matrix. -/
def choi_matrix (M : MatrixMap A B R) : Matrix (B √ó A) (B √ó A) R :=
  fun (j‚ÇÅ,i‚ÇÅ) (j‚ÇÇ,i‚ÇÇ) ‚Ü¶ M (Matrix.single i‚ÇÅ i‚ÇÇ 1) j‚ÇÅ j‚ÇÇ

/-- Given the Choi matrix, generate the corresponding R-linear map between matrices as a
MatrixMap. This is the inverse of `MatrixMap.choi_matrix`. -/
def of_choi_matrix (M : Matrix (B √ó A) (B √ó A) R) : MatrixMap A B R where
  toFun X := fun b‚ÇÅ b‚ÇÇ ‚Ü¶ ‚àë (a‚ÇÅ : A), ‚àë (a‚ÇÇ : A), X a‚ÇÅ a‚ÇÇ * M (b‚ÇÅ, a‚ÇÅ) (b‚ÇÇ, a‚ÇÇ)
  map_add' x y := by funext b‚ÇÅ b‚ÇÇ; simp [add_mul, Finset.sum_add_distrib]
  map_smul' r x := by
    funext b‚ÇÅ b‚ÇÇ
    simp only [Matrix.smul_apply, smul_eq_mul, RingHom.id_apply, Finset.mul_sum, mul_assoc]

/-- Proves that `MatrixMap.of_choi_matrix` and `MatrixMap.choi_matrix` inverses. -/
@[simp]
theorem map_choi_inv (M : Matrix (B √ó A) (B √ó A) R) : choi_matrix (of_choi_matrix M) = M := by
  ext ‚ü®i‚ÇÅ,i‚ÇÇ‚ü© ‚ü®j‚ÇÅ,j‚ÇÇ‚ü©
  simp [of_choi_matrix, choi_matrix, Matrix.single, ite_and]

/-- Proves that `MatrixMap.choi_matrix` and `MatrixMap.of_choi_matrix` inverses. -/
@[simp]
theorem choi_map_inv (M : MatrixMap A B R) : of_choi_matrix (choi_matrix M) = M := by
  sorry

/-- The correspondence induced by `MatrixMap.of_choi_matrix` is injective. -/
theorem choi_matrix_inj : Function.Injective (@choi_matrix A B R _ _) := by
  intro x y h
  simpa only [choi_map_inv] using congrArg of_choi_matrix h

variable {R : Type*} [CommSemiring R]

/-- The linear equivalence between MatrixMap's and transfer matrices on a larger space.
Compare with `MatrixMap.choi_matrix`, which gives the Choi matrix instead of the transfer matrix. -/
noncomputable def toMatrix [Fintype B] : MatrixMap A B R ‚âÉ‚Çó[R] Matrix (B √ó B) (A √ó A) R :=
  LinearMap.toMatrix (Matrix.stdBasis R A A) (Matrix.stdBasis R B B)

/-- Multiplication of transfer matrices, `MatrixMap.toMatrix`, is equivalent to composition of maps. -/
theorem toMatrix_comp [Fintype B] [Fintype C] [DecidableEq B] (M‚ÇÅ : MatrixMap A B R) (M‚ÇÇ : MatrixMap B C R) : toMatrix (M‚ÇÇ ‚àò‚Çó M‚ÇÅ) = (toMatrix M‚ÇÇ) * (toMatrix M‚ÇÅ) :=
  LinearMap.toMatrix_comp _ _ _ M‚ÇÇ M‚ÇÅ

end matrix

section kraus

variable [SMulCommClass R R R] [Star R]
variable {Œ∫ : Type*} [Fintype Œ∫]

/-- Construct a matrix map out of families of matrices M N : Œ£ ‚Üí Matrix B A R
indexed by Œ∫ via X ‚Ü¶ ‚àë k : Œ∫, (M k) * X * (N k)·¥¥ -/
def of_kraus (M N : Œ∫ ‚Üí Matrix B A R) : MatrixMap A B R :=
  ‚àë k : Œ∫, {
    toFun X := M k * X * (N k).conjTranspose
    map_add' x y := by rw [Matrix.mul_add, Matrix.add_mul]
    map_smul' r x := by rw [RingHom.id_apply, Matrix.mul_smul, Matrix.smul_mul]
  }

def exists_kraus (Œ¶ : MatrixMap A B R) : ‚àÉ r : ‚Ñï, ‚àÉ (M N : Fin r ‚Üí Matrix B A R), Œ¶ = of_kraus M N :=
  sorry

end kraus

section kron
open Kronecker

variable {A B C D R : Type*} [Fintype A] [Fintype B] [Fintype C] [Fintype D]
variable [DecidableEq A] [DecidableEq C]

/-- The Kronecker product of MatrixMaps. Defined here using `TensorProduct.map M‚ÇÅ M‚ÇÇ`, with appropriate
reindexing operations and `LinearMap.toMatrix`/`Matrix.toLin`. Notation `‚äó‚Çñ‚Çò`. -/
noncomputable def kron [CommSemiring R] (M‚ÇÅ : MatrixMap A B R) (M‚ÇÇ : MatrixMap C D R) : MatrixMap (A √ó C) (B √ó D) R :=
  let h‚ÇÅ := (LinearMap.toMatrix (Module.Basis.tensorProduct  (Matrix.stdBasis R A A) (Matrix.stdBasis R C C))
      (Module.Basis.tensorProduct  (Matrix.stdBasis R B B) (Matrix.stdBasis R D D)))
    (TensorProduct.map M‚ÇÅ M‚ÇÇ);
  let r‚ÇÅ := Equiv.prodProdProdComm B B D D;
  let r‚ÇÇ := Equiv.prodProdProdComm A A C C;
  let h‚ÇÇ := Matrix.reindex r‚ÇÅ r‚ÇÇ h‚ÇÅ;
  Matrix.toLin (Matrix.stdBasis R (A √ó C) (A √ó C)) (Matrix.stdBasis R (B √ó D) (B √ó D)) h‚ÇÇ

scoped[MatrixMap] infixl:100 " ‚äó‚Çñ‚Çò " => MatrixMap.kron

/-- The extensional definition of the Kronecker product `MatrixMap.kron`, in terms of the entries of its image. -/
theorem kron_def [CommRing R] (M‚ÇÅ : MatrixMap A B R) (M‚ÇÇ : MatrixMap C D R) (M : Matrix (A √ó C) (A √ó C) R) : (M‚ÇÅ ‚äó‚Çñ‚Çò M‚ÇÇ) M (b‚ÇÅ, d‚ÇÅ) (b‚ÇÇ, d‚ÇÇ) =
  ‚àë a‚ÇÅ, ‚àë a‚ÇÇ, ‚àë c‚ÇÅ, ‚àë c‚ÇÇ, (M‚ÇÅ (Matrix.single a‚ÇÅ a‚ÇÇ 1) b‚ÇÅ b‚ÇÇ) * (M‚ÇÇ (Matrix.single c‚ÇÅ c‚ÇÇ 1) d‚ÇÅ d‚ÇÇ) * (M (a‚ÇÅ, c‚ÇÅ) (a‚ÇÇ, c‚ÇÇ)) := by
  rw [kron, TensorProduct.toMatrix_map]
  simp
  rw [Matrix.toLin_apply]
  simp [Equiv.prodProdProdComm, Matrix.kroneckerMap, Matrix.submatrix, LinearMap.toMatrix]
  simp [Matrix.stdBasis_eq_single]
  sorry

section kron_lemmas
variable [CommSemiring R]

theorem add_kron (ML‚ÇÅ ML‚ÇÇ : MatrixMap A B R) (MR : MatrixMap C D R) : (ML‚ÇÅ + ML‚ÇÇ) ‚äó‚Çñ‚Çò MR = ML‚ÇÅ ‚äó‚Çñ‚Çò MR + ML‚ÇÇ ‚äó‚Çñ‚Çò MR := by
  simp [kron, TensorProduct.map_add_left, Matrix.submatrix_add]

theorem kron_add (ML : MatrixMap A B R) (MR‚ÇÅ MR‚ÇÇ : MatrixMap C D R) : ML ‚äó‚Çñ‚Çò (MR‚ÇÅ + MR‚ÇÇ) = ML ‚äó‚Çñ‚Çò MR‚ÇÅ + ML ‚äó‚Çñ‚Çò  MR‚ÇÇ := by
  simp [kron, TensorProduct.map_add_right, Matrix.submatrix_add]

theorem smul_kron (r : R) (ML : MatrixMap A B R) (MR : MatrixMap C D R) : (r ‚Ä¢ ML) ‚äó‚Çñ‚Çò MR = r ‚Ä¢ (ML ‚äó‚Çñ‚Çò MR) := by
  simp [kron, TensorProduct.map_smul_left, Matrix.submatrix_smul]

theorem kron_smul (r : R) (ML : MatrixMap A B R) (MR : MatrixMap C D R) : ML ‚äó‚Çñ‚Çò (r ‚Ä¢ MR) = r ‚Ä¢ (ML ‚äó‚Çñ‚Çò MR) := by
  simp [kron, TensorProduct.map_smul_right, Matrix.submatrix_smul]

@[simp]
theorem zero_kron (MR : MatrixMap C D R) : (0 : MatrixMap A B R) ‚äó‚Çñ‚Çò MR = 0 := by
  simp [kron]

@[simp]
theorem kron_zero (ML : MatrixMap A B R) : ML ‚äó‚Çñ‚Çò (0 : MatrixMap C D R) = 0 := by
  simp [kron]

variable [DecidableEq B] in
theorem kron_id_id : (id A R ‚äó‚Çñ‚Çò id B R) = id (A √ó B) R := by
  simp [kron]

variable {Dl‚ÇÅ Dl‚ÇÇ Dl‚ÇÉ Dr‚ÇÅ Dr‚ÇÇ Dr‚ÇÉ : Type*}
  [Fintype Dl‚ÇÅ] [Fintype Dl‚ÇÇ] [Fintype Dl‚ÇÉ] [Fintype Dr‚ÇÅ] [Fintype Dr‚ÇÇ] [Fintype Dr‚ÇÉ]
  [DecidableEq Dl‚ÇÅ] [DecidableEq Dl‚ÇÇ] [DecidableEq Dr‚ÇÅ] [DecidableEq Dr‚ÇÇ] in
/-- For maps L‚ÇÅ, L‚ÇÇ, R‚ÇÅ, and R‚ÇÇ, the product (L‚ÇÇ ‚àò‚Çó L‚ÇÅ) ‚äó‚Çñ‚Çò (R‚ÇÇ ‚àò‚Çó R‚ÇÅ) = (L‚ÇÇ ‚äó‚Çñ‚Çò R‚ÇÇ) ‚àò‚Çó (L‚ÇÅ ‚äó‚Çñ‚Çò R‚ÇÅ) -/
theorem kron_comp_distrib (L‚ÇÅ : MatrixMap Dl‚ÇÅ Dl‚ÇÇ R) (L‚ÇÇ : MatrixMap Dl‚ÇÇ Dl‚ÇÉ R) (R‚ÇÅ : MatrixMap Dr‚ÇÅ Dr‚ÇÇ R)
    (R‚ÇÇ : MatrixMap Dr‚ÇÇ Dr‚ÇÉ R) : (L‚ÇÇ ‚àò‚Çó L‚ÇÅ) ‚äó‚Çñ‚Çò (R‚ÇÇ ‚àò‚Çó R‚ÇÅ) = (L‚ÇÇ ‚äó‚Çñ‚Çò R‚ÇÇ) ‚àò‚Çó (L‚ÇÅ ‚äó‚Çñ‚Çò R‚ÇÅ) := by
  simp [kron, TensorProduct.map_comp, ‚Üê Matrix.toLin_mul, Matrix.submatrix_mul_equiv, ‚Üê LinearMap.toMatrix_comp]

end kron_lemmas

-- /-- The canonical tensor product on linear maps between matrices, where a map from
--   M[A,B] to M[C,D] is given by M[A√óC,B√óD]. This tensor product acts independently on
--   Kronecker products and gives Kronecker products as outputs. -/
-- def matrixMap_kron (M‚ÇÅ : Matrix (A‚ÇÅ √ó B‚ÇÅ) (C‚ÇÅ √ó D‚ÇÅ) R) (M‚ÇÇ : Matrix (A‚ÇÇ √ó B‚ÇÇ) (C‚ÇÇ √ó D‚ÇÇ) R) : Matrix ((A‚ÇÅ √ó A‚ÇÇ) √ó (B‚ÇÅ √ó B‚ÇÇ)) ((C‚ÇÅ √ó C‚ÇÇ) √ó (D‚ÇÅ √ó D‚ÇÇ)) R :=
--   Matrix.of fun ((a‚ÇÅ, a‚ÇÇ), (b‚ÇÅ, b‚ÇÇ)) ((c‚ÇÅ, c‚ÇÇ), (d‚ÇÅ, d‚ÇÇ)) ‚Ü¶
--     (M‚ÇÅ (a‚ÇÅ, b‚ÇÅ) (c‚ÇÅ, d‚ÇÅ)) * (M‚ÇÇ (a‚ÇÇ, b‚ÇÇ) (c‚ÇÇ, d‚ÇÇ))

/-- The operational definition of the Kronecker product `MatrixMap.kron`, that it maps a Kronecker product of
inputs to the Kronecker product of outputs. It is the unique bilinear map doing so. -/
theorem kron_map_of_kron_state [CommRing R] (M‚ÇÅ : MatrixMap A B R) (M‚ÇÇ : MatrixMap C D R) (MA : Matrix A A R) (MC : Matrix C C R) : (M‚ÇÅ ‚äó‚Çñ‚Çò M‚ÇÇ) (MA ‚äó‚Çñ MC) = (M‚ÇÅ MA) ‚äó‚Çñ (M‚ÇÇ MC) := by
  ext bd‚ÇÅ bd‚ÇÇ
  let (b‚ÇÅ, d‚ÇÅ) := bd‚ÇÅ
  let (b‚ÇÇ, d‚ÇÇ) := bd‚ÇÇ
  rw [kron_def]
  simp only [Matrix.kroneckerMap_apply]
  simp_rw [mul_assoc, ‚Üê Finset.mul_sum]
  simp_rw [mul_comm (M‚ÇÇ _ _ _), mul_assoc, ‚Üê Finset.mul_sum, ‚Üê mul_assoc]
  simp_rw [‚Üê Finset.sum_mul]
  congr
  -- simp_rw [‚Üê Matrix.stdBasis_eq_stdBasisMatrix ]
  -- unfold Matrix.stdBasisMatrix
  -- simp_rw [‚Üê LinearMap.sum_apply]
  -- simp
  sorry
  sorry

theorem choi_matrix_state_rep {B : Type*} [Fintype B] [Nonempty A] (M : MatrixMap A B ‚ÑÇ) :
  M.choi_matrix = (‚Üë(Fintype.card (Œ± := A)) : ‚ÑÇ) ‚Ä¢ (M ‚äó‚Çñ‚Çò (LinearMap.id : MatrixMap A A ‚ÑÇ)) (MState.pure (Ket.MES A)).m := by
  ext i j
  simp [choi_matrix, kron_def M, Ket.MES, Ket.apply, Finset.mul_sum]
  conv =>
    rhs
    conv =>
      enter [2, x, 2, a_1]
      conv =>
        enter [2, a_2]
        simp [apply_ite]
      simp only [Finset.sum_ite_eq, Finset.mem_univ, ‚ÜìreduceIte]
      rw [‚Üê mul_inv, ‚Üê Complex.ofReal_mul, ‚Üê Real.sqrt_mul (Fintype.card A).cast_nonneg',
        Real.sqrt_mul_self (Fintype.card A).cast_nonneg', mul_comm, mul_assoc]
      simp
      conv =>
        right
        rw [Matrix.single, Matrix.of_apply]
        enter [1]
        rw [and_comm]
      simp [apply_ite, ite_and]
    conv =>
      enter [2, x]
      simp [Finset.sum_ite]
    simp [Finset.sum_ite]

end kron

section pi
section basis

--Missing from Mathlib

variable {Œπ : Type*}
variable {R : Type*} [CommSemiring R]
variable {s : Œπ ‚Üí Type*} [‚àÄ i, AddCommMonoid (s i)] [‚àÄ i, Module R (s i)]
variable {L : Œπ ‚Üí Type* }

/-- Like `Basis.tensorProduct`, but for `PiTensorProduct` -/
noncomputable def _root_.Module.Basis.piTensorProduct [‚àÄi, Fintype (L i)]
    (b : (i:Œπ) ‚Üí Module.Basis (L i) R (s i)) :
      Module.Basis ((i:Œπ) ‚Üí L i) R (PiTensorProduct R s) :=
  Finsupp.basisSingleOne.map sorry

end basis

variable {R : Type*} [CommSemiring R]
variable {Œπ : Type u} [DecidableEq Œπ] [fŒπ : Fintype Œπ]
variable {dI : Œπ ‚Üí Type v} [‚àÄi, Fintype (dI i)] [‚àÄi, DecidableEq (dI i)]
variable {dO : Œπ ‚Üí Type w} [‚àÄi, Fintype (dO i)] [‚àÄi, DecidableEq (dO i)]

/-- Finite Pi-type tensor product of MatrixMaps. Defined as `PiTensorProduct.tprod` of the underlying
Linear maps. Notation `‚®Ç‚Çú‚Çò[R] i, f i`, eventually. -/
noncomputable def piKron (Œõi : ‚àÄ i, MatrixMap (dI i) (dO i) R) : MatrixMap (‚àÄi, dI i) (‚àÄi, dO i) R :=
  let map‚ÇÅ := PiTensorProduct.map Œõi;
  let map‚ÇÇ := LinearMap.toMatrix
    (Module.Basis.piTensorProduct (fun i ‚Ü¶ Matrix.stdBasis R (dI i) (dI i)))
    (Module.Basis.piTensorProduct (fun i ‚Ü¶ Matrix.stdBasis R (dO i) (dO i))) map‚ÇÅ
  let r‚ÇÅ : ((i : Œπ) ‚Üí dO i √ó dO i) ‚âÉ ((i : Œπ) ‚Üí dO i) √ó ((i : Œπ) ‚Üí dO i) := Equiv.arrowProdEquivProdArrow _ dO dO
  let r‚ÇÇ : ((i : Œπ) ‚Üí dI i √ó dI i) ‚âÉ ((i : Œπ) ‚Üí dI i) √ó ((i : Œπ) ‚Üí dI i) := Equiv.arrowProdEquivProdArrow _ dI dI
  let map‚ÇÉ := Matrix.reindex r‚ÇÅ r‚ÇÇ map‚ÇÇ;
  Matrix.toLin
    (Matrix.stdBasis R ((i:Œπ) ‚Üí dI i) ((i:Œπ) ‚Üí dI i))
    (Matrix.stdBasis R ((i:Œπ) ‚Üí dO i) ((i:Œπ) ‚Üí dO i)) map‚ÇÉ

-- notation3:100 "‚®Ç‚Çú‚Çò "(...)", "r:(scoped f => tprod R f) => r
-- syntax (name := bigsum) "‚àë " bigOpBinders ("with " term)? ", " term:67 : term

end pi


================================================================================
FILE: QuantumInfo/Finite/CPTPMap/Unbundled.lean
TYPE: Lean 4
SIZE: 14081 characters
================================================================================

import QuantumInfo.Finite.CPTPMap.MatrixMap

/-! # Properties of Matrix Maps

Building on `MatrixMap`s, this defines the properties: `IsTracePreserving`, `Unital`,
`IsHermitianPreserving`, `IsPositive` and `IsCompletelyPositive`. They have basic facts
such as closure under composition, addition, and scaling.

These are the *unbundled* versions, which just state the relevant properties of a given `MatrixMap`.
The bundled versions are `HPMap`, `UnitalMap`, `TPMap`, `PMap`, and `CPMap` respectively, given
in Bundled.lean.
-/

namespace MatrixMap

section tp
variable [Fintype A] [DecidableEq A] [Fintype B] [Fintype C] [Semiring R]

/-- A linear matrix map is *trace preserving* if trace of the output equals trace of the input. -/
def IsTracePreserving (M : MatrixMap A B R) : Prop :=
  ‚àÄ (x : Matrix A A R), (M x).trace = x.trace

/-- A map is trace preserving iff the partial trace of the Choi matrix is the identity. -/
theorem IsTracePreserving_iff_trace_choi (M : MatrixMap A B R) : M.IsTracePreserving
    ‚Üî M.choi_matrix.traceLeft = 1 := by
  constructor
  ¬∑ intro h
    ext a‚ÇÅ a‚ÇÇ
    replace h := h (Matrix.single a‚ÇÅ a‚ÇÇ 1)
    simp_rw [Matrix.trace, Matrix.diag] at h
    simp only [Matrix.traceLeft, choi_matrix, Matrix.of_apply, h]
    simp only [Matrix.single, Matrix.of_apply, Finset.sum_boole, Matrix.one_apply]
    have : (fun x => a‚ÇÅ = x ‚àß a‚ÇÇ = x) = (fun x => a‚ÇÅ = a‚ÇÇ ‚àß a‚ÇÇ = x) := by
      funext x
      rw [eq_iff_iff, and_congr_left_iff]
      rintro rfl
      trivial
    split_ifs with h
    <;> simp [this, h, Finset.filter_eq]
  ¬∑ intro h X
    replace h := fun (a‚ÇÅ a‚ÇÇ : A) ‚Ü¶ congrFun‚ÇÇ h a‚ÇÅ a‚ÇÇ
    simp [Matrix.traceLeft, Matrix.trace] at h ‚ä¢
    rw [‚Üê M.choi_map_inv, of_choi_matrix]
    dsimp
    rw [Finset.sum_comm_cycle, Finset.sum_comm_cycle]
    simp_rw [‚Üê Finset.mul_sum, h, Matrix.one_apply]
    simp

namespace IsTracePreserving

variable {A : Type*} [Fintype A] in
/-- Simp lemma: the trace of the image of a IsTracePreserving map is the same as the original trace. -/
@[simp]
theorem apply_trace {M : MatrixMap A B R} (h : M.IsTracePreserving) (œÅ : Matrix A A R)
    : (M œÅ).trace = œÅ.trace :=
  h œÅ

/-- The trace of a Choi matrix of a TP map is the cardinality of the input space. -/
theorem trace_choi {M : MatrixMap A B R} (h : M.IsTracePreserving) :
    M.choi_matrix.trace = (Finset.univ (Œ± := A)).card := by
  rw [‚Üê Matrix.traceLeft_trace, (IsTracePreserving_iff_trace_choi M).mp h,
    Matrix.trace_one, Finset.card_univ]

variable {A : Type*} [Fintype A] in
/-- The composition of IsTracePreserving maps is also trace preserving. -/
theorem comp {M‚ÇÅ : MatrixMap A B R} {M‚ÇÇ : MatrixMap B C R} (h‚ÇÅ : M‚ÇÅ.IsTracePreserving) (h‚ÇÇ : M‚ÇÇ.IsTracePreserving) :
    IsTracePreserving (M‚ÇÇ ‚àò‚Çó M‚ÇÅ) := by
  intro x
  simp [h‚ÇÇ _, h‚ÇÅ _]

variable {A : Type*} [Fintype A] in
/-- The identity MatrixMap IsTracePreserving. -/
@[simp]
theorem id : (id A R).IsTracePreserving := by
  simp [IsTracePreserving, MatrixMap.id]

variable {A R : Type*} [CommSemiring R] [Fintype A] in
/-- Unit linear combinations of IsTracePreserving maps are IsTracePreserving. -/
theorem unit_linear {M‚ÇÅ M‚ÇÇ : MatrixMap A B R} {x y : R}
    (h‚ÇÅ : M‚ÇÅ.IsTracePreserving) (h‚ÇÇ : M‚ÇÇ.IsTracePreserving) (hxy : x + y = 1) :
    (x ‚Ä¢ M‚ÇÅ + y ‚Ä¢ M‚ÇÇ).IsTracePreserving := by
  rw [IsTracePreserving] at h‚ÇÅ h‚ÇÇ ‚ä¢
  simp [h‚ÇÅ, h‚ÇÇ, ‚Üê add_mul, hxy]

variable {D R : Type*} [CommSemiring R] [DecidableEq C] [Fintype D] in
/-- The kronecker product of IsTracePreserving maps is also trace preserving. -/
theorem kron {M‚ÇÅ : MatrixMap A B R} {M‚ÇÇ : MatrixMap C D R} (h‚ÇÅ : M‚ÇÅ.IsTracePreserving) (h‚ÇÇ : M‚ÇÇ.IsTracePreserving) :
    (M‚ÇÅ ‚äó‚Çñ‚Çò M‚ÇÇ).IsTracePreserving := by
  unfold MatrixMap.kron
  intro x
  simp
  sorry

variable [CommSemiring S] [Star S] [SMulCommClass S S S] in
/-- The channel X ‚Ü¶ ‚àë k : Œ∫, (M k) * X * (N k)·¥¥ formed by Kraus operators M, N : Œ∫ ‚Üí Matrix B A R
is trace-preserving if ‚àë k : Œ∫, (N k)·¥¥ * (M k) = 1 -/
theorem of_kraus_isTracePreserving {Œ∫ : Type*} [Fintype Œ∫]
  (M N : Œ∫ ‚Üí Matrix B A S)
  (hTP : (‚àë k, (N k).conjTranspose * (M k)) = 1) :
  (MatrixMap.of_kraus M N).IsTracePreserving := by
  intro x
  simp only [of_kraus, LinearMap.coeFn_sum, LinearMap.coe_mk, AddHom.coe_mk, Finset.sum_apply,
    Matrix.trace_sum]
  conv =>
    enter [1,2,i]
    rw [Matrix.trace_mul_cycle (M i) x (N i).conjTranspose]
  rw [‚Üê Matrix.trace_sum, ‚Üê Finset.sum_mul, hTP, one_mul]

end IsTracePreserving
end tp


section unital

variable [DecidableEq A] [DecidableEq B] [Semiring R]

/-- A linear matrix map is *unital* if it preserves the identity. -/
def Unital (M : MatrixMap A B R) : Prop :=
  M 1 = 1

namespace Unital

variable {M : MatrixMap A B R}

@[simp]
theorem map_1 (h : M.Unital) : M 1 = 1 :=
  h

/-- The identity `MatrixMap` is `Unital`. -/
@[simp]
theorem id : (id A R).Unital := by
  simp [Unital, MatrixMap.id]

--TODO: Closed under composition, kronecker products, it's iff M.choi_matrix.traceLeft = 1...

end Unital
end unital

variable {A B C R : Type*}

open Kronecker
open TensorProduct

open ComplexOrder
variable [RCLike R]

/-- A linear matrix map is *Hermitian preserving* if it maps `IsHermitian` matrices to `IsHermitian`.-/
def IsHermitianPreserving (M : MatrixMap A B R) : Prop :=
  ‚àÄ{x}, x.IsHermitian ‚Üí (M x).IsHermitian

/-- A linear matrix map is *positive* if it maps `PosSemidef` matrices to `PosSemidef`.-/
def IsPositive [Fintype A] [Fintype B] (M : MatrixMap A B R) : Prop :=
  ‚àÄ{x}, x.PosSemidef ‚Üí (M x).PosSemidef

/-- A linear matrix map is *completely positive* if, for any integer n, the tensor product
with `I(n)` is positive. -/
def IsCompletelyPositive [Fintype A] [Fintype B] [DecidableEq A] (M : MatrixMap A B R) : Prop :=
  ‚àÄ (n : ‚Ñï), (M ‚äó‚Çñ‚Çò (LinearMap.id : MatrixMap (Fin n) (Fin n) R)).IsPositive

namespace IsHermitianPreserving

variable {A : Type*} [Fintype A] in
/-- The identity MatrixMap IsHermitianPreserving. -/
theorem id : (id A R).IsPositive :=
  _root_.id

/-- The composition of IsHermitianPreserving maps is also Hermitian preserving. -/
theorem comp {M‚ÇÅ : MatrixMap A B R} {M‚ÇÇ : MatrixMap B C R}
    (h‚ÇÅ : M‚ÇÅ.IsHermitianPreserving) (h‚ÇÇ : M‚ÇÇ.IsHermitianPreserving) : IsHermitianPreserving (M‚ÇÇ ‚àò‚Çó M‚ÇÅ) :=
  fun h ‚Ü¶ h‚ÇÇ (h‚ÇÅ h)

end IsHermitianPreserving

namespace IsPositive
variable [Fintype A] [Fintype B] [Fintype C]

/- Every `MatrixMap` that `IsPositive` is also `IsHermitianPreserving`. -/
theorem IsHermitianPreserving {M : MatrixMap A B R}
    (hM : IsPositive M) : IsHermitianPreserving M := by
  intro x hx
  let xH : HermitianMat _ _ := ‚ü®x, hx‚ü©
  classical --because PosPart requires DecidableEq
  have hMPos := hM (HermitianMat.zero_le_iff.mp xH.zero_le_posPart)
  have hMNeg := hM (HermitianMat.zero_le_iff.mp xH.negPart_le_zero)
  have hSub := hMPos.isHermitian.sub hMNeg.isHermitian
  rw [‚Üê map_sub] at hSub
  convert ‚Üê hSub
  exact HermitianMat.ext_iff.1 (HermitianMat.posPart_add_negPart xH)

/-- The composition of IsPositive maps is also positive. -/
theorem comp {M‚ÇÅ : MatrixMap A B R} {M‚ÇÇ : MatrixMap B C R} (h‚ÇÅ : M‚ÇÅ.IsPositive)
    (h‚ÇÇ : M‚ÇÇ.IsPositive) : IsPositive (M‚ÇÇ ‚àò‚Çó M‚ÇÅ) :=
  fun h ‚Ü¶ h‚ÇÇ (h‚ÇÅ h)

variable {A : Type*} [Fintype A] in
/-- The identity MatrixMap IsPositive. -/
@[simp]
theorem id : (id A R).IsPositive :=
  _root_.id

/-- Sums of IsPositive maps are IsPositive. -/
theorem add {M‚ÇÅ M‚ÇÇ : MatrixMap A B R} (h‚ÇÅ : M‚ÇÅ.IsPositive) (h‚ÇÇ : M‚ÇÇ.IsPositive) :
    (M‚ÇÅ + M‚ÇÇ).IsPositive :=
  fun x ‚Ü¶ Matrix.PosSemidef.add (h‚ÇÅ x) (h‚ÇÇ x)

/-- Nonnegative scalings of IsPositive maps are IsPositive. -/
theorem smul {M : MatrixMap A B R} (hM : M.IsPositive) {x : R} (hx : 0 ‚â§ x) :
    (x ‚Ä¢ M).IsPositive :=
  fun hm ‚Ü¶ (hM hm).smul hx

end IsPositive

namespace IsCompletelyPositive
variable [Fintype A] [Fintype B] [Fintype C] [DecidableEq A]

/-- Definition of a CP map, but with `Fintype T` in the definition instead of a `Fin n`. -/
theorem of_Fintype  {M : MatrixMap A B R} (h : IsCompletelyPositive M)
    (T : Type*) [Fintype T] [DecidableEq T] :
    (M.kron (LinearMap.id : MatrixMap T T R)).IsPositive := by
  sorry

/- Every `MatrixMap` that `IsCompletelyPositive` also `IsPositiveMap`. -/
theorem IsPositive [DecidableEq A] {M : MatrixMap A B R}
    (hM : IsCompletelyPositive M) : IsPositive M := by
  intro x hx
  let x' : Matrix (A √ó Fin 1) (A √ó Fin 1) R := x ‚äó‚Çñ 1
  let eqA : (A √ó Fin 1) ‚âÉ A :=
    (Equiv.prodCongrRight (fun _ ‚Ü¶ finOneEquiv)).trans (Equiv.prodPUnit A)
  let eqB : (B √ó Fin 1) ‚âÉ B :=
    (Equiv.prodCongrRight (fun _ ‚Ü¶ finOneEquiv)).trans (Equiv.prodPUnit B)
  specialize @hM 1 (x.submatrix eqA eqA) (Matrix.PosSemidef.submatrix hx _)
  replace hM := Matrix.PosSemidef.submatrix hM eqB.symm
  convert hM
  sorry

/-- The composition of IsCompletelyPositive maps is also completely positive. -/
theorem comp [DecidableEq B] {M‚ÇÅ : MatrixMap A B R} {M‚ÇÇ : MatrixMap B C R} (h‚ÇÅ : M‚ÇÅ.IsCompletelyPositive)
    (h‚ÇÇ : M‚ÇÇ.IsCompletelyPositive) : IsCompletelyPositive (M‚ÇÇ ‚àò‚Çó M‚ÇÅ) := by
  --sketch: (M‚ÇÇ ‚àò‚Çó M‚ÇÅ) ‚äó‚Çñ‚Çò id[n] = (M‚ÇÇ ‚äó‚Çñ‚Çò id[n]) ‚àò‚Çó (M‚ÇÅ ‚äó‚Çñ‚Çò id[n]), which is a composition of positive maps.
  intro n x hx
  specialize h‚ÇÅ n hx
  specialize h‚ÇÇ n h‚ÇÅ
  conv in LinearMap.id =>
    change LinearMap.id ‚àò‚Çó LinearMap.id
  rw [kron_comp_distrib]
  simpa using h‚ÇÇ

/-- The identity MatrixMap IsCompletelyPositive. -/
@[simp]
theorem id : (id A R).IsCompletelyPositive := by
  intro n œÅ h
  rwa [show LinearMap.id = MatrixMap.id (Fin n) R from rfl, kron_id_id]

/-- Sums of IsCompletelyPositive maps are IsCompletelyPositive. -/
theorem add {M‚ÇÅ M‚ÇÇ : MatrixMap A B R} (h‚ÇÅ : M‚ÇÅ.IsCompletelyPositive) (h‚ÇÇ : M‚ÇÇ.IsCompletelyPositive) :
    (M‚ÇÅ + M‚ÇÇ).IsCompletelyPositive :=
  fun n _ h ‚Ü¶ by
  simpa only [add_kron] using Matrix.PosSemidef.add (h‚ÇÅ n h) (h‚ÇÇ n h)

/-- Nonnegative scalings of `IsCompletelyPositive` maps are `IsCompletelyPositive`. -/
theorem smul {M : MatrixMap A B R} (hM : M.IsCompletelyPositive) {x : R} (hx : 0 ‚â§ x) :
    (x ‚Ä¢ M).IsCompletelyPositive :=
  fun n œÅ h ‚Ü¶ by
    rw [MatrixMap.smul_kron]
    exact (hM n h).smul hx

variable (A B) in
/-- The zero map `IsCompletelyPositive`. -/
theorem zero : (0 : MatrixMap A B R).IsCompletelyPositive :=
  fun _ _ _ ‚Ü¶ by simpa using Matrix.PosSemidef.zero

/-- A finite sum of completely positive maps is completely positive. -/
theorem finset_sum {Œπ : Type*} [Fintype Œπ] {m : Œπ ‚Üí MatrixMap A B R} (hm : ‚àÄ i, (m i).IsCompletelyPositive) :
    (‚àë i, m i).IsCompletelyPositive :=
  Finset.sum_induction m _ (fun _ _ ‚Ü¶ add) (.zero A B) (by simpa)

variable [Fintype d] [DecidableEq d]
/-- The map that takes M and returns M ‚äó‚Çñ C, where C is positive semidefinite, is a completely positive map. -/
theorem kron_kronecker_const {C : Matrix d d R} (h : C.PosSemidef) {h‚ÇÅ h‚ÇÇ : _} : MatrixMap.IsCompletelyPositive
    (‚ü®‚ü®fun M => M ‚äó‚Çñ C, h‚ÇÅ‚ü©, h‚ÇÇ‚ü© : MatrixMap A (A √ó d) R) := by
  sorry

/-- Choi's theorem on completely positive maps: A map `IsCompletelyPositive` iff its Choi Matrix is PSD. -/
theorem _root_.MatrixMap.choi_PSD_iff_CP_map [DecidableEq A] (M : MatrixMap A B ‚ÑÇ) :
    M.IsCompletelyPositive ‚Üî M.choi_matrix.PosSemidef := by
  by_cases hA : Nonempty A
  ¬∑ constructor
    ¬∑ intro hcp
      rw [choi_matrix_state_rep]
      apply Matrix.PosSemidef.smul _ (ha := by positivity)
      exact of_Fintype hcp A (MState.pure (Ket.MES A)).pos
    ¬∑ sorry
  ¬∑ simp at hA
    have : M = 0 := Subsingleton.elim M 0
    subst M
    have hx (x : B √ó A ‚Üí ‚ÑÇ) : x = 0 := Subsingleton.elim x 0
    simp [Matrix.PosSemidef, Matrix.IsHermitian, IsCompletelyPositive,
      MatrixMap.IsPositive, hx]
    ext
    simp [choi_matrix] --TODO: `choi_matrix 0 = 0` as simp

/-- The act of conjugating (not necessarily by a unitary, just by any matrix at all) is completely positive. -/
theorem conj_isCompletelyPositive (M : Matrix B A R) :
  IsCompletelyPositive {
    toFun := fun (x : Matrix A A R) ‚Ü¶ M * x * M.conjTranspose,
    map_add' x y := by rw [Matrix.mul_add, Matrix.add_mul]
    map_smul' r x := by rw [RingHom.id_apply, Matrix.mul_smul, Matrix.smul_mul]
  } := by
  sorry

/-- The channel X ‚Ü¶ ‚àë k : Œ∫, (M k) * X * (M k)·¥¥ formed by Kraus operators M : Œ∫ ‚Üí Matrix B A R
is completely positive -/
theorem of_kraus_isCompletelyPositive {Œ∫ : Type*} [Fintype Œ∫] (M : Œ∫ ‚Üí Matrix B A R) :
    (MatrixMap.of_kraus M M).IsCompletelyPositive := by
  rw [of_kraus]
  exact finset_sum (fun i ‚Ü¶ conj_isCompletelyPositive (M i))

def exists_kraus (Œ¶ : MatrixMap A B R) (hCP : Œ¶.IsCompletelyPositive) :
    ‚àÉ r : ‚Ñï, ‚àÉ (M : Fin r ‚Üí Matrix B A R), Œ¶ = of_kraus M M :=
  sorry

/-- The Kronecker product of IsCompletelyPositive maps is also completely positive. -/
theorem kron [DecidableEq C] [Fintype D] {M‚ÇÅ : MatrixMap A B R} {M‚ÇÇ : MatrixMap C D R}
    (h‚ÇÅ : M‚ÇÅ.IsCompletelyPositive) (h‚ÇÇ : M‚ÇÇ.IsCompletelyPositive) : IsCompletelyPositive (M‚ÇÅ ‚äó‚Çñ‚Çò M‚ÇÇ) := by
--sketch: the Choi matrix of the Kron is the Kron of the Choi matrix, and Kron of PSD matrices is PSD.
/-
      intro n M hM
      let M' : Matrix (dI‚ÇÅ √ó (dI‚ÇÇ √ó Fin n)) (dI‚ÇÅ √ó (dI‚ÇÇ √ó Fin n)) ‚ÑÇ := sorry --reorder indices of M
      have hM' : M'.PosSemidef := sorry --PSD preserved under reordering
      let Œõ‚ÇÅM := ((Œõ‚ÇÅ.map.kron LinearMap.id) M')
      have hŒõ‚ÇÅM : Œõ‚ÇÅM.PosSemidef := Œõ‚ÇÅ.completely_pos.def_Fintype (dI‚ÇÇ √ó Fin n) hM'
      let Œõ‚ÇÅM' : Matrix (dI‚ÇÇ √ó (dO‚ÇÅ √ó Fin n)) (dI‚ÇÇ √ó (dO‚ÇÅ √ó Fin n)) ‚ÑÇ := sorry --reorder Œõ‚ÇÅM
      have hŒõ‚ÇÅM' : Œõ‚ÇÅM'.PosSemidef := sorry --PSD preserved under reordering
      let Œõ‚ÇÇŒõ‚ÇÅM := (Œõ‚ÇÇ.map.kron LinearMap.id) Œõ‚ÇÅM'
      have hŒõ‚ÇÇŒõ‚ÇÅM : Œõ‚ÇÇŒõ‚ÇÅM.PosSemidef := Œõ‚ÇÇ.completely_pos.def_Fintype (dO‚ÇÅ √ó Fin n) hŒõ‚ÇÅM'
      --PSD preserved under reordering to get (((Œõ‚ÇÅ.map.MatrixMap_Prod Œõ‚ÇÇ.map).MatrixMap_Prod LinearMap.id) M)
      sorry
      -/
  sorry

section piKron

variable {Œπ : Type u} [DecidableEq Œπ] [fŒπ : Fintype Œπ]
variable {dI : Œπ ‚Üí Type v} [‚àÄi, Fintype (dI i)] [‚àÄi, DecidableEq (dI i)]
variable {dO : Œπ ‚Üí Type w} [‚àÄi, Fintype (dO i)] [‚àÄi, DecidableEq (dO i)]

/-- The `piKron` product of IsCompletelyPositive maps is also completely positive. -/
theorem piKron {Œõi : ‚àÄ i, MatrixMap (dI i) (dO i) R} (h‚ÇÅ : ‚àÄ i, (Œõi i).IsCompletelyPositive) :
    IsCompletelyPositive (MatrixMap.piKron Œõi) := by
  sorry

end piKron

end IsCompletelyPositive

end MatrixMap


================================================================================
FILE: QuantumInfo/Finite/CPTPMap.lean
TYPE: Lean 4
SIZE: 208 characters
================================================================================

import QuantumInfo.Finite.CPTPMap.Bundled
import QuantumInfo.Finite.CPTPMap.CPTP
import QuantumInfo.Finite.CPTPMap.Dual
import QuantumInfo.Finite.CPTPMap.MatrixMap
import QuantumInfo.Finite.CPTPMap.Unbundled


================================================================================
FILE: QuantumInfo/Finite/Capacity.lean
TYPE: Lean 4
SIZE: 9233 characters
================================================================================

import Mathlib.Analysis.SpecialFunctions.Log.Base

import QuantumInfo.Finite.Entropy
import QuantumInfo.Finite.CPTPMap
import QuantumInfo.Finite.Distance


/-! # Quantum Capacity

This focuses on defining and proving theorems about the quantum capacity, the maximum asymptotic rate at which quantum information can be coherently transmitted. The precise definition is not consistent in the literature, see [Capacity_doc](./QuantumInfo/Finite/Capacity_doc.html) for a note on what has been used and how that was used to arrive at the following definition:

 1. A channel A `Emulates` another channel B if there are D and E such that D‚àòA‚àòE = B.
 2. A channel A `ŒµApproximates` channel B (of the same dimensions) if the for every state œÅ, the fidelity F(A(œÅ), B(œÅ)) is at least 1-Œµ.
 3. A channel A `AchievesRate` R:‚Ñù if for every Œµ>0, n copies of A emulates some channel B such that log2(dimout(B))/n ‚â• R, and that B is ŒµApproximately the identity.
 4. The `quantumCapacity` of the channel A is the supremum of the achievable rates, i.e. `sSup { R : ‚Ñù | AchievesRate A R }`.

The most basic facts:
 * `emulates_self`: Every channel emulates itself.
 * `emulates_trans`: If A emulates B and B emulates C, then A emulates C. (That is, emulation is an ordering.)
 * `ŒµApproximates A B Œµ` is equivalent to the existence of some Œ¥ (depending Œµ and dims(A)) so that |A-B| has diamond norm at most Œ¥, and Œ¥‚Üí0 as Œµ‚Üí0.
 * `achievesRate_0`: Every channel achievesRate 0. So, the set of achievable rates is Nonempty.
 * If a channel achievesRate R‚ÇÅ, it also every achievesRate R‚ÇÇ every R‚ÇÇ ‚â§ R‚ÇÅ, i.e. it is an interval extending left towards -‚àû. Achievable rates are `¬¨BddBelow`.
 * `bddAbove_achievesRate`: A channel C : dimX ‚Üí dimY cannot achievesRate R with `R > log2(min(dimX, dimY))`. Thus, the interval is `BddAbove`.

The nice lemmas we would want:
 * Capacity of a replacement channel is zero.
 * Capacity of an identity channel is `log2(D)`.
 * Capacity is superadditive under tensor products. (That is, at least additive. Showing that it isn't _exactly_ additive, unlike classical capacity which is additive, is a much harder task.)
 * Capacity of a kth tensor power is exactly k times the capacity of the original channel.
 * Capacity does not decrease under tensor sums.
 * Capacity does not increase under composition.

Then, we should show that our definition is equivalent to some above. Most, except (3), should be not too hard to prove.

Then the LSD theorem establishes that the single-copy coherent information is a lower bound. This is stated in `coherentInfo_le_quantumCapacity`. The corollary, that the n-copy coherent information converges to the capacity, is `quantumCapacity_eq_piProd_coherentInfo`.

# TODO

The only notion of "capacity" here currently is "quantum capacity" in the usual sense. But there are several non-equal capacities relevant to quantum channels, see e.g. [Watrous's notes](https://cs.uwaterloo.ca/~watrous/TQI/TQI.8.pdf) for a list:
 * Quantum capacity (`quantumCapacity`)
 * Quantum 1-shot capacity
 * Entanglement-assisted classical capacity
 * Qss, the quantum side-channel capacity
 * Holevo capacity, aka Holevo œá. The Holevo‚ÄìSchumacher‚ÄìWestmoreland theorem as a major theorem
 * Entanglement-assisted Holevo capacity
 * Entanglement-assisted quantum capacity
 * One- and two-way distillable entanglement

And other important theorems like superdense coding, nonadditivity, superactivation
-/

namespace CPTPMap

variable {d‚ÇÅ d‚ÇÇ d‚ÇÉ d‚ÇÑ d‚ÇÖ d‚ÇÜ : Type*}
variable [Fintype d‚ÇÅ] [Fintype d‚ÇÇ] [Fintype d‚ÇÉ] [Fintype d‚ÇÑ] [Fintype d‚ÇÖ] [Fintype d‚ÇÜ] [DecidableEq d‚ÇÅ] [DecidableEq d‚ÇÇ]

variable [DecidableEq d‚ÇÉ] [DecidableEq d‚ÇÑ] in
/--
A channel Œõ‚ÇÅ `Emulates` another channel Œõ‚ÇÇ if there are D and E such that D‚àòŒõ‚ÇÅ‚àòE = Œõ‚ÇÇ.
-/
def Emulates (Œõ‚ÇÅ : CPTPMap d‚ÇÅ d‚ÇÇ) (Œõ‚ÇÇ : CPTPMap d‚ÇÉ d‚ÇÑ) : Prop :=
  ‚àÉ (E : CPTPMap d‚ÇÉ d‚ÇÅ) (D : CPTPMap d‚ÇÇ d‚ÇÑ), D.compose (Œõ‚ÇÅ.compose E) = Œõ‚ÇÇ

/--
A channel A `ŒµApproximates` channel B of the same dimensions if the for every state œÅ, the fidelity F(A(œÅ), B(œÅ)) is at least 1-Œµ.
-/
def ŒµApproximates (A B : CPTPMap d‚ÇÅ d‚ÇÇ) (Œµ : ‚Ñù) : Prop :=
  ‚àÄ (œÅ : MState d‚ÇÅ), (A œÅ).fidelity (B œÅ) ‚â• 1-Œµ

variable [DecidableEq d‚ÇÇ] in
/--
A channel A `AchievesRate` R:‚Ñù if for every Œµ>0, some n copies of A emulates a channel B such that log2(dimout(B))/n ‚â• R, and that B ŒµApproximates the identity channel.
-/
def AchievesRate (A : CPTPMap d‚ÇÅ d‚ÇÇ) (R : ‚Ñù) : Prop :=
  ‚àÄ Œµ : ‚Ñù, Œµ > 0 ‚Üí
    ‚àÉ (n : ‚Ñï) (dimB : ‚Ñï) (B : CPTPMap (Fin dimB) (Fin dimB)),
      (CPTPMap.piProd (fun (_ : Fin n) ‚Ü¶ A)).Emulates B ‚àß
      Real.logb 2 dimB ‚â• R*n ‚àß
      B.ŒµApproximates CPTPMap.id Œµ

variable [DecidableEq d‚ÇÇ] in
noncomputable def quantumCapacity (A : CPTPMap d‚ÇÅ d‚ÇÇ) : ‚Ñù :=
  sSup { R : ‚Ñù | AchievesRate A R }

section emulates
variable [DecidableEq d‚ÇÇ] [DecidableEq d‚ÇÉ] [DecidableEq d‚ÇÑ] [DecidableEq d‚ÇÖ]

set_option linter.unusedSectionVars false in
/-- Every quantum channel emulates itself. -/
theorem emulates_self (Œõ : CPTPMap d‚ÇÅ d‚ÇÇ) : Œõ.Emulates Œõ :=
  ‚ü®CPTPMap.id, CPTPMap.id, by simp‚ü©

set_option linter.unusedSectionVars false in
/-- If a quantum channel A emulates B, and B emulates C, then A emulates C. -/
theorem emulates_trans (Œõ‚ÇÅ : CPTPMap d‚ÇÅ d‚ÇÇ) (Œõ‚ÇÇ : CPTPMap d‚ÇÉ d‚ÇÑ) (Œõ‚ÇÉ : CPTPMap d‚ÇÖ d‚ÇÜ)
  (h‚ÇÅ‚ÇÇ : Œõ‚ÇÅ.Emulates Œõ‚ÇÇ) (h‚ÇÇ‚ÇÉ : Œõ‚ÇÇ.Emulates Œõ‚ÇÉ) : Œõ‚ÇÅ.Emulates Œõ‚ÇÉ := by
  obtain ‚ü®E‚ÇÅ, D‚ÇÅ, hED‚ÇÅ‚ü© := h‚ÇÅ‚ÇÇ
  obtain ‚ü®E‚ÇÇ, D‚ÇÇ, hED‚ÇÇ‚ü© := h‚ÇÇ‚ÇÉ
  exact ‚ü®E‚ÇÅ.compose E‚ÇÇ, D‚ÇÇ.compose D‚ÇÅ, by classical simp [‚Üê hED‚ÇÅ, ‚Üê hED‚ÇÇ, compose_assoc]‚ü©

end emulates

section ŒµApproximates

/-- Every quantum channel perfectly approximates itself, that is, `ŒµApproximates` with `Œµ = 0`. -/
theorem ŒµApproximates_self (Œõ : CPTPMap d‚ÇÅ d‚ÇÇ) : Œõ.ŒµApproximates Œõ 0 :=
  fun œÅ ‚Ü¶ ((Œõ œÅ).fidelity_self_eq_one.trans (sub_zero 1).symm).ge

/-- If a quantum channel A approximates B with Œµ‚ÇÄ, it also approximates B with all larger Œµ‚ÇÅ. -/
theorem ŒµApproximates_monotone {A B : CPTPMap d‚ÇÅ d‚ÇÇ} {Œµ‚ÇÄ : ‚Ñù} (h : A.ŒµApproximates B Œµ‚ÇÄ)
    {Œµ‚ÇÅ : ‚Ñù} (h‚ÇÇ : Œµ‚ÇÄ ‚â§ Œµ‚ÇÅ) : A.ŒµApproximates B Œµ‚ÇÅ :=
  fun œÅ ‚Ü¶ (tsub_le_tsub_left h‚ÇÇ 1).trans (h œÅ)

end ŒµApproximates

section AchievesRate
variable [DecidableEq d‚ÇÇ]

/-- Every quantum channel achieves a rate of zero. -/
theorem achievesRate_0 (Œõ : CPTPMap d‚ÇÅ d‚ÇÇ) : Œõ.AchievesRate 0 := by
  intro Œµ hŒµ
  let _ : Nonempty (Fin 1) := Fin.pos_iff_nonempty.mp Nat.one_pos
  let _ : Nonempty (Fin 0 ‚Üí d‚ÇÇ) := instNonemptyOfInhabited
  use 0, 1, default
  constructor
  ¬∑ exact ‚ü®default, default, Unique.eq_default _‚ü©
  constructor
  ¬∑ norm_num
  ¬∑ rw [Unique.eq_default id]
    exact ŒµApproximates_monotone (ŒµApproximates_self default) hŒµ.le

/-- The identity channel on D dimensional space achieves a rate of log2(D). -/
theorem id_achievesRate_log_dim : (id (dIn := d‚ÇÅ)).AchievesRate (Real.logb 2 (Fintype.card d‚ÇÅ)) := by
  intro Œµ hŒµ
  use 1, Fintype.card d‚ÇÅ, id
  constructor
  ¬∑ sorry--they are equivalent up to permutation
  constructor
  ¬∑ norm_num
  ¬∑ exact ŒµApproximates_monotone (ŒµApproximates_self id) hŒµ.le

/-- A channel cannot achieve a rate greater than log2(D), where D is the input dimension. -/
theorem not_achievesRate_gt_log_dim_in (Œõ : CPTPMap d‚ÇÅ d‚ÇÇ) {R : ‚Ñù} (hR : Real.logb 2 (Fintype.card d‚ÇÅ) < R): ¬¨Œõ.AchievesRate R := by
  sorry

/-- A channel cannot achieve a rate greater than log2(D), where D is the output dimension. -/
theorem not_achievesRate_gt_log_dim_out (Œõ : CPTPMap d‚ÇÅ d‚ÇÇ) {R : ‚Ñù} (hR : Real.logb 2 (Fintype.card d‚ÇÇ) < R): ¬¨Œõ.AchievesRate R := by
  sorry

/-- The achievable rates are a bounded set. -/
theorem bddAbove_achievesRate (Œõ : CPTPMap d‚ÇÅ d‚ÇÇ) : BddAbove {R | Œõ.AchievesRate R} := by
  use Real.logb 2 (Fintype.card d‚ÇÅ)
  intro R h
  contrapose h
  exact not_achievesRate_gt_log_dim_in Œõ (lt_of_not_ge h)

end AchievesRate

section capacity
variable [DecidableEq d‚ÇÇ]

/-- Quantum channel capacity is nonnegative. -/
theorem zero_le_quantumCapacity (Œõ : CPTPMap d‚ÇÅ d‚ÇÇ) : 0 ‚â§ Œõ.quantumCapacity :=
  le_csSup (bddAbove_achievesRate Œõ) (achievesRate_0 Œõ)

/-- Quantum channel capacity is at most log2(D), where D is the input dimension. -/
theorem quantumCapacity_ge_log_dim_in (Œõ : CPTPMap d‚ÇÅ d‚ÇÇ) : Œõ.quantumCapacity ‚â§ Real.logb 2 (Fintype.card d‚ÇÅ) :=
  Real.sSup_le (by
    intro R h
    contrapose h
    exact not_achievesRate_gt_log_dim_in Œõ (lt_of_not_ge h))
  (by
    by_cases h : Nonempty d‚ÇÅ
    ¬∑ apply Real.logb_nonneg one_lt_two (Nat.one_le_cast.mpr Fintype.card_pos)
    ¬∑ simp [not_nonempty_iff.mp h])

/-- The LSD (Lloyd-Shor-Devetak) theorem: the quantum capacity is at least as large the single-copy coherent
information. The "coherent information" is used in literature to refer to both a function of state and
a channel (`coherentInfo`), or a function of just a channel. In the latter case, the state is implicitly
maximized over. Here we use the former definition and state that the lower bound is true for all states. -/
theorem coherentInfo_le_quantumCapacity (Œõ : CPTPMap d‚ÇÅ d‚ÇÇ) (œÅ : MState d‚ÇÅ) : coherentInfo œÅ Œõ ‚â§ Œõ.quantumCapacity := by
  sorry

/-- The quantum capacity is the limit of the coherent information of n-copy uses of the channel. -/
theorem quantumCapacity_eq_piProd_coherentInfo (Œõ : CPTPMap d‚ÇÅ d‚ÇÇ) (œÅ : MState d‚ÇÅ) : Œõ.quantumCapacity =
    sSup { r : ‚Ñù | ‚àÉ n œÅ, r = coherentInfo œÅ (CPTPMap.piProd (fun (_ : Fin n) ‚Ü¶ Œõ))} := by
  sorry

end capacity


================================================================================
FILE: QuantumInfo/Finite/Capacity_doc.lean
TYPE: Lean 4
SIZE: 5164 characters


[Repository content continues in next chunk]