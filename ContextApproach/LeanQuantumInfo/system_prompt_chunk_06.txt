# Lean 4 Code Generation System Prompt (Chunked Version)

You are an expert Lean 4 theorem prover specializing in quantum information theory. Convert natural language prompts into precise Lean 4 code using the Lean-QuantumInfo repository as reference.

## Your Role
Convert natural language descriptions of mathematical concepts, theorems, and proofs into formal Lean 4 code following the exact patterns, definitions, and conventions from the Lean-QuantumInfo repository.

## Key Repository Patterns

### Probability & Distributions
```lean
def Prob := { p : ‚Ñù // 0 ‚â§ p ‚àß p ‚â§ 1 }
def Distribution (Œ± : Type u) [Fintype Œ±] : Type u :=
  { f : Œ± ‚Üí Prob // Finset.sum Finset.univ (fun i ‚Ü¶ (f i : ‚Ñù)) = 1 }
```

### Quantum States
```lean
structure MState (d : Type*) [Fintype d] :=
  m : Matrix d d ‚ÑÇ
  pos : m.PosSemidef
  tr : m.trace = 1

structure Bra (d : ‚Ñï) :=
  vec : Fin d ‚Üí ‚ÑÇ
  normalized' : ‚àë i, ‚Äñvec i‚Äñ^2 = 1
```

### Entropy Functions
```lean
def shannon_entropy (p : Distribution Œ±) : ‚Ñù :=
  -‚àë x, (p.val x).toReal * Real.log (p.val x).toReal

def von_neumann_entropy (œÅ : MState d) : ‚Ñù :=
  -‚àë i, (eigenvalues œÅ.m i).toReal * Real.log (eigenvalues œÅ.m i).toReal
```

## Response Format
1. **Analysis**: Explain the mathematical concept
2. **Lean Code**: Complete implementation with imports
3. **Explanation**: Key components and mathematical meaning
4. **Dependencies**: Required imports and related definitions

## Guidelines
- Use Unicode: `‚Ñù`, `‚Ñï`, `‚ÑÇ`, `‚Üí`, `‚Üî`, `‚àß`, `‚à®`, `‚àÄ`, `‚àÉ`
- Include docstrings: `/-- ... -/`
- Type annotations: `[Fintype Œ±]`, `[DecidableEq Œ±]`
- Use `sorry` for incomplete proofs
- Follow repository naming conventions
- Reference existing definitions when possible

## Repository Content Reference

The following is a portion of the Lean-QuantumInfo repository content. Use this as reference for code generation:

---

  rw [LinearMap.sum_apply, trace_sum]
    dsimp
    simp only [Matrix.trace_kronecker, Matrix.trace_mul_cycle (B := x),
      Matrix.trace_single_eq_same, mul_one]
    rw [‚Üê trace_sum, ‚Üê Finset.sum_mul]
    congr
    convert one_mul x
    rw [show (1 : Matrix d d ‚ÑÇ) = (1 : HermitianMat d ‚ÑÇ).toMat by rfl, ‚Üê Œõ.normalized]
    push_cast
    congr! with i _
    exact HermitianMat.pow_half_mul (Œõ.zero_le i)

open Kronecker in
theorem MeasurementMap_apply_matrix (Œõ : POVM X d) (m : Matrix d d ‚ÑÇ) :
  Œõ.MeasurementMap.map m =  ‚àë x : X,
    ((((Œõ.mats x) ^ (1/2:‚Ñù)).toMat * m * ((Œõ.mats x)^(1/2:‚Ñù)).toMat) ‚äó‚Çñ Matrix.single x x 1) := by
  dsimp [MeasurementMap, HPMap.map]
  rw [LinearMap.sum_apply]
  rfl

open HermitianMat in
theorem MeasurementMap_apply_hermitianMat (Œõ : POVM X d) (m : HermitianMat d ‚ÑÇ) :
  Œõ.MeasurementMap.toHPMap m = ‚àë x : X,
    --TODO: Something like `HermitianMat.single` to make this better
    ((m.conj ((Œõ.mats x)^(1/2:‚Ñù)).toMat : HermitianMat d ‚ÑÇ) ‚äó‚Çñ .diagonal (fun y ‚Ü¶ ite (x = y) 1 0)) := by
  ext1
  convert Œõ.MeasurementMap_apply_matrix m.toMat
  simp [HermitianMat.conj]
  congr!
  ext i j
  simp [HermitianMat.diagonal, Matrix.diagonal_apply, Matrix.single]
  split_ifs <;> (try grind) <;> norm_num

/-- A POVM leads to a distribution of outcomes on any given mixed state œÅ. -/
def Measure (Œõ : POVM X d) (œÅ : MState d) : Distribution X := .mk'
    (f := fun x ‚Ü¶ (Œõ.mats x).inner œÅ.M)
    (h‚ÇÅ := fun x ‚Ü¶ HermitianMat.inner_ge_zero (Œõ.zero_le x) œÅ.zero_le)
    (hN := by
      simp [HermitianMat.inner_eq_re_trace, ‚Üê Complex.re_sum, ‚Üê trace_sum, ‚Üê Finset.sum_mul,
      ‚Üê AddSubgroup.val_finset_sum, ‚Üê HermitianMat.val_eq_coe, Œõ.normalized])

/-- The quantum-classical `POVM.measurement_map`, gives a marginal on the right equal to `POVM.measure`.-/
theorem traceLeft_measurementMap_eq_measure (Œõ : POVM X d) (œÅ : MState d) :
    (Œõ.MeasurementMap œÅ).traceLeft = MState.ofClassical (Œõ.Measure œÅ) := by
  open Kronecker in
  ext i j
  rcases œÅ with ‚ü®‚ü®œÅ, œÅH‚ü©, hœÅ0, hœÅ1‚ü©
  change (Matrix.traceLeft (Œõ.MeasurementMap.map œÅ)) i j = _
  rw [MeasurementMap_apply_matrix]
  --TODO: a lemma for Matrix.traceLeft (‚àë x, _) = ‚àë x, (Matrix.traceLeft _)
  simp_rw [Matrix.traceLeft, Matrix.of_apply, Matrix.sum_apply]
  rw [Finset.sum_comm]
  simp only [kroneckerMap_apply, MState.coe_ofClassical]
  simp only [single, of_apply, mul_ite, mul_one, mul_zero, Finset.sum_ite_irrel,
    Finset.sum_const_zero]
  simp only [HermitianMat.diagonal, HermitianMat.mk_toMat, diagonal_apply]
  symm; split
  ¬∑ subst j
    simp only [Measure, Distribution.mk', Distribution.funlike_apply, and_self, Finset.sum_ite_eq',
      Finset.mem_univ, ‚ÜìreduceIte]
    change _ = Matrix.trace _
    rw [Matrix.trace_mul_cycle, HermitianMat.pow_half_mul (Œõ.zero_le i)]
    exact HermitianMat.inner_eq_trace_rc _ _
  ¬∑ conv => enter [2, 2, x]; rw [if_neg (by grind)]
    simp

/-- The action of measuring a state with the POVM `Œõ`, discarding the resulting state, and keeping
the mixed state recording the outcome. This resulting state is purely diagonal, as given in
`POVM.measureDiscard_apply`. -/
noncomputable def MeasureDiscard (Œõ : POVM X d) : CPTPMap d X :=
  CPTPMap.traceLeft ‚àò‚Çò Œõ.MeasurementMap

theorem measureDiscard_apply (Œõ : POVM X d) (œÅ : MState d) :
    Œõ.MeasureDiscard œÅ = MState.ofClassical (Œõ.Measure œÅ) := by
  simp [MeasureDiscard, traceLeft_measurementMap_eq_measure]

end POVM


================================================================================
FILE: QuantumInfo/Finite/Pinching.lean
TYPE: Lean 4
SIZE: 2701 characters
================================================================================

import QuantumInfo.Finite.CPTPMap
import QuantumInfo.Finite.MState
import QuantumInfo.Finite.Entropy
import QuantumInfo.ForMathlib.HermitianMat.CFC

/-! # Pinching channels
A pinching channel decoheres in the eigenspaces of a given state.
More precisely, given a state œÅ, the pinching channel with respect to œÅ is defined as
  E(œÉ) = ‚àë P·µ¢ œÉ P·µ¢
where the P_i are the projectors onto the i-th eigenspaces of œÅ = ‚àë·µ¢ p·µ¢ P·µ¢, with i ‚â† j ‚Üí p·µ¢ ‚â† p‚±º.
-/

noncomputable section

variable {d : Type*} [Fintype d] [DecidableEq d]

def pinching_kraus (œÅ : MState d) : spectrum ‚Ñù œÅ.m ‚Üí HermitianMat d ‚ÑÇ :=
  fun x ‚Ü¶ œÅ.M.cfc (fun y ‚Ü¶ if y = x then 1 else 0)

instance finite_spectrum_inst (œÅ : MState d) : Fintype (spectrum ‚Ñù œÅ.m) :=
  Fintype.ofFinite (spectrum ‚Ñù œÅ.m)

theorem pinching_sq_eq_self (œÅ : MState d) : ‚àÄ k, (pinching_kraus œÅ k)^2 = (pinching_kraus œÅ k) := fun k => by
  ext1
  push_cast
  rw [pow_two, pinching_kraus, HermitianMat.cfc, ‚Üêcfc_mul
  (hf := by simp only [continuousOn_iff_continuous_restrict, continuous_of_discreteTopology, implies_true])
  (hg := by simp only [continuousOn_iff_continuous_restrict, continuous_of_discreteTopology, implies_true])]
  simp only [‚Üê pow_two, ite_pow, one_pow, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
    zero_pow]

theorem pinching_sum (œÅ : MState d) : ‚àë k, pinching_kraus œÅ k = 1 := by
  ext i j
  simp [pinching_kraus, HermitianMat.cfc]
  have heq : Set.EqOn (fun x => ‚àë i : spectrum ‚Ñù œÅ.m, if x = ‚Üëi then (1 : ‚Ñù) else 0) 1 (spectrum ‚Ñù œÅ.m) := by
    unfold Set.EqOn; intro x hx
    dsimp
    rw [Finset.sum_set_coe (f := fun i => if x = i then 1 else 0) (s := spectrum ‚Ñù œÅ.m), Finset.sum_ite_eq_of_mem]
    rw [Set.mem_toFinset]
    exact hx
  rw [‚Üêcfc_sum (hf := by simp only [continuousOn_iff_continuous_restrict, continuous_of_discreteTopology, implies_true]),
  Finset.sum_fn, cfc_congr heq, cfc_one (R := ‚Ñù) (ha := _)]
  rw [IsSelfAdjoint, Matrix.star_eq_conjTranspose, œÅ.Hermitian]

def pinching_map (œÅ : MState d) : CPTPMap d d ‚ÑÇ :=
  CPTPMap.of_kraus_CPTPMap (HermitianMat.toMat ‚àò pinching_kraus œÅ) (by
  conv =>
    enter [1, 2, k]
    rw [Function.comp_apply, (pinching_kraus œÅ k).H, ‚Üêpow_two]
    norm_cast
    rw [pinching_sq_eq_self œÅ k]
  norm_cast
  rw [pinching_sum]
  rfl
  )

/-- Exercise 2.8 of Hayashi's book "A group theoretic approach to Quantum Information".
-- Used in (S59) -/
theorem pinching_pythagoras (œÅ œÉ : MState d) :  ùêÉ(œÅ‚ÄñœÉ) = ùêÉ(œÅ‚Äñpinching_map œÉ œÅ) + ùêÉ(pinching_map œÉ œÅ‚ÄñœÉ) :=
  sorry

/-- Lemma 3.10 of Hayashi's book "Quantum Information Theory - Mathematical Foundations".
-- Used in (S60) -/
theorem pinching_bound (œÅ œÉ : MState d) : œÅ.M ‚â§ (‚Üë(Fintype.card (spectrum ‚Ñù œÉ.m)) : ‚Ñù) ‚Ä¢ (pinching_map œÉ œÅ).M :=
  sorry


================================================================================
FILE: QuantumInfo/Finite/Qubit/Basic.lean
TYPE: Lean 4
SIZE: 5829 characters
================================================================================

import QuantumInfo.Finite.CPTPMap

/-!
Quantum theory and operations specific to qubits.
 - Standard named (single-qubit) gates: Z, X, Y, H, S, T
 - Controlled versions of gates
 - Completeness of the PPT test: a state is separable iff it is PPT.
 - Fidelity for qubits: `F(œÅ,œÉ) = 2‚àö(œÅ.det * œÉ.det)`.
 - The singlet/triplet split.
-/

abbrev Qubit := Fin 2

section Mathlib
namespace Matrix

variable {Œ± : Type*} [NonUnitalNonAssocSemiring Œ±] [StarRing Œ±]

variable {Œ± Œ≤ : Type*} [DecidableEq Œ±] [Fintype Œ±] [DecidableEq Œ≤] [Fintype Œ≤]

@[simp]
theorem neg_unitary_val (u : ùêî[Œ±]) : (-u).val = -u := by
  rfl

omit [DecidableEq Œ±] [Fintype Œ±] [DecidableEq Œ≤] [Fintype Œ≤] in
open Kronecker in
@[simp]
theorem star_kron (a : Matrix Œ± Œ± ‚ÑÇ) (b : Matrix Œ≤ Œ≤ ‚ÑÇ) : star (a ‚äó‚Çñ b) = (star a) ‚äó‚Çñ (star b) := by
  ext _ _
  simp

open Kronecker in
theorem kron_unitary (a : ùêî[Œ±]) (b : ùêî[Œ≤]) : a.val ‚äó‚Çñ b.val ‚àà ùêî[Œ± √ó Œ≤] := by
  simp [Matrix.mem_unitaryGroup_iff, ‚Üê Matrix.mul_kronecker_mul]

open Kronecker in
def unitary_kron (a : ùêî[Œ±]) (b : ùêî[Œ≤]) : ùêî[Œ± √ó Œ≤] :=
  ‚ü®_, kron_unitary a b‚ü©

scoped notation a:60 " ‚äó·µ§ " b:60 => unitary_kron a b

@[simp]
theorem unitary_kron_apply (a : ùêî[Œ±]) (b : ùêî[Œ≤]) (i‚ÇÅ i‚ÇÇ : Œ±) (j‚ÇÅ j‚ÇÇ : Œ≤) :
    (a ‚äó·µ§ b) (i‚ÇÅ, j‚ÇÅ) (i‚ÇÇ, j‚ÇÇ) = (a i‚ÇÅ i‚ÇÇ) * (b j‚ÇÅ j‚ÇÇ) := by
  rfl

@[simp]
theorem unitary_kron_one_one : (1 : ùêî[Œ±]) ‚äó·µ§ (1 : ùêî[Œ≤]) = (1 : ùêî[Œ± √ó Œ≤]) := by
  simp [Matrix.unitary_kron]

end Matrix
end Mathlib

open Lean.Parser.Tactic in
open Lean in
/--
Proves goals equating small matrices by expanding out products and simpliying standard Real arithmetic.
-/
syntax (name := matrix_expand) "matrix_expand"
  (" [" ((simpStar <|> simpErase <|> simpLemma),*,?) "]")?
  (" with " rcasesPat+)? : tactic

macro_rules
  | `(tactic| matrix_expand $[[$rules,*]]? $[with $withArg*]?) => do
    let id1 := (withArg.getD ‚ü®[]‚ü©).getD 0 (‚Üê `(rcasesPat| _))
    let id2 := (withArg.getD ‚ü®[]‚ü©).getD 1 (‚Üê `(rcasesPat| _))
    let rules' := rules.getD ‚ü®#[]‚ü©
    `(tactic| (
      ext i j
      repeat rcases (i : Prod _ _) with ‚ü®i, $id1‚ü©
      repeat rcases (j : Prod _ _) with ‚ü®j, $id2‚ü©
      fin_cases i
      <;> fin_cases j
      <;> simp [Complex.ext_iff,
        Matrix.mul_apply, Fintype.sum_prod_type, Matrix.one_apply, field,
        $rules',* ]
      <;> norm_num
      <;> try field_simp
      <;> try ring_nf
      ))

namespace Qubit
open Real
open Complex

variable {k : Type*} [Fintype k] [DecidableEq k]

/-- The Pauli Z gate on a qubit. -/
def Z : ùêî[Qubit] :=
  ‚ü®!![1, 0; 0, -1], by constructor <;> matrix_expand‚ü©

/-- The Pauli X gate on a qubit. -/
def X : ùêî[Qubit] :=
  ‚ü®!![0, 1; 1, 0], by constructor <;> matrix_expand‚ü©

/-- The Pauli Y gate on a qubit. -/
def Y : ùêî[Qubit] :=
  ‚ü®!![0, -I; I, 0], by constructor <;> matrix_expand‚ü©

/-- The H gate, a Hadamard gate, on a qubit. -/
noncomputable def H : ùêî[Qubit] :=
  ‚ü®‚àö(1/2) ‚Ä¢ (!![1, 1; 1, -1]), by constructor <;> matrix_expand‚ü©

/-- The S gate, or Rz(œÄ/2) rotation on a qubit. -/
def S : ùêî[Qubit] :=
  ‚ü®!![1, 0; 0, I], by constructor <;> matrix_expand‚ü©

/-- The T gate, or Rz(œÄ/4) rotation on a qubit. -/
noncomputable def T : ùêî[Qubit] :=
  ‚ü®!![1, 0; 0, (1 + I)/‚àö2], by constructor <;> matrix_expand‚ü©

@[simp]
theorem Z_sq : Z * Z = 1 := by
  matrix_expand [Z]

@[simp]
theorem X_sq : X * X = 1 := by
  matrix_expand [X]

@[simp]
theorem Y_sq : Y * Y = 1 := by
  matrix_expand [Y]

@[simp]
theorem H_sq : H * H = 1 := by
  matrix_expand [H]

@[simp]
theorem S_sq : S * S = Z := by
  matrix_expand [S, Z]

@[simp]
theorem T_sq : T * T = S := by
  matrix_expand [T, S]

/-- The anticommutator `{X,Y}` is zero. Marked simp as to put Pauli products in a canonical Y-X-Z order. -/
@[simp]
theorem X_Y_anticomm : X * Y = -Y * X := by
  matrix_expand [X, Y]

/-- The anticommutator `{Y,Z}` is zero. -/
theorem Y_Z_anticomm : Z * Y = -Y * Z := by
  matrix_expand [Z, Y]

/-- The anticommutator `{Z,X}` is zero. -/
theorem Z_X_anticomm : Z * X = -X * Z := by
  matrix_expand [Z, X]

@[simp]
theorem H_mul_X_eq_Z_mul_H : H * X = Z * H := by
  matrix_expand [H, X, Z]

@[simp]
theorem H_mul_Z_eq_X_mul_H : H * Z = X * H := by
  matrix_expand [H, X, Z]

@[simp]
theorem S_Z_comm : Z * S = S * Z := by
  simp [‚Üê S_sq, mul_assoc]

@[simp]
theorem T_Z_comm : Z * T = T * Z := by
  simp [‚Üê S_sq, ‚Üê T_sq, mul_assoc]

@[simp]
theorem S_T_comm : S * T = T * S := by
  simp [‚Üê T_sq, mul_assoc]

/-- Given a unitary `U` on some Hilbert space `k`, we have the controllized version that acts on `Fin 2 ‚äó k`
where `U` is conditionally applied if the first qubit is `1`. -/
def controllize (g : ùêî[k]) : ùêî[Qubit √ó k] :=
  ‚ü®Matrix.of fun (q‚ÇÅ,t‚ÇÅ) (q‚ÇÇ,t‚ÇÇ) ‚Ü¶
    if (q‚ÇÅ,q‚ÇÇ) = (0,0) then
      (if t‚ÇÅ = t‚ÇÇ then 1 else 0)
    else if (q‚ÇÅ,q‚ÇÇ) = (1,1) then
      g t‚ÇÅ t‚ÇÇ
    else 0
    , by
      rw [Matrix.mem_unitaryGroup_iff]
      matrix_expand [-Complex.ext_iff] with ti tj;
      ¬∑ congr 1
        exact propext eq_comm
      ¬∑ exact congrFun‚ÇÇ g.2.2 ti tj
    ‚ü©

scoped notation "C[" g "]" => controllize g

variable (g : ùêî[k]) (j‚ÇÅ j‚ÇÇ : k)

@[simp]
theorem controllize_apply_zero_zero : C[g] (0, j‚ÇÅ) (0, j‚ÇÇ) = (1 : ùêî[k]) j‚ÇÅ j‚ÇÇ := by
  rfl

@[simp]
theorem controllize_apply_zero_one : C[g] (0, j‚ÇÅ) (1, j‚ÇÇ) = 0 := by
  rfl

@[simp]
theorem controllize_apply_one_zero : C[g] (1, j‚ÇÅ) (0, j‚ÇÇ) = 0 := by
  rfl

@[simp]
theorem controllize_apply_one_one : C[g] (1, j‚ÇÅ) (1, j‚ÇÇ) = g j‚ÇÅ j‚ÇÇ := by
  rfl

@[simp]
theorem controllize_mul (g‚ÇÅ g‚ÇÇ : ùêî[k]) : C[g‚ÇÅ] * C[g‚ÇÇ] = C[g‚ÇÅ * g‚ÇÇ] := by
  matrix_expand

@[simp]
theorem controllize_one : C[(1 : ùêî[k])] = 1 := by
  matrix_expand

@[simp]
theorem controllize_mul_inv : C[g] * C[g‚Åª¬π] = 1 := by
  simp

open scoped Matrix in
@[simp]
theorem X_controllize_X : (X ‚äó·µ§ 1) * C[g] * (X ‚äó·µ§ 1) = (1 ‚äó·µ§ g) * C[g‚Åª¬π] := by
  matrix_expand [X, -Complex.ext_iff] with ki kj;
  suffices (1 : Matrix k k ‚ÑÇ) ki kj = (g * g‚Åª¬π) ki kj by
    convert this
  simp

end Qubit


================================================================================
FILE: QuantumInfo/Finite/ResourceTheory/FreeState.lean
TYPE: Lean 4
SIZE: 20090 characters
================================================================================

import Mathlib.Algebra.Module.Submodule.Lattice
import Mathlib.Analysis.Subadditive
import Mathlib.CategoryTheory.Functor.FullyFaithful
import Mathlib.CategoryTheory.Monoidal.Braided.Basic
import Mathlib.Data.EReal.Basic
import Mathlib.Tactic

import QuantumInfo.Finite.CPTPMap
import QuantumInfo.Finite.Entropy

open scoped Topology

/-- A `ResourcePretheory` is a family of Hilbert spaces closed under tensor products, with an instance of
`Fintype` and `DecidableEq` for each. It forms a pre-structure then on which to discuss resource
theories. For instance, to talk about "two-party scenarios", we could write `ResourcePretheory (‚Ñï √ó ‚Ñï)`,
with `H (a,b) := (Fin a) √ó (Fin b)`.

The `Semigroup Œπ` structure means we have a way to take products of our labels of Hilbert spaces
in a way that is associative (with actual equality). The `prodEquiv` lets us reinterpret between
a product-labelled Hilbert spaces, and an actual pair of Hilbert spaces.
-/
class ResourcePretheory (Œπ : Type*) extends Semigroup Œπ where
  /-- The indexing of each Hilbert space -/
  H : Œπ ‚Üí Type*
  /-- Each space is finite -/
  [FinH : ‚àÄ i, Fintype (H i)]
  /-- Each object has decidable equality -/
  [DecEqH : ‚àÄ i, DecidableEq (H i)]
  /-- Each space is nonempty (dimension at least 1) -/
  [NonemptyH : ‚àÄ i, Nonempty (H i)]
  /-- The product structure induces an isomorphism of Hilbert spaces -/
  prodEquiv i j : H (i * j) ‚âÉ (H i) √ó (H j)
  --Possible we want some fact like the associativity of `prod` or the existence of an identity space,
  -- which would then imply MonoidalCategory structure later (instead of just Category). For now we
  -- take the (logically equivalent, in the appropriate model) assumption that the associator is
  -- actually an equality. This is captured in the `Semigroup Œπ` assumption. If we wanted to turn
  -- this into something more flexible, we would replace that with `Mul Œπ` (dropping `mul_assoc`)
  -- and get an appropriate associator `Equiv` here.
  hAssoc i j k :
    ((prodEquiv (i * j) k).trans <|
      ((prodEquiv i j).prodCongr (Equiv.refl (H k))).trans <|
      (Equiv.prodAssoc _ _ _).trans <|
      ((Equiv.refl (H i)).prodCongr ((prodEquiv j k).symm)).trans
      (prodEquiv i (j * k)).symm
    )
     = Equiv.cast (congrArg H <| mul_assoc i j k)

attribute [instance] ResourcePretheory.FinH
attribute [instance] ResourcePretheory.DecEqH
attribute [instance] ResourcePretheory.NonemptyH

namespace ResourcePretheory

variable {Œπ : Type*} [ResourcePretheory Œπ] {i j k l : Œπ}

/-- The `prod` operation of `ResourcePretheory` gives the natural product operation on `MState`s
that puts us in a new Hilbert space of the category. Accessible by the notation `œÅ‚ÇÅ ‚äó·µ£ œÅ‚ÇÇ`. -/
noncomputable def prodRelabel (œÅ‚ÇÅ : MState (H i)) (œÅ‚ÇÇ : MState (H j)) : MState (H (i * j)) :=
  (œÅ‚ÇÅ ‚äó œÅ‚ÇÇ).relabel (prodEquiv i j)

scoped infixl:65 "‚äó·µ£" => prodRelabel

theorem prodRelabel_assoc (œÅ‚ÇÅ : MState (H i)) (œÅ‚ÇÇ : MState (H j)) (œÅ‚ÇÉ : MState (H k)) :
    œÅ‚ÇÅ ‚äó·µ£ œÅ‚ÇÇ ‚äó·µ£ œÅ‚ÇÉ ‚âç œÅ‚ÇÅ ‚äó·µ£ (œÅ‚ÇÇ ‚äó·µ£ œÅ‚ÇÉ) := by
  simp [prodRelabel, MState.relabel_kron]
  have h_equiv := hAssoc i j k
  rw [‚Üê Equiv.trans_assoc, Equiv.trans_cancel_right] at h_equiv
  have h_cong := congrArg (MState.relabel ((œÅ‚ÇÅ‚äóœÅ‚ÇÇ)‚äóœÅ‚ÇÉ)) h_equiv
  rw [‚Üê eq_cast_iff_heq]; swap
  ¬∑ rw [mul_assoc]
  convert h_cong; clear h_equiv h_cong
  rw [‚Üê MState.relabel_cast]; swap
  ¬∑ rw [mul_assoc]
  rw [MState.kron_relabel, MState.prod_assoc]
  rw [MState.relabel_comp, MState.relabel_comp, MState.relabel_comp]
  rfl

/-- A `MState.relabel` can be distributed across a `prodRelabel`, if you have proofs that the factors
correspond correctly. -/
theorem prodRelabel_relabel_cast_prod
    (œÅ‚ÇÅ : MState (H i)) (œÅ‚ÇÇ : MState (H j))
    (h : H (k * l) = H (i * j)) (hik : k = i) (hlj : l = j) :
    (œÅ‚ÇÅ ‚äó·µ£ œÅ‚ÇÇ).relabel (Equiv.cast h) =
    (œÅ‚ÇÅ.relabel (Equiv.cast (congrArg H hik))) ‚äó·µ£ (œÅ‚ÇÇ.relabel (Equiv.cast (congrArg H hlj))) := by
  subst hik
  subst hlj
  rfl

/-- The `prod` operation of `ResourcePretheory` gives the natural product operation on `CPTPMap`s. Accessible
by the notation `M‚ÇÅ ‚äó·µ£ M‚ÇÇ`. -/
noncomputable def prodCPTPMap (M‚ÇÅ : CPTPMap (H i) (H j)) (M‚ÇÇ : CPTPMap (H k) (H l)) :
    CPTPMap (H (i * k)) (H (j * l)) :=
  (CPTPMap.of_equiv (prodEquiv j l).symm).compose ((M‚ÇÅ ‚äó‚Çñ M‚ÇÇ).compose (CPTPMap.of_equiv (prodEquiv i k)))

scoped notation M‚ÇÅ "‚äó‚Çñ·µ£" M‚ÇÇ => prodCPTPMap M‚ÇÅ M‚ÇÇ

open ComplexOrder in
theorem PosDef.prod {œÅ : MState (H i)} {œÉ : MState (H j)} (hœÅ : œÅ.m.PosDef) (hœÉ : œÉ.m.PosDef)
    : (œÅ ‚äó·µ£ œÉ).m.PosDef := by
  have : (œÅ ‚äó œÉ).m.PosDef := MState.PosDef.kron hœÅ hœÉ
  rw [prodRelabel]
  exact MState.PosDef.relabel this (prodEquiv i j)

--BAD old attempt at PNat powers
-- /-- Powers of spaces. Defined for `PNat` so that we don't have zeroth powers. -/
-- noncomputable def spacePow (i : Œπ) (n : ‚Ñï+) : Œπ :=
--   n.natPred.rec i (fun _ j ‚Ü¶ prod j i)

-- scoped notation i "‚äó^H[" n "]" => spacePow i n

-- @[simp]
-- theorem spacePow_one (i : Œπ) : i‚äó^H[1] = i :=
--   rfl

-- theorem spacePow_succ (i : Œπ) (n : ‚Ñï+) : i‚äó^H[n + 1] = prod (i‚äó^H[n]) i := by
--   rcases n with ‚ü®_|n, hn‚ü©
--   ¬∑ contradiction
--   ¬∑ rfl

-- /-- Powers of states. Defined for `PNat`, so that we don't have zeroth powers -/
-- noncomputable def statePow {i : Œπ} (œÅ : MState (H i)) (n : ‚Ñï+) : MState (H (i‚äó^H[n])) :=
--   (n.natPred.rec œÅ (fun _ œÉ ‚Ü¶ œÉ ‚äó·µ£ œÅ) : MState (H (i‚äó^H[n.natPred.succPNat])))

-- scoped notation œÅ "‚äó^S[" n "]" => statePow œÅ n

-- @[simp]
-- theorem statePow_one {i : Œπ} (œÅ : MState (H i)) : œÅ‚äó^S[1] = œÅ :=
--   rfl

-- theorem statePow_succ {i : Œπ} (œÅ : MState (H i)) (n : ‚Ñï+) : œÅ‚äó^S[n + 1] = œÅ‚äó^S[n] ‚äó·µ£ œÅ := by
--   rcases n with ‚ü®_|n, hn‚ü©
--   ¬∑ contradiction
--   ¬∑ rfl

@[simp]
theorem qRelEntropy_prodRelabel (œÅ‚ÇÅ œÅ‚ÇÇ : MState (H i)) (œÉ‚ÇÅ œÉ‚ÇÇ : MState (H j)):
    ùêÉ(œÅ‚ÇÅ ‚äó·µ£ œÉ‚ÇÅ‚ÄñœÅ‚ÇÇ ‚äó·µ£ œÉ‚ÇÇ) = ùêÉ(œÅ‚ÇÅ‚ÄñœÅ‚ÇÇ) + ùêÉ(œÉ‚ÇÅ‚ÄñœÉ‚ÇÇ) := by
  simp [prodRelabel]

@[simp]
theorem sandwichedRelRentropy_prodRelabel {Œ± : ‚Ñù} (œÅ‚ÇÅ œÅ‚ÇÇ : MState (H i)) (œÉ‚ÇÅ œÉ‚ÇÇ : MState (H j)):
    DÃÉ_ Œ±(œÅ‚ÇÅ ‚äó·µ£ œÉ‚ÇÅ‚ÄñœÅ‚ÇÇ ‚äó·µ£ œÉ‚ÇÇ) = DÃÉ_ Œ±(œÅ‚ÇÅ‚ÄñœÅ‚ÇÇ) + DÃÉ_ Œ±(œÉ‚ÇÅ‚ÄñœÉ‚ÇÇ) := by
  simp [prodRelabel]

end ResourcePretheory

open ResourcePretheory

/-- A ResourcePretheory is `Unital` if it has a Hilbert space of size 1, i.e. `‚ÑÇ`. -/
class UnitalPretheory (Œπ : Type*) extends ResourcePretheory Œπ, MulOneClass Œπ, Unique (H 1) where
  prod_default {i} (œÅ : MState (H i)) :
    (toResourcePretheory.prodRelabel œÅ (Inhabited.default : MState (H 1))) ‚âç œÅ
  default_prod {i} (œÅ : MState (H i)) :
    (toResourcePretheory.prodRelabel (Inhabited.default : MState (H 1)) œÅ) ‚âç œÅ

namespace UnitalPretheory

variable {Œπ : Type*} [UnitalPretheory Œπ] {i j : Œπ}

instance : Monoid Œπ where

/-- Powers of spaces.

We define it for `Nat` in a `UnitalPretheory`. In principal this could be done for any
`ResourcePretheory` and be defined for `PNat` so that we don't have zeroth powers. In
anticipation that we might some day want that, and that we might do everything with a
non-equality associator, we keep this as its own definition and keep our own names for
rewriting theorems where possible.-/
noncomputable def spacePow (i : Œπ) (n : ‚Ñï) : Œπ :=
  i ^ n

--This notation is less necessary now since we can just write `i ^ n` as long as it's
--a monoid.
scoped notation i "‚äó^H[" n "]" => spacePow i n

@[simp]
theorem spacePow_zero (i : Œπ) : i ^ 0 = 1 := by
  rfl

@[simp]
theorem spacePow_one (i : Œπ) : i ^ 1 = i := by
  simp

theorem spacePow_succ (i : Œπ) (n : ‚Ñï) : i ^ (n + 1) = (i ^ n) * i := by
  rfl

theorem spacePow_add (m n : ‚Ñï) :
    i ^ (m + n) = (i ^ m) * (i ^ n) := by
  induction n
  ¬∑ simp
  ¬∑ rename_i n ih
    rw [spacePow_succ, ‚Üê mul_assoc, ‚Üê add_assoc, ‚Üê ih, spacePow_succ]

theorem spacePow_mul (m n : ‚Ñï) :
    i ^ (m * n) = (i ^ m) ^ n :=
  pow_mul i m n

/-- Powers of states. Defined for `PNat`, so that we don't have zeroth powers -/
noncomputable def statePow (œÅ : MState (H i)) (n : ‚Ñï) : MState (H (i ^ n)) :=
  n.rec default (fun _ œÉ ‚Ü¶ œÉ ‚äó·µ£ œÅ)

scoped notation œÅ "‚äó^S[" n "]" => statePow œÅ n

@[simp]
theorem statePow_zero (œÅ : MState (H i)) : œÅ‚äó^S[0] = default :=
  rfl

@[simp]
theorem statePow_one (œÅ : MState (H i)) : œÅ‚äó^S[1] ‚âç œÅ := by
  rw [‚Üê eq_cast_iff_heq]; swap
  ¬∑ rw [spacePow_one]
  ¬∑ rw [eq_cast_iff_heq, statePow]
    exact default_prod œÅ

theorem statePow_succ (œÅ : MState (H i)) (n : ‚Ñï) : œÅ‚äó^S[n + 1] = œÅ‚äó^S[n] ‚äó·µ£ œÅ := by
  rfl

theorem statePow_add (œÅ : MState (H i)) (m n : ‚Ñï) : œÅ‚äó^S[m + n] ‚âç œÅ‚äó^S[m] ‚äó·µ£ œÅ‚äó^S[n] := by
  rw [‚Üê eq_cast_iff_heq]; swap
  ¬∑ rw [spacePow_add]
  rw [eq_cast_iff_heq]
  induction n
  ¬∑ rw [add_zero, statePow_zero]
    exact (prod_default _).symm
  ¬∑ rename_i n ih
    rw [statePow_succ, ‚Üê add_assoc, statePow_succ]
    refine HEq.trans ?_ (prodRelabel_assoc _ _ _)
    congr
    apply spacePow_add

theorem statePow_add_relabel (œÅ : MState (H i)) (m n : ‚Ñï) :
    œÅ‚äó^S[m + n] = (œÅ‚äó^S[m] ‚äó·µ£ œÅ‚äó^S[n]).relabel (Equiv.cast (by congr; exact pow_add i m n)) := by
  have h := statePow_add œÅ m n
  rw [heq_iff_exists_eq_cast] at h
  obtain ‚ü®h, h‚ÇÇ‚ü© := h
  rw [h‚ÇÇ, MState.relabel_cast]

theorem statePow_mul (œÅ : MState (H i)) (m n : ‚Ñï) : œÅ‚äó^S[m * n] ‚âç (œÅ‚äó^S[m])‚äó^S[n] := by
  rw [‚Üê eq_cast_iff_heq]; swap
  ¬∑ rw [spacePow_mul]
  rw [eq_cast_iff_heq]
  induction n
  ¬∑ simp
  ¬∑ rename_i n ih
    rw [statePow_succ, mul_add]
    --This is TERRIBLE. There has to be a better way
    trans œÅ‚äó^S[m * n] ‚äó·µ£ œÅ‚äó^S[m * 1]
    ¬∑ apply statePow_add
    ¬∑ rw [‚Üê eq_cast_iff_heq] at ih; swap
      ¬∑ congr 2 <;> simp [pow_mul]
      rw [‚Üê eq_cast_iff_heq]; swap
      ¬∑ congr 2 <;> simp [pow_mul]
      rw [‚Üê MState.relabel_cast _ (by simp [pow_mul])]
      rw [prodRelabel_relabel_cast_prod]
      ¬∑ congr
        ¬∑ rw [ih, MState.relabel_cast]
        ¬∑ rw [MState.relabel_cast]
          rw [eq_cast_iff_heq]
          ¬∑ rw [mul_one]
          ¬∑ rw [mul_one]
      ¬∑ rw [pow_mul]

theorem statePow_mul_relabel {i : Œπ} (œÅ : MState (H i)) (m n : ‚Ñï) :
   œÅ‚äó^S[m * n] = (œÅ‚äó^S[m])‚äó^S[n].relabel (Equiv.cast (congrArg H (pow_mul i m n))) := by
  have h := statePow_mul œÅ m n
  rw [heq_iff_exists_eq_cast] at h
  obtain ‚ü®h, h‚ÇÇ‚ü© := h
  rw [h‚ÇÇ, MState.relabel_cast]

open ComplexOrder in
theorem PosDef.npow {œÅ : MState (H i)} (hœÅ : œÅ.m.PosDef) (n : ‚Ñï)
    : (œÅ‚äó^S[n]).m.PosDef := by
  induction n
  ¬∑ rw [statePow_zero, spacePow_zero]
    exact MState.posDef_of_unique default
  ¬∑ apply ResourcePretheory.PosDef.prod ‚Äπ_‚Ä∫ hœÅ

theorem statePow_rw {n m : ‚Ñï} (h : n = m) (œÅ : MState (H i)) :
    œÅ‚äó^S[n] = (œÅ‚äó^S[m]).relabel (Equiv.cast (by congr)) := by
  subst n
  simp

@[simp]
theorem qRelEntropy_statePow (œÅ œÉ : MState (H i)) (n : ‚Ñï) :
    ùêÉ(œÅ‚äó^S[n] ‚Äñ œÉ ‚äó^S[n]) = n * ùêÉ(œÅ‚ÄñœÉ) := by
  induction n
  ¬∑ simp
  ¬∑ rename_i n ih
    rw [statePow_succ, statePow_succ, qRelEntropy_prodRelabel]
    simp [ih, add_mul]

--PULLOUT: MState.lean
@[simp]
theorem _root_.MState.default_M [Fintype d] [DecidableEq d] [Unique d] : (default : MState d).M = 1 := by
  simp [MState.instInhabited, MState.uniform]
  rfl

--PULLOUT: HermitianMat/CFC.lean
@[simp]
theorem _root_.HermitianMat.one_rpow [Fintype d] [DecidableEq d] (r : ‚Ñù) :
    (1 : HermitianMat d ‚ÑÇ) ^ r = 1 := by
  rcases isEmpty_or_nonempty d
  ¬∑ apply Subsingleton.allEq
  ¬∑ nth_rw 2 [‚Üê HermitianMat.cfc_id (1 : HermitianMat d ‚ÑÇ)]
    exact HermitianMat.cfc_congr 1 (by simp)

--PULLOUT: HermitianMat/Trace.lean
@[simp]
theorem _root_.HermitianMat.trace_one [Fintype d] [DecidableEq d] :
    (1 : HermitianMat d ‚ÑÇ).trace = (Fintype.card d) := by
  simp [HermitianMat.trace_eq_re_trace]

--PULLOUT: Entropy.lean
@[simp]
theorem _root_.sandwichedRelRentropy_of_unique [Fintype d] [DecidableEq d] [Unique d]
  (œÅ œÉ : MState d) (Œ± : ‚Ñù) :
    DÃÉ_Œ±(œÅ‚ÄñœÉ) = 0 := by
  simp [Subsingleton.allEq œÅ default, Subsingleton.allEq œÉ default, SandwichedRelRentropy]

@[simp]
theorem sandwichedRelRentropy_statePow {Œ± : ‚Ñù} (œÅ œÉ : MState (H i)) (n : ‚Ñï) :
    DÃÉ_ Œ±(œÅ‚äó^S[n] ‚Äñ œÉ‚äó^S[n]) = n * DÃÉ_ Œ±(œÅ‚ÄñœÉ) := by
  induction n
  ¬∑ rw [statePow_zero, statePow_zero, spacePow_zero]
    simp
  ¬∑ rename_i n ih
    rw [statePow_succ, statePow_succ, sandwichedRelRentropy_prodRelabel]
    simp [ih, add_mul]

theorem sandwichedRelRentropy_heq_congr {Œ± : ‚Ñù}
      {d‚ÇÅ d‚ÇÇ : Type u} [Fintype d‚ÇÅ] [DecidableEq d‚ÇÅ] [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ]
      {œÅ‚ÇÅ œÉ‚ÇÅ : MState d‚ÇÅ} {œÅ‚ÇÇ œÉ‚ÇÇ : MState d‚ÇÇ} (hd : d‚ÇÅ = d‚ÇÇ) (hœÅ : œÅ‚ÇÅ ‚âç œÅ‚ÇÇ) (hœÉ : œÉ‚ÇÅ ‚âç œÉ‚ÇÇ) :
    DÃÉ_ Œ±(œÅ‚ÇÅ‚ÄñœÉ‚ÇÅ) = DÃÉ_ Œ±(œÅ‚ÇÇ‚ÄñœÉ‚ÇÇ) := by
  rw [heq_iff_exists_eq_cast] at hœÅ hœÉ
  obtain ‚ü®_, rfl‚ü© := hœÅ
  obtain ‚ü®_, rfl‚ü© := hœÉ
  simp [‚Üê MState.relabel_cast _ hd]

@[gcongr]
theorem sandwichedRelRentropy_congr {Œ± : ‚Ñù}
      {d‚ÇÅ d‚ÇÇ : Type u} [Fintype d‚ÇÅ] [DecidableEq d‚ÇÅ] [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ]
      {œÅ‚ÇÅ œÉ‚ÇÅ : MState d‚ÇÅ} {œÅ‚ÇÇ œÉ‚ÇÇ : MState d‚ÇÇ} (hd : d‚ÇÅ = d‚ÇÇ)
        (hœÅ : œÅ‚ÇÅ = œÅ‚ÇÇ.relabel (Equiv.cast hd)) (hœÉ : œÉ‚ÇÅ = œÉ‚ÇÇ.relabel (Equiv.cast hd)) :
    DÃÉ_ Œ±(œÅ‚ÇÅ‚ÄñœÉ‚ÇÅ) = DÃÉ_ Œ±(œÅ‚ÇÇ‚ÄñœÉ‚ÇÇ) := by
  subst œÅ‚ÇÅ œÉ‚ÇÅ
  simp

end UnitalPretheory

/- FreeStateTheories: theories defining some sets of "free states" within a collection of Hilbert spaces. -/

/-- A `FreeStateTheory` is a collection of mixed states (`MState`s) in a `ResourcePretheory` that obeys
some necessary axioms:
 * For each Hilbert space `H i`, the free states are a closed, convex set
 * For each Hilbert space `H i`, there is a free state of full rank
 * If `œÅ·µ¢ ‚àà H i` and `œÅ‚±º ‚àà H j` are free, then `œÅ·µ¢ ‚äó œÅ‚±º` is free in `H (prod i j)`.
-/
class FreeStateTheory (Œπ : Type*) extends ResourcePretheory Œπ where
  /-- The set of states we're calling "free" -/
  IsFree : Set (MState (toResourcePretheory.H i))
  /-- The set F(H) of free states is closed -/
  free_closed : IsClosed (@IsFree i)
  /-- The set F(H) of free states is convex (more precisely, their matrices are) -/
  free_convex : Convex ‚Ñù (MState.M '' (@IsFree i))
  /-- The set of free states is closed under tensor product -/
  free_prod {œÅ‚ÇÅ : MState (H i)} {œÅ‚ÇÇ : MState (H j)} (h‚ÇÅ : IsFree œÅ‚ÇÅ) (h‚ÇÇ : IsFree œÅ‚ÇÇ) : IsFree (œÅ‚ÇÅ ‚äó·µ£ œÅ‚ÇÇ)
  /-- The set F(H) of free states contains a full-rank state `œÅfull`, equivalently `œÅfull` is positive definite. -/
  free_fullRank (i : Œπ) : open ComplexOrder in ‚àÉ (œÅ : MState (H i)), œÅ.m.PosDef ‚àß IsFree œÅ

namespace FreeStateTheory

variable {Œπ : Type*} [FreeStateTheory Œπ] {i : Œπ}

noncomputable instance Inhabited_IsFree : Inhabited (IsFree (i := i)) :=
  ‚ü®‚ü®(free_fullRank i).choose, (free_fullRank i).choose_spec.right‚ü©‚ü©

theorem IsFree.of_unique [Unique (H i)] (œÅ : MState (H i)) : œÅ ‚àà IsFree := by
  obtain ‚ü®œÉ, h‚ÇÅ, h‚ÇÇ‚ü© := free_fullRank i
  convert h‚ÇÇ
  apply Subsingleton.allEq

/--The set of free states is compact because it's a closed subset of a compact space. -/
theorem IsCompact_IsFree : IsCompact (IsFree (i := i)) :=
  .of_isClosed_subset isCompact_univ free_closed (Set.subset_univ _)

--Also this needs to be generalized to other convex sets. I think it should work for any
--(well-behaved?) Mixable instance, it certainly works for any `Convex` set (of which `IsFree`
-- is one, the only relevant property here is `free_convex`.
theorem IsFree.mix {Œπ : Type*} [FreeStateTheory Œπ] {i : Œπ} {œÉ‚ÇÅ œÉ‚ÇÇ : MState (H i)}
    (hœÉ‚ÇÅ : IsFree œÉ‚ÇÅ) (hœÉ‚ÇÇ : IsFree œÉ‚ÇÇ) (p : Prob) : IsFree (p [œÉ‚ÇÅ ‚Üî œÉ‚ÇÇ]) := by
  obtain ‚ü®m, hm‚ÇÅ, hm‚ÇÇ‚ü© := free_convex (i := i) ‚ü®œÉ‚ÇÅ, hœÉ‚ÇÅ, rfl‚ü© ‚ü®œÉ‚ÇÇ, hœÉ‚ÇÇ, rfl‚ü© p.zero_le (1 - p).zero_le (by simp)
  simp [Mixable.mix, Mixable.mix_ab, MState.instMixable]
  simp at hm‚ÇÇ
  convert ‚Üê hm‚ÇÅ

end FreeStateTheory

open UnitalPretheory
open FreeStateTheory

class UnitalFreeStateTheory (Œπ : Type*) extends FreeStateTheory Œπ, UnitalPretheory Œπ

namespace UnitalFreeStateTheory

--Things like asymptotically free operations, measures of non-freeness, etc. that can be stated
--entirely in terms of the free states (without referring to operations) go here.

variable {Œπ : Type*} [UnitalFreeStateTheory Œπ] {i : Œπ}

theorem _root_.FreeStateTheory.IsFree.npow {i : Œπ} {œÅ : MState (H i)}
    (hœÅ : IsFree œÅ) (n : ‚Ñï) : IsFree (œÅ‚äó^S[n]) := by
  induction n
  ¬∑ rw [statePow_zero, spacePow_zero]
    apply IsFree.of_unique
  ¬∑ rw [statePow_succ]
    exact FreeStateTheory.free_prod ‚Äπ_‚Ä∫ hœÅ

@[simp]
theorem relabel_cast_isFree {i j : Œπ} (œÅ : MState (H i)) (h : j = i) {h' : H j = H i}:
    œÅ.relabel (Equiv.cast h') ‚àà IsFree ‚Üî œÅ ‚àà IsFree := by
  subst h
  simp

open NNReal

/-- In a `FreeStateTheory`, we have free states of full rank, therefore the minimum relative entropy
of any state `œÅ` to a free state is finite. -/
@[aesop (rule_sets := [finiteness]) safe]
lemma relativeEntResource_ne_top (œÅ : MState (H i)) : ‚®Ö œÉ ‚àà IsFree, ùêÉ(œÅ‚ÄñœÉ) ‚â† ‚ä§ := by
  let ‚ü®w,h‚ü© := free_fullRank i
  apply ne_top_of_le_ne_top _ (iInf_le _ w)
  simp only [ne_eq, iInf_eq_top, Classical.not_imp]
  constructor
  ¬∑ exact h.2
  ¬∑ refine ne_of_apply_ne ENNReal.toEReal (qRelativeEnt_ker (œÅ := œÅ) (?_) ‚ñ∏ EReal.coe_ne_top _)
    convert @bot_le _ _ (Submodule.instOrderBot) _
    exact h.1.toLin_ker_eq_bot
  /-
  simp only [ne_eq, iInf_eq_top, not_forall]
  obtain ‚ü®œÉ, hœÉ‚ÇÅ, hœÉ‚ÇÇ‚ü© := FreeStateTheory.free_fullRank i
  use œÉ, hœÉ‚ÇÇ
  rw [qRelativeEnt]
  split_ifs with h
  ¬∑ simp --should be `finiteness`, TODO debug
  contrapose! h
  convert bot_le
  exact hœÉ‚ÇÅ.toLin_ker_eq_bot
  -/

noncomputable def RelativeEntResource : MState (H i) ‚Üí ‚Ñù‚â•0 :=
    fun œÅ ‚Ü¶ (‚®Ö œÉ ‚àà IsFree, ùêÉ(œÅ‚ÄñœÉ)).untop (relativeEntResource_ne_top œÅ)

scoped notation "ùëÖ·µ£" => RelativeEntResource

theorem exists_isFree_relativeEntResource (œÅ : MState (H i)) :
    ‚àÉ œÉ ‚àà IsFree, ùêÉ(œÅ‚ÄñœÉ) = ùëÖ·µ£ œÅ := by
  obtain ‚ü®œÉ, hœÉ‚ÇÅ, hœÉ‚ÇÇ‚ü© := IsCompact_IsFree.exists_isMinOn_lowerSemicontinuousOn
    (s := IsFree (i := i)) (f := fun œÉ ‚Ü¶ ùêÉ(œÅ‚ÄñœÉ))
    Set.Nonempty.of_subtype (by fun_prop)
  use œÉ, hœÉ‚ÇÅ
  rw [RelativeEntResource, ‚Üê hœÉ‚ÇÇ.iInf_eq hœÉ‚ÇÅ, ENNReal.ofNNReal, WithTop.coe_untop, iInf_subtype']

theorem RelativeEntResource.Subadditive (œÅ : MState (H i)) : Subadditive fun n ‚Ü¶ ùëÖ·µ£ (œÅ‚äó^S[n]) := by
  intro m n
  obtain ‚ü®œÉ‚ÇÇ, hœÉ‚ÇÇf, hœÉ‚ÇÇd‚ü© := exists_isFree_relativeEntResource (œÅ‚äó^S[m])
  obtain ‚ü®œÉ‚ÇÉ, hœÉ‚ÇÉf, hœÉ‚ÇÉd‚ü© := exists_isFree_relativeEntResource (œÅ‚äó^S[n])
  simp only [RelativeEntResource, ‚Üê NNReal.coe_add, coe_le_coe]
  rw [‚Üê ENNReal.coe_le_coe]
  simp [RelativeEntResource, ENNReal.ofNNReal] at hœÉ‚ÇÇd hœÉ‚ÇÉd ‚ä¢
  rw [‚Üê hœÉ‚ÇÇd, ‚Üê hœÉ‚ÇÉd]
  clear hœÉ‚ÇÇd hœÉ‚ÇÉd
  have ht‚ÇÅ : i ^ (m + n) = i ^ m * i ^ n :=
    spacePow_add m n
  have ht := congrArg H ht‚ÇÅ
  refine le_trans (biInf_le (i := (œÉ‚ÇÇ ‚äó·µ£ œÉ‚ÇÉ).relabel (Equiv.cast ht)) _ ?_) ?_
  ¬∑ simpa [ht‚ÇÅ] using free_prod hœÉ‚ÇÇf hœÉ‚ÇÉf
  ¬∑ apply le_of_eq
    rw [‚Üê qRelEntropy_prodRelabel]
    gcongr
    ¬∑ apply statePow_add
    ¬∑ rw [‚Üê eq_cast_iff_heq]
      apply MState.relabel_cast

noncomputable def RegularizedRelativeEntResource (œÅ : MState (H i)) : ‚Ñù‚â•0 :=
  ‚ü®(RelativeEntResource.Subadditive œÅ).lim, by
    rw [Subadditive.lim]
    apply Real.sInf_nonneg
    rintro x ‚ü®x, hx, rfl‚ü©
    positivity‚ü©

scoped notation "ùëÖ·µ£‚àû" => RegularizedRelativeEntResource

/-- Lemma 5 -/
theorem RelativeEntResource.tendsto (œÅ : MState (H i)) :
    Filter.atTop.Tendsto (fun n ‚Ü¶ ùëÖ·µ£ (œÅ‚äó^S[n]) / n) (ùìù (ùëÖ·µ£‚àû œÅ)) := by
  rw [‚Üê NNReal.tendsto_coe]
  apply (RelativeEntResource.Subadditive œÅ).tendsto_lim
  use 0
  rintro _ ‚ü®y, rfl‚ü©
  positivity

/-- Alternate version of Lemma 5 which states the convergence with the `ENNReal`
expression for `RelativeEntResource`, as opposed its `untop`-ped `NNReal` value. -/
theorem RelativeEntResource.tendsto_ennreal (œÅ : MState (H i)) :
    Filter.atTop.Tendsto (fun n ‚Ü¶ (‚®Ö œÉ ‚àà IsFree, ùêÉ(œÅ‚äó^S[n]‚ÄñœÉ)) / ‚Üën) (ùìù (ùëÖ·µ£‚àû œÅ)) := by
  refine Filter.Tendsto.congr' ?_ (ENNReal.tendsto_coe.mpr <| RelativeEntResource.tendsto œÅ)
  rw [Filter.EventuallyEq, Filter.eventually_atTop]
  use 1; intros
  rw [RelativeEntResource, ENNReal.coe_div (by positivity), ENNReal.coe_natCast]
  congr
  apply WithTop.coe_untop

noncomputable def GlobalRobustness {i : Œπ} : MState (H i) ‚Üí ‚Ñù‚â•0 :=
  fun œÅ ‚Ü¶ sInf {s | ‚àÉ œÉ, (‚ü®1 / (1+s), by bound‚ü© [œÅ ‚Üî œÉ]) ‚àà IsFree}

/-- A sequence of operations `f_n` is asymptotically nongenerating if `lim_{n‚Üí‚àû} RG(f_n(œÅ_n)) = 0`, where
RG is `GlobalRobustness` and `œÅ_n` is any sequence of free states. Equivalently, we can take the `max` (
over operations and states) on the left-hand side inside the limit.
-/
def IsAsymptoticallyNongenerating (dI dO : Œπ) (f : (n : ‚Ñï) ‚Üí CPTPMap (H (dI‚äó^H[n])) (H (dO‚äó^H[n]))) : Prop :=
  ‚àÄ (œÅs : (n : ‚Ñï) ‚Üí MState (H (dI‚äó^H[n]))), (‚àÄ n, IsFree (œÅs n)) ‚Üí
  Filter.atTop.Tendsto (fun n ‚Ü¶ GlobalRobustness ((f n) (œÅs n))) (ùìù 0)

end UnitalFreeStateTheory


================================================================================
FILE: QuantumInfo/Finite/ResourceTheory/HypothesisTesting.lean
TYPE: Lean 4
SIZE: 22681 characters
================================================================================

import Mathlib.Algebra.Module.Submodule.Lattice
import Mathlib.Analysis.Subadditive
import Mathlib.CategoryTheory.Functor.FullyFaithful
import Mathlib.CategoryTheory.Monoidal.Braided.Basic
import Mathlib.Data.EReal.Basic

import QuantumInfo.Finite.CPTPMap
import QuantumInfo.Finite.Entropy
import QuantumInfo.Finite.POVM

/-!
Defines `OptimalHypothesisRate`, the optimal rate of distinguishing an `MState` œÅ from a set of other
mixed states `S`, with at most Type I error Œµ.

That is to say: take a projective measurement (a `POVM`) with elements `{T, 1-T}`, where measuring `T`
will mean we conclude our unknown state was œÅ, and measuring `1-T` will mean we think the state was
something in `S`. We only accept T's such that `Tr[(1-T)œÅ] ‚â§ Œµ`, that is, we have at most an Œµ
probability of incorrectly concluding it was œÅ. The Type II error associated to this T is then
`max_{œÉ ‚àà S} Tr[T œÉ]`, that is, the (worst possible, over possible states) chance of incorrectly
concluding our state was in `S`. Optimize over `T` to get the lowest possible Type II error rate,
and the resulting error rate is `OptimalHypothesisRate œÅ Œµ S`.

We make this accessible through the notation `Œ≤_ Œµ(œÅ‚ÄñS)`.

See [The tangled state of quantum hypothesis testing](https://doi.org/10.1038/s41567-023-02289-9) by
Mario Berta et al. for a broader overview.
-/

open NNReal
open ComplexOrder
open Topology
open Prob

variable {d : Type*} [Fintype d] [DecidableEq d]

/-- The optimal hypothesis testing rate, for a tolerance Œµ: given a state œÅ and a set of states S,
the optimum distinguishing rate that allows a probability Œµ of errors. -/
noncomputable def OptimalHypothesisRate (œÅ : MState d) (Œµ : Prob) (S : Set (MState d)) : Prob :=
  ‚®Ö T : { m : HermitianMat d ‚ÑÇ // œÅ.exp_val (1 - m) ‚â§ Œµ ‚àß 0 ‚â§ m ‚àß m ‚â§ 1},
    ‚®Ü œÉ ‚àà S, ‚ü®_, œÉ.exp_val_prob T.prop.right‚ü©

scoped[OptimalHypothesisRate] notation "Œ≤_" Œµ " (" œÅ "‚Äñ" S ")" =>  OptimalHypothesisRate œÅ Œµ S

namespace OptimalHypothesisRate

/-- The space of strategies `T` in `OptimalHypothesisRate` is inhabited, we always have some valid strategy. -/
instance iInf_Inhabited (œÅ : MState d) (Œµ : Prob) :
    Inhabited { m // œÅ.exp_val (1 - m) ‚â§ Œµ ‚àß 0 ‚â§ m ‚àß m ‚â§ 1 } :=
  ‚ü®1, by simp‚ü©

instance (œÅ : MState d) (Œµ : Prob) : Inhabited {m | œÅ.exp_val (1 - m) ‚â§ Œµ ‚àß 0 ‚â§ m ‚àß m ‚â§ 1} :=
  iInf_Inhabited œÅ Œµ

/-- The space of strategies `T` in `OptimalHypothesisRate` is compact. -/
theorem iInf_IsCompact (œÅ : MState d) (Œµ : Prob) : IsCompact { m | œÅ.exp_val (1 - m) ‚â§ Œµ ‚àß 0 ‚â§ m ‚àß m ‚â§ 1 } := by
  have hC‚ÇÅ : IsCompact {m : HermitianMat d ‚ÑÇ | 0 ‚â§ m ‚àß m ‚â§ 1} :=
    HermitianMat.unitInterval_IsCompact
  have hC‚ÇÇ : IsClosed {m | œÅ.exp_val (1 - m) ‚â§ Œµ} := by
    --This is a linear constraint and so has a closed image
    change IsClosed ((fun m ‚Ü¶ œÅ.M.inner_BilinForm (1 - m)) ‚Åª¬π' (Set.Iic Œµ))
    refine IsClosed.preimage ?_ isClosed_Iic
    fun_prop
  exact hC‚ÇÅ.inter_left hC‚ÇÇ

/-- The space of strategies `T` in `OptimalHypothesisRate` is convex. -/
theorem iInf_IsConvex (œÅ : MState d) (Œµ : Prob) : Convex ‚Ñù { m | œÅ.exp_val (1 - m) ‚â§ Œµ ‚àß 0 ‚â§ m ‚àß m ‚â§ 1 } := by
  --We *could* get this from a more general fact that any linear subspace is convex,
  --and the intersection of convex spaces is convex, and this is an intersection of
  --three convex spaces. That would be more broken-down and lemmaified.
  rintro x ‚ü®hx‚ÇÅ, hx‚ÇÇ, hx‚ÇÉ‚ü© y ‚ü®hy‚ÇÅ, hy‚ÇÇ, hy‚ÇÉ‚ü© a b ha hb hab
  rw [‚Üê eq_sub_iff_add_eq'] at hab
  subst b
  refine And.intro ?_ (And.intro ?_ ?_)
  ¬∑ simp only [MState.exp_val, HermitianMat.inner_left_sub, HermitianMat.inner_one, MState.tr,
      tsub_le_iff_right, HermitianMat.inner_left_distrib, HermitianMat.inner_smul] at hx‚ÇÅ hy‚ÇÅ ‚ä¢
    linear_combination a * hx‚ÇÅ + (1 - a) * hy‚ÇÅ
  ¬∑ apply HermitianMat.convex_cone <;> assumption
  ¬∑ --Something's wrong with type class inference that's taking wayyy longer than it should.
    --DFunLike.coe is being unfolded tonnnnss of times.
    rw [‚Üê sub_nonneg] at hx‚ÇÉ hy‚ÇÉ ‚ä¢
    convert HermitianMat.convex_cone hx‚ÇÉ hy‚ÇÉ ha hb using 1
    simp only [sub_smul, one_smul, smul_sub]
    abel

/-- When `S` is empty, the optimal hypothesis testing rate is zero. -/
@[simp]
theorem of_empty {œÅ : MState d} (Œµ : Prob) : Œ≤_ Œµ(œÅ‚Äñ‚àÖ) = 0 := by
  simp [OptimalHypothesisRate]
  rfl

theorem le_sup_exp_val {œÅ : MState d} (Œµ : Prob) {S : Set (MState d)}
    (m : HermitianMat d ‚ÑÇ) (hExp : œÅ.exp_val (1 - m) ‚â§ Œµ) (hm : 0 ‚â§ m ‚àß m ‚â§ 1) :
    Œ≤_ Œµ(œÅ‚ÄñS) ‚â§ ‚®Ü œÉ ‚àà S, ‚ü®_, œÉ.exp_val_prob hm‚ü© := by
  unfold OptimalHypothesisRate
  apply iInf_le_of_le ‚ü®m, ‚ü®hExp, hm‚ü©‚ü© _
  simp only [le_refl]

theorem le_of_subset (œÅ : MState d) (Œµ : Prob) {S1 S2 : Set (MState d)} (h : S1 ‚äÜ S2) :
    Œ≤_ Œµ(œÅ‚ÄñS1) ‚â§ Œ≤_ Œµ(œÅ‚ÄñS2) :=
  iInf_mono (fun _ ‚Ü¶ iSup_le_iSup_of_subset h)

theorem of_singleton {œÅ œÉ : MState d} {Œµ : Prob} :
    Œ≤_ Œµ(œÅ‚Äñ{œÉ}) =
      ‚®Ö T : { m : HermitianMat d ‚ÑÇ // œÅ.exp_val (1 - m) ‚â§ Œµ ‚àß 0 ‚â§ m ‚àß m ‚â§ 1},
        ‚ü®_, œÉ.exp_val_prob T.2.right‚ü© := by
  simp only [OptimalHypothesisRate, iSup_singleton]

open scoped Prob in
theorem negLog_le_singleton (œÅ : MState d) (Œµ : Prob) (S : Set (MState d))
    (œÉ : MState d) (h : œÉ ‚àà S) : ‚Äîlog Œ≤_ Œµ(œÅ‚ÄñS) ‚â§ ‚Äîlog Œ≤_ Œµ(œÅ‚Äñ{œÉ}) := by
  apply Prob.negLog_Antitone
  apply le_of_subset
  exact Set.singleton_subset_iff.mpr h

theorem singleton_le_exp_val {œÅ œÉ : MState d} {Œµ : Prob} (m : HermitianMat d ‚ÑÇ)
    (hExp : œÅ.exp_val (1 - m) ‚â§ Œµ) (hm : 0 ‚â§ m ‚àß m ‚â§ 1) :
  Œ≤_ Œµ(œÅ‚Äñ{œÉ}) ‚â§ ‚ü®_, œÉ.exp_val_prob hm‚ü© := by
  rw [of_singleton]
  apply iInf_le_of_le ‚ü®m, ‚ü®hExp, hm‚ü©‚ü© _
  simp only [le_refl]

/-- There exists an optimal T for the hypothesis testing, that is, it's a minimum
and not just an infimum. This states we have `1 - Œµ ‚â§ œÅ.exp_val T`, but we can always
"worsen" T to make that bound tight, which is `exists_min`. -/
theorem exists_min' (œÅ : MState d) (Œµ : Prob) (S : Set (MState d)):
    ‚àÉ (T : { m : HermitianMat d ‚ÑÇ // œÅ.exp_val (1 - m) ‚â§ Œµ ‚àß 0 ‚â§ m ‚àß m ‚â§ 1}),
      (‚®Ü œÉ ‚àà S, ‚ü®_, œÉ.exp_val_prob T.prop.right‚ü© = Œ≤_ Œµ(œÅ‚ÄñS))
      ‚àß 1 - Œµ ‚â§ œÅ.exp_val T := by
  have _ : Nonempty d := œÅ.nonempty
  rcases S.eq_empty_or_nonempty with rfl | hS
  ¬∑ simpa [-Subtype.exists] using ‚ü®rfl, ‚ü®1, by simp‚ü©, by simp‚ü©
  rw [‚Üê Set.nonempty_coe_sort] at hS
  obtain ‚ü®T, hT‚ÇÅ, hT‚ÇÇ‚ü© := IsCompact.exists_isMinOn (Œ± := Prob)
    (isCompact_iff_isCompact_univ.mp (iInf_IsCompact œÅ Œµ)) Set.univ_nonempty
    (f := fun T ‚Ü¶ ‚®Ü œÉ ‚àà S, ‚ü®_, œÉ.exp_val_prob T.prop.right‚ü©)
    (by
      have h := HermitianMat.inner_BilinForm.continuous_iSup_fst
        (Bornology.isBounded_induced.mp (Bornology.IsBounded.all S))
      apply Continuous.continuousOn
      simp_rw [‚Üê iSup_subtype'', subtype_val_iSup' (Œπ := S)]
      refine Continuous.subtype_mk ?_ _
      refine Continuous.comp (g := fun T ‚Ü¶ ‚®Ü (i : S), i.val.exp_val T) ?_ continuous_subtype_val
      convert h with T
      rw [‚Üê sSup_image' (s := S) (f := fun i ‚Ü¶ i.exp_val T)]
      rw [‚Üê sSup_image' (s := (MState.M '' S)) (f := fun i ‚Ü¶ i.inner_BilinForm T)]
      simp [Set.image, MState.exp_val]
    )
  clear hT‚ÇÅ

  use T
  constructor
  ¬∑ simp only [isMinOn_univ_iff] at hT‚ÇÇ
    rw [OptimalHypothesisRate]
    --Why is the following three bundled together not a theorem? Is it, and I can't find it? TODO
    apply le_antisymm
    ¬∑ exact le_iInf hT‚ÇÇ
    ¬∑ exact iInf_le_iff.mpr fun _ a ‚Ü¶ a T
  ¬∑ simpa [MState.exp_val_sub, add_comm (Œµ : ‚Ñù) _] using T.2.1

--TODO: Maybe we should define these two instances.
-- Then we can get rid of `Prob.sub_zero` and use the generic `tsub_zero`.
-- #synth AddCommMonoid Prob
-- #synth OrderedSub Prob

/-- There exists an optimal T for the hypothesis testing, that is, it's a minimum and
not just an infimum. This tightens the `T` from `exists_min'` to a `‚ü™œÅ,T‚ü´ = 1 - Œµ` bound. -/
theorem exists_min (œÅ : MState d) (Œµ : Prob) (S : Set (MState d)):
    ‚àÉ (T : { m : HermitianMat d ‚ÑÇ // œÅ.exp_val (1 - m) ‚â§ Œµ ‚àß 0 ‚â§ m ‚àß m ‚â§ 1}),
      (‚®Ü œÉ ‚àà S, ‚ü®_, œÉ.exp_val_prob T.prop.right‚ü© = Œ≤_ Œµ(œÅ‚ÄñS))
      ‚àß œÅ.exp_val T = 1 - Œµ := by
  obtain ‚ü®T, hT‚ÇÅ, hT‚ÇÇ‚ü© := exists_min' œÅ Œµ S

  --Instead of just `use T`, we (may) have to reduce it so that it saturates the ‚ü™œÅ,T‚ü´ = 1 - Œµ bound.
  --We do this by multiplying it by a scalar less than 1 to get a `T'`. Since this operator is less
  --than T, it's still optimal in terms of achieving `Œ≤_ Œµ(œÅ‚ÄñS)`, but it can get the `1 - Œµ` bound instead.
  set Œ¥ := œÅ.exp_val ‚ÜëT - (1 - Œµ)-- with Œ¥_def
  by_cases hŒ¥ : Œ¥ = 0
  ¬∑ use T, hT‚ÇÅ
    linarith
  replace hŒ¥ : 0 < Œ¥ := by linarith +splitNe
  have hŒ¥_le : Œ¥ ‚â§ 1 := by
    linarith [œÅ.exp_val_le_one T.2.2.2, Œµ.2]

  have hTr : 0 < œÅ.exp_val T := by
    linarith [Œµ.coe_le_one]

  set T' : HermitianMat d ‚ÑÇ :=
    (1 - Œ¥ / œÅ.exp_val T) ‚Ä¢ T with hT'_def
  have hT'_le : T' ‚â§ T := by
    rw [‚Üê one_smul ‚Ñù T.val, hT'_def]
    gcongr
    ¬∑ exact T.2.2.1
    ¬∑ simp; positivity
  have hœÅT' : œÅ.exp_val (1 - T') = Œµ := by
    simp [T', MState.exp_val_sub, Œ¥, field]

  have hT' : œÅ.exp_val (1 - T') ‚â§ Œµ ‚àß 0 ‚â§ T' ‚àß T' ‚â§ 1 := by
    use hœÅT'.le
    constructor
    ¬∑ simp [T']
      refine smul_nonneg ?_ T.2.2.1
      bound
    ¬∑ exact hT'_le.trans T.2.2.2
  use ‚ü®T', hT'‚ü©

  constructor
  ¬∑ rw [OptimalHypothesisRate] at hT‚ÇÅ ‚ä¢
    apply le_antisymm
    ¬∑ apply le_iInf
      intro i
      refine le_trans ?_ (le_of_eq_of_le hT‚ÇÅ ?_)
      ¬∑ gcongr
      ¬∑ exact iInf_le_iff.mpr fun _ a ‚Ü¶ a i
    ¬∑ exact iInf_le_iff.mpr fun _ a ‚Ü¶ a ‚ü®T', hT'‚ü©
  ¬∑ simp [MState.exp_val_sub, ‚Üê hœÅT']

/-- When the allowed Type I error `Œµ` is less than 1 (so, we have some limit on our errors),
and the kernel of the state `œÅ` contains the kernel of some element in `S`, then the optimal
hypothesis rate is positive - there is some lower bound on the type II errors we'll see. In
other words, under these conditions, we cannot completely avoid type II errors. -/
theorem pos_of_lt_one {œÅ : MState d} (S : Set (MState d))
  (hœÅ : ‚àÉ œÉ ‚àà S, œÉ.M.ker ‚â§ œÅ.M.ker)
  {Œµ : Prob} (hŒµ : Œµ < 1) : 0 < Œ≤_ Œµ(œÅ‚ÄñS) := by
  obtain ‚ü®œÉ, hœÉ‚ÇÅ, hœÉ‚ÇÇ‚ü© := hœÅ
  --Assume the converse: that the infimum is zero. The set of such T's is inhabited
  --and closed, so there is some T that attains the value zero. This T has zero
  --inner product with œÉ (`œÉ.exp_val T = 0`), and yet (by definition of T's type) we
  --also have that `œÅ.exp_val (1 - T) ‚â§ Œµ < 1`. So `T` lives entirely in œÉ's kernel,
  --which (by `h_supp`) is contained in œÅ's kernel. So
  --`œÅ.exp_val (1 - T) = œÅ.exp_val 1 - œÅ.exp_val T = œÅ.trace - 0 = 1`, a contradiction.
  by_contra h
  obtain ‚ü®‚ü®T, hT‚ÇÅ, hT‚ÇÇ, hT‚ÇÉ‚ü©, hT‚ÇÑ, hT‚ÇÖ‚ü© := exists_min œÅ Œµ S
  rw [‚Üê bot_eq_zero'', not_bot_lt_iff] at h
  rw [h, iSup_eq_bot, bot_eq_zero''] at hT‚ÇÑ
  specialize hT‚ÇÑ œÉ
  simp only [iSup_pos hœÉ‚ÇÅ, Subtype.ext_iff, Set.Icc.coe_zero, MState.exp_val] at hT‚ÇÑ
  rw [HermitianMat.inner_zero_iff œÉ.zero_le hT‚ÇÇ] at hT‚ÇÑ
  replace hT‚ÇÅ : œÅ.exp_val (1 - T) ‚â† 1 := (lt_of_le_of_lt hT‚ÇÅ hŒµ).ne
  absurd hT‚ÇÅ
  rw [œÅ.exp_val_eq_one_iff ?_, sub_sub_cancel]
  ¬∑ grw [‚Üê hT‚ÇÑ]
    rwa [HermitianMat.ker, HermitianMat.ker, ContinuousLinearMap.ker_le_ker_iff_range_le_range] at hœÉ‚ÇÇ
    ¬∑ simp
    ¬∑ simp
  ¬∑ exact sub_le_self 1 hT‚ÇÇ

--Lemma 3 from Hayashi
theorem Lemma3 {œÅ : MState d} (Œµ : Prob) {S : Set (MState d)} (hS‚ÇÅ : IsCompact S)
    (hS‚ÇÇ : Convex ‚Ñù (MState.M '' S)) : ‚®Ü œÉ ‚àà S, Œ≤_ Œµ(œÅ‚Äñ{œÉ}) = Œ≤_ Œµ(œÅ‚ÄñS) := by

  --Work out the case where S is empty, so we can now assume it's nonempty
  rcases S.eq_empty_or_nonempty with rfl|hnS
  ¬∑ simpa using bot_eq_zero''
  --Upgrade this fact to an instance
  have _ : Nonempty S := hnS.to_subtype

  simp only [OptimalHypothesisRate, Set.mem_singleton_iff, iSup_iSup_eq_left]

  --This parts needs the minimax theorem. Set up the relevant sets and hypotheses.
  --The function `f` will be the `MState.exp_val` function, but bundled as a bilinear form.
  let f : LinearMap.BilinForm ‚Ñù (HermitianMat d ‚ÑÇ) := HermitianMat.inner_BilinForm
  let S' : Set (HermitianMat d ‚ÑÇ) := MState.M '' S
  let T' : Set (HermitianMat d ‚ÑÇ) := { m | œÅ.exp_val (1 - m) ‚â§ Œµ ‚àß 0 ‚â§ m ‚àß m ‚â§ 1 }

  have hS'‚ÇÅ : IsCompact S' := hS‚ÇÅ.image MState.Continuous_HermitianMat

  have hT'‚ÇÅ : IsCompact T' := iInf_IsCompact œÅ Œµ

  have hT'‚ÇÇ : Convex ‚Ñù T' := iInf_IsConvex œÅ Œµ

  have hS'‚ÇÉ : S'.Nonempty := by simpa only [Set.image_nonempty, S']

  have hT'‚ÇÉ : T'.Nonempty := Set.Nonempty.of_subtype

  ext1 --turn it from Prob equality into ‚Ñù equality
  convert minimax (M := HermitianMat d ‚ÑÇ) f S' T' hS'‚ÇÅ hT'‚ÇÅ hS‚ÇÇ hT'‚ÇÇ hS'‚ÇÉ hT'‚ÇÉ
  --The remaining twiddling is about moving the casts inside the iInf's and iSup's.
  --In a better world, this would be mostly handled by some clever simps or push_cast's.
  ¬∑ have hi := iSup_range' (Œπ := S) (fun x ‚Ü¶ ‚®Ö (y : T'), (f x) ‚Üëy) (¬∑)
    rw [‚Üê Set.image_eq_range] at hi
    rw [‚Üê iSup_subtype'', Set.Icc.coe_iSup (zero_le_one), hi]
    congr!
    exact Set.Icc.coe_iInf zero_le_one
  ¬∑ rw [Set.Icc.coe_iInf (Œπ := T') zero_le_one]
    congr! 2 with y
    have hi := iSup_range' (Œπ := S) (fun x ‚Ü¶ (f x) ‚Üëy) (¬∑)
    rw [‚Üê Set.image_eq_range] at hi
    rw [‚Üê iSup_subtype'', Set.Icc.coe_iSup zero_le_one, hi]
    rfl

--Maybe should be phrased in terms of `0 < ...` instead? Maybe belongs in another file? It's kiinnnd of specialized..
theorem ker_diagonal_prob_eq_bot {q : Prob} (hq‚ÇÅ : 0 < q) (hq‚ÇÇ : q < 1) :
    HermitianMat.ker (.diagonal (Distribution.coin q ¬∑)) = ‚ä• := by
  apply Matrix.PosDef.toLin_ker_eq_bot
  apply Matrix.PosDef.diagonal
  intro i; fin_cases i
  ¬∑ simpa
  ¬∑ simpa [‚Üê Complex.ofReal_one, Complex.real_lt_real]

variable {d‚ÇÇ : Type*} [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ] in
/-- Lemma S1 -/
theorem optimalHypothesisRate_antitone (œÅ œÉ : MState d) (‚Ñ∞ : CPTPMap d d‚ÇÇ) (Œµ : Prob) :
    Œ≤_ Œµ(œÅ‚Äñ{œÉ}) ‚â§ Œ≤_ Œµ(‚Ñ∞ œÅ‚Äñ{‚Ñ∞ œÉ}) := by
  simp only [of_singleton]
  obtain ‚ü®‚Ñ∞dualSubtype, h‚ü© :
      ‚àÉ e : ({ m : HermitianMat d‚ÇÇ ‚ÑÇ // (‚Ñ∞ œÅ).exp_val (1 - m) ‚â§ Œµ ‚àß 0 ‚â§ m ‚àß m ‚â§ 1} ‚Üí
      { m : HermitianMat d ‚ÑÇ // œÅ.exp_val (1 - m) ‚â§ Œµ ‚àß 0 ‚â§ m ‚àß m ‚â§ 1}),
      ‚àÄ x, e x = ‚Ñ∞.hermDual x
       := by
    constructor; swap
    ¬∑ rintro ‚ü®m, hm‚ÇÅ, hm‚ÇÇ‚ü©
      refine ‚ü®‚Ñ∞.toPTPMap.hermDual m, ?_, PTPMap.hermDual.PTP_POVM ‚Ñ∞.toPTPMap hm‚ÇÇ‚ü©
      have h‚Ñ∞d : (‚Ñ∞ œÅ).exp_val (1 - m) = œÅ.exp_val (‚Ñ∞.hermDual (1 - m)) :=
        ‚Ñ∞.exp_val_hermDual œÅ (1 - m)
      simpa [h‚Ñ∞d] using hm‚ÇÅ
    ¬∑ rintro ‚ü®m, hm‚ÇÅ, hm‚ÇÇ‚ü©
      rfl
  convert le_iInf_comp _ ‚Ñ∞dualSubtype
  rename_i T'
  specialize h T'
  rw [h]
  exact ‚Ñ∞.exp_val_hermDual œÉ T'

open scoped HermitianMat in
open scoped Prob in
/-- This is from [Strong converse exponents for a quantum channel discrimination problem
and quantum-feedback-assisted communication](https://doi.org/10.1007/s00220-016-2645-4), Lemma 5.

It seems like this is actually true for all 0 < Œ± (with appropriate modifications at Œ± = 1), but we only need
it for the case of 1 < Œ±.
-/
theorem Ref81Lem5 (œÅ œÉ : MState d) (Œµ : Prob) (hŒµ : Œµ < 1) (Œ± : ‚Ñù) (hŒ± : 1 < Œ±) :
    ‚Äîlog Œ≤_ Œµ(œÅ‚Äñ{œÉ}) ‚â§ DÃÉ_ Œ±(œÅ‚ÄñœÉ) + ‚Äîlog (1 - Œµ) *
      (.ofNNReal ‚ü®Œ±, zero_le_one.trans hŒ±.le‚ü©) / (.ofNNReal ‚ü®Œ± - 1, sub_nonneg_of_le hŒ±.le‚ü©)
    := by
  generalize_proofs pf1 pf2
  --If œÅ isn't in the support of œÉ, the right hand side is just ‚ä§. (The left hand side is not, necessarily!)
  by_cases h_supp : œÉ.M.ker ‚â§ œÅ.M.ker
  swap
  ¬∑ simp [SandwichedRelRentropy, h_supp]

  --Now we know that œÅ.support ‚â§ œÉ.support. This is the main case we actually care about.
  --Proof from https://link.springer.com/article/10.1007/s00220-016-2645-4 reproduced below.
  /-
  Lemma 5. Let œÅ, œÉ ‚àà S (H) be such that supp œÅ ‚äÜ supp œÉ . For any Q ‚àà B(H) such
    that 0 ‚â§ Q ‚â§ I , and any Œ± > 1,
    ‚àí log Tr[QœÉ] ‚â§ DÀúŒ± (œÅ‚ÄñœÉ) ‚àí Œ± / (Œ±‚àí1) * log Tr[QœÅ]. (3.7)
    In particular, for any Œ± > 1 and any Œµ ‚àà (0, 1),
    D^Œµ_H (œÅ‚ÄñœÉ) ‚â§ DÀúŒ± (œÅ‚ÄñœÉ) + Œ± / (Œ±‚àí1) * log(1 / (1‚àíŒµ)). (3.8)
    Proof. Let p ‚â° Tr {QœÅ} and q ‚â° Tr {QœÉ}. By the monotonicity of the sandwiched
    R√©nyi relative entropy for Œ± > 1, we find that
    DÀúŒ± (œÅ‚ÄñœÉ) ‚â• DÀúŒ± ((p, 1 ‚àí p) ‚Äñ (q, 1 ‚àí q)) (3.9)
      = 1 / (Œ±‚àí1) * log[p^Œ± * q^(1‚àíŒ±) + (1‚àíp)^Œ± * (1‚àíq)^(1‚àíŒ±) ] (3.10)
      ‚â• 1 / (Œ±‚àí1) * log[p^Œ± * q^(1‚àíŒ±) ] (3.11)
      = Œ± / (Œ±‚àí1) * log p ‚àí log q, (3.12)
    from which (3.7) follows. The statement in (3.8) follows by optimizing over all Q such
    that Tr {QœÅ} ‚â• 1 ‚àí Œµ.
  -/
  -- The "monotonicity of the ..." part here refers to the data processing inequality, and
  -- the (p, 1-p) and (q,1-q) refer to states which are qubits ("coins") of probability p and
  -- q, respectively. The states œÅ and œÉ can be "processed" into these coins by measuring the optimal T.

  have h‚ÇÇ : 0 < 1 - Œµ.val := by
    change Œµ.val < 1 at hŒµ
    linarith

  let p : Prob := 1 - Œµ
  set q : Prob := Œ≤_ Œµ(œÅ‚Äñ{œÉ})
  let p2 : MState (Fin 2) := .ofClassical <| .coin p
  let q2 : MState (Fin 2) := .ofClassical <| .coin q

  --Show there's a lower bound on Œ≤_Œµ, that you can't do perfect discrimination
  --It's possible that we actually don't want this here, that it should "follow"
  --from the main proof.
  have hq : 0 < q := pos_of_lt_one {œÉ} ‚ü®œÉ, rfl, h_supp‚ü© hŒµ

  suffices ‚Äîlog q ‚â§ DÃÉ_ Œ±(p2‚Äñq2) + ‚Äîlog (1 - Œµ) * (.ofNNReal ‚ü®Œ±, pf1‚ü©) / (.ofNNReal ‚ü®Œ± - 1, pf2‚ü©) by
    refine this.trans (add_le_add_right ?_ _)
    --Show that this is an instance of the Data Processing Inequality
    obtain ‚ü®Œ¶, hŒ¶‚ÇÅ, hŒ¶‚ÇÇ‚ü© : ‚àÉ (Œ¶ : CPTPMap d (Fin 2)), p2 = Œ¶ œÅ 