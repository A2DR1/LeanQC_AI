# Lean 4 Code Generation System Prompt (Chunked Version)

You are an expert Lean 4 theorem prover specializing in quantum information theory. Convert natural language prompts into precise Lean 4 code using the Lean-QuantumInfo repository as reference.

## Your Role
Convert natural language descriptions of mathematical concepts, theorems, and proofs into formal Lean 4 code following the exact patterns, definitions, and conventions from the Lean-QuantumInfo repository.

## Key Repository Patterns

### Probability & Distributions
```lean
def Prob := { p : ‚Ñù // 0 ‚â§ p ‚àß p ‚â§ 1 }
def Distribution (Œ± : Type u) [Fintype Œ±] : Type u :=
  { f : Œ± ‚Üí Prob // Finset.sum Finset.univ (fun i ‚Ü¶ (f i : ‚Ñù)) = 1 }
```

### Quantum States
```lean
structure MState (d : Type*) [Fintype d] :=
  m : Matrix d d ‚ÑÇ
  pos : m.PosSemidef
  tr : m.trace = 1

structure Bra (d : ‚Ñï) :=
  vec : Fin d ‚Üí ‚ÑÇ
  normalized' : ‚àë i, ‚Äñvec i‚Äñ^2 = 1
```

### Entropy Functions
```lean
def shannon_entropy (p : Distribution Œ±) : ‚Ñù :=
  -‚àë x, (p.val x).toReal * Real.log (p.val x).toReal

def von_neumann_entropy (œÅ : MState d) : ‚Ñù :=
  -‚àë i, (eigenvalues œÅ.m i).toReal * Real.log (eigenvalues œÅ.m i).toReal
```

## Response Format
1. **Analysis**: Explain the mathematical concept
2. **Lean Code**: Complete implementation with imports
3. **Explanation**: Key components and mathematical meaning
4. **Dependencies**: Required imports and related definitions

## Guidelines
- Use Unicode: `‚Ñù`, `‚Ñï`, `‚ÑÇ`, `‚Üí`, `‚Üî`, `‚àß`, `‚à®`, `‚àÄ`, `‚àÉ`
- Include docstrings: `/-- ... -/`
- Type annotations: `[Fintype Œ±]`, `[DecidableEq Œ±]`
- Use `sorry` for incomplete proofs
- Follow repository naming conventions
- Reference existing definitions when possible

## Repository Content Reference

The following is a portion of the Lean-QuantumInfo repository content. Use this as reference for code generation:

---

eference works in at least seven meaningfully different ways:

(1) https://www.uio.no/studier/emner/matnat/math/MAT4430/v23/timeplan/lectureblup.pdf, Defn 20.3.

Defines the notion of "(n, m, Œ¥)-coding scheme", a code for m qubits in n copies of the channel, with diamond-norm distance of Œ¥ from the identity channel. Then a rate R is "achievable" if there is a sequence of coding schemes that converge m/n -> R and Œ¥ -> 0. The set of achieveable rates is a closed interval, and the capacity is the maximum of this interval.

(2) https://cs.uwaterloo.ca/~watrous/TQI/TQI.8.pdf, Defn 8.42.

Watrous doesn't use the word "coding scheme", but rather define "emulating" (8.1) an "Œµ-approximation" (8.2) of the identity. This is equivalent to the coding scheme and diamond norm part. Then a rate R is "achievable" if, for every Œ¥>0, there is a k:‚Ñï such that k < n implies the existence of a (n, floor(R*n), Œ¥)-coding scheme. Now the set of achievable rates may be an open or closed interval, and the capacity is the supremum of this interval (not the maximum, since an open interval has no maximum).

(3) Works like https://arxiv.org/pdf/1007.2855 (equation 3) and https://arxiv.org/pdf/1801.02019 (equation 186) define the quantum capacity of C as $Q(C) = lim_n 1/n * Q^{(1)}(C ^ {‚äón})$, where $Q^{(1)}$ is the quantum coherent information (or "one-shot channel capacity"), and so it is the average coherent information achieved across n copies of the channel, in the large-n limit. This definition makes the LSD theorem (which stats that $Q ‚â• Q^{(1)}$) actually entirely trivial, as it requires only the fact that $Q^{(1)}$ is superadditive.

(4) https://arxiv.org/pdf/quant-ph/0304127 (Section 5) and https://arxiv.org/pdf/quant-ph/9809010 specifically distinguish between "subspace transmission", "entanglement transmission", and "entanglement generation" capabilities of the channel. The fact that all three are equal is then a theorem. Option (4), subspace transsmission capacity, is like option (1) above, but instead of the channel having diamond norm at most Œ¥ from the identity channel, we require that the channel has fidelity at least 1-Œ¥ on all inputs. Converging in fidelity is surely equivalent to converging in diamond norm, but the precise bounds are not obvious. (4) also differs from (1) and (2) in that it has an arbitrary dimension input space, instead of specifically a 2^n-dimensional space of qubits. arxiv:9809010 specifically requires a sequence of codes whose limiting fidelity is 1 and rate is R; arxiv:0304127 doesn't actually precisely say.

(5) "Entanglement transmission" asks for a high-entropy state (thus, a large subspace dimension) that can be transmitted through the channel with a high "entanglement fidelity". See equation (52) in arxiv:0304127. The rate achieved is the von Neumann entropy of the state, the set of achievable rates are closed, and the rate of the channel is the maximum.

(6) "Entanglement generation" changes the task from coding. Instead we need a bipartite state œÅ_AB on a Hilbert space of dimension Œ∫, of which the left half goes through the encoder, channel, and decoder. The fidelity between the result C(œÅ) and the maximally entangled state must be at least 1-Œµ. The rates are (1/n)*(log Œ∫), achievable if for all Œ¥ and sufficiently large n (etc. - like option (2)), and we take the supremum.

Note: Option (6) is what Devetak, in arxiv:0304127, actually proves the LSD theorem for. Theorem 5 in that reference. (4), (5), and (6) are proven equal.

(7) Wilde's book also of "coding scheme", but defines it in terms of entanglement generation and the logarithm of the dimension of the space. Instead of fidelity preserved in the entanglement, it's the trace norm. He effectively defines it by supremum, although he doesn't need to use the word, giving an equivalent Œ¥/Œµ definition for coding schemes. He then takes supremum (even though maximum would work as well -- the capacity is itself an achievable rate by his definition). In this way, it combines aspects of definitions (1), (2), and (4). He gives as an exercise showing that small trace norm error of transmitted states implies a small diamond norm error from the identity.

----

To capture the idea of "quantum capacity", and some other idea that turns out to be equivalent, (1), (2), or (5) seems best. The definitions (1) and (2) seem to be the more recently popular ones. Between those two, choosing "supremum" or "maximum", the supremum seems shorter to state in a definition (as it doesn't require proving closure); indeed Mathlib has no notion of "max real" as a function, only a supremum which can also be shown to be in the set. But the definition in (2) of "For every Œ¥>0, there is a k:‚Ñï such that k < n implies the existence of a (...)-coding scheme" is cleaner work with as a way to directly construct or extract codes, as opposed to limits of sequences of codes. And finally, the notions of "emulate" and "approximate" seem useful for defining it more elegantly.

This leads to the final definition in [Capacity.lean](./QuantumInfo/Finite/Capacity.html).
-/


================================================================================
FILE: QuantumInfo/Finite/Channel/DegradableOrder.lean
TYPE: Lean 4
SIZE: 2064 characters
================================================================================

import QuantumInfo.Finite.CPTPMap

/-! # The Degradable Order

We define the "degradable order" on channels, where M ‚â§ N if N can be degraded to M.
This is a scoped instance, because there are other reasonable orders on channels.

The degradable order is actually only a preorder, because channels that are degradable to
each other are not necessarily equal. (For instance, unitary channels are degradable to
the identity and vice versa.) It can compare channels of different output dimensions, but
they must have the same input dimension. For this reason the `DegradablePreorder` is parameterized
by the channel input type.

One might hope that if this was defined on the quotient type of "channels up to unitary equivalence"
that it would become an order; but this is not the case. That is, there are channels `A ‚Üí B` that
are degradable to each other, but cannot be degraded to each other by unitary operations. For instance,
let A be the replacement channel that goes to a mixed state, and B be a replacement channel that goes
to a pure state.

Technical notes: to model "channels of different output types", the preorder is on the Sigma
type of channels parameterized by their output type. And since the output type needs to be a
Fintype and DecidableEq, the argument is also a Sigma to bring this along.
-/

section

def DegradablePreorder (dIn : Type*) [Fintype dIn] [DecidableEq dIn] : Preorder
    (Œ£ dOut : (Œ£ t, Fintype t √ó DecidableEq t), let _ := dOut.snd.1; CPTPMap dIn dOut.fst) where
  le Œõ‚ÇÅ Œõ‚ÇÇ :=
    let _ := Œõ‚ÇÅ.fst.snd.1;
    let _ := Œõ‚ÇÇ.fst.snd.1;
    let _ := Œõ‚ÇÇ.fst.snd.2;
    Œõ‚ÇÇ.snd.IsDegradableTo Œõ‚ÇÅ.snd;
  le_refl Œõ :=
    let _ := Œõ.fst.snd.1;
    let _ := Œõ.fst.snd.2;
    ‚ü®CPTPMap.id, CPTPMap.compose_id Œõ.snd‚ü©
  le_trans Œõ‚ÇÅ Œõ‚ÇÇ Œõ‚ÇÉ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ := by
    let _ := Œõ‚ÇÅ.fst.snd.1;
    let _ := Œõ‚ÇÅ.fst.snd.2;
    let _ := Œõ‚ÇÇ.fst.snd.1;
    let _ := Œõ‚ÇÇ.fst.snd.2;
    let _ := Œõ‚ÇÉ.fst.snd.1;
    let _ := Œõ‚ÇÉ.fst.snd.2;
    obtain ‚ü®D‚ÇÅ‚ÇÇ, hD‚ÇÅ‚ÇÇ‚ü© := h‚ÇÅ‚ÇÇ;
    obtain ‚ü®D‚ÇÇ‚ÇÉ, hD‚ÇÇ‚ÇÉ‚ü© := h‚ÇÇ‚ÇÉ;
    use D‚ÇÅ‚ÇÇ.compose D‚ÇÇ‚ÇÉ
    rwa [CPTPMap.compose_assoc, hD‚ÇÇ‚ÇÉ]

end


================================================================================
FILE: QuantumInfo/Finite/Distance/Fidelity.lean
TYPE: Lean 4
SIZE: 2038 characters
================================================================================

import QuantumInfo.Finite.CPTPMap

noncomputable section

open BigOperators
open ComplexConjugate
open Kronecker
open scoped Matrix ComplexOrder

variable {d d‚ÇÇ : Type*} [Fintype d] [DecidableEq d] [Fintype d‚ÇÇ] (œÅ œÉ : MState d)

--We put all of the fidelity defs and theorems in the MState namespace so that they have the
--nice . syntax, i.e. `œÅ.fidelity œÉ = 1 ‚Üî œÅ = œÉ`.
namespace MState

/-- The fidelity of two quantum states. This is the quantum version of the Bhattacharyya coefficient. -/
def fidelity (œÅ œÉ : MState d) : ‚Ñù :=
  ((œÉ.M.conj œÅ.pos.sqrt) ^ (1/2 : ‚Ñù)).trace
  -- let œÅœÉœÅ := œÅ.pos.sqrt * œÉ.m * œÅ.pos.sqrt
  -- let œÅœÉœÅ_PosSemidef : œÅœÉœÅ.PosSemidef := by
  --   unfold œÅœÉœÅ
  --   nth_rewrite 2 [‚Üê œÅ.pos.posSemidef_sqrt.isHermitian]
  --   exact œÉ.pos.mul_mul_conjTranspose_same _
  -- (œÅœÉœÅ_PosSemidef.posSemidef_sqrt.1.rtrace)^2

theorem fidelity_ge_zero : 0 ‚â§ fidelity œÅ œÉ :=
  sorry
  -- sq_nonneg _

theorem fidelity_le_one : fidelity œÅ œÉ ‚â§ 1 :=
  sorry --submultiplicativity of trace and sqrt

/-- The fidelity, as a `Prob` probability with value between 0 and 1. -/
def fidelity_prob : Prob :=
  ‚ü®fidelity œÅ œÉ, ‚ü®fidelity_ge_zero œÅ œÉ, fidelity_le_one œÅ œÉ‚ü©‚ü©

/-- A state has perfect fidelity with itself. -/
theorem fidelity_self_eq_one : fidelity œÅ œÅ = 1 :=
  sorry --Break and recombine sqrts

/-- The fidelity is 1 if and only if the two states are the same. -/
theorem fidelity_eq_one_iff_self : fidelity œÅ œÉ = 1 ‚Üî œÅ = œÉ :=
  ‚ü®sorry,
  fun h ‚Ü¶ h ‚ñ∏ fidelity_self_eq_one œÅ
  ‚ü©

/-- The fidelity is a symmetric quantity. -/
theorem fidelity_symm : fidelity œÅ œÉ = fidelity œÉ œÅ :=
  sorry --break into sqrts

/-- The fidelity cannot decrease under the application of a channel. -/
theorem fidelity_channel_nondecreasing [DecidableEq d‚ÇÇ] (Œõ : CPTPMap d d‚ÇÇ) : fidelity (Œõ œÅ) (Œõ œÉ) ‚â• fidelity œÅ œÉ :=
  sorry

--TODO: Real.arccos ‚àò fidelity forms a metric (triangle inequality), the Fubini‚ÄìStudy metric.
--Matches with classical (squared) Bhattacharyya coefficient
--Invariance under unitaries
--Uhlmann's theorem

end MState


================================================================================
FILE: QuantumInfo/Finite/Distance/TraceDistance.lean
TYPE: Lean 4
SIZE: 1602 characters
================================================================================

import QuantumInfo.Finite.MState

import QuantumInfo.ForMathlib

noncomputable section

open Classical
open BigOperators
open ComplexConjugate
open Kronecker
open scoped Matrix ComplexOrder

variable {d : Type*} [Fintype d] [DecidableEq d]

/--The trace distance between two quantum states: half the trace norm of the difference (œÅ - œÉ). -/
def TrDistance (œÅ œÉ : MState d) : ‚Ñù :=
  (1/2:‚Ñù) * (œÅ.m - œÉ.m).traceNorm

namespace TrDistance

variable {d d‚ÇÇ : Type*} [Fintype d] [Fintype d‚ÇÇ] (œÅ œÉ : MState d)

theorem ge_zero : 0 ‚â§ TrDistance œÅ œÉ := by
  rw [TrDistance]
  simp [Matrix.traceNorm_nonneg]

theorem le_one : TrDistance œÅ œÉ ‚â§ 1 :=
  calc TrDistance œÅ œÉ
    _ = (1/2:‚Ñù) * (œÅ.m - œÉ.m).traceNorm := by rfl
    _ ‚â§ (1/2:‚Ñù) * (œÅ.m.traceNorm + œÉ.m.traceNorm) := by
      linarith [Matrix.traceNorm_triangleIneq' œÅ.m œÉ.m]
    _ = (1/2:‚Ñù) * (1 + 1) := by
      rw [œÅ.traceNorm_eq_1, œÉ.traceNorm_eq_1]
    _ = 1 := by norm_num

/-- The trace distance, as a `Prob` probability with value between 0 and 1. -/
def prob : Prob :=
  ‚ü®TrDistance œÅ œÉ, ‚ü®ge_zero œÅ œÉ, le_one œÅ œÉ‚ü©‚ü©

/-- The trace distance is a symmetric quantity. -/
theorem symm : TrDistance œÅ œÉ = TrDistance œÉ œÅ := by
  dsimp [TrDistance]
  rw [‚Üê Matrix.traceNorm_eq_neg_self, neg_sub]

/-- The trace distance is equal to half the 1-norm of the eigenvalues of their difference . -/
theorem eq_abs_eigenvalues : TrDistance œÅ œÉ = (1/2:‚Ñù) *
    ‚àë i, abs ((œÅ.Hermitian.sub œÉ.Hermitian).eigenvalues i) := by
  rw [TrDistance, Matrix.traceNorm_Hermitian_eq_sum_abs_eigenvalues]

-- Fuchs‚Äìvan de Graaf inequalities
-- Relation to classical TV distance


================================================================================
FILE: QuantumInfo/Finite/Distance.lean
TYPE: Lean 4
SIZE: 313 characters
================================================================================

import QuantumInfo.Finite.Distance.Fidelity
import QuantumInfo.Finite.Distance.TraceDistance

/-!
Distances between quantum states.
 * Fidelity
 * Trace distance
 * Bures metric
 * Superfidelity
 * Quantum Wasserstein Distance

All share some axioms: https://quantiki.org/wiki/distance-measures-between-states
-/


================================================================================
FILE: QuantumInfo/Finite/Ensemble.lean
TYPE: Lean 4
SIZE: 12153 characters
================================================================================

import QuantumInfo.Finite.MState

open MState
open BigOperators

noncomputable section

/-- A mixed-state ensemble is a random variable valued in `MState d`. That is,
a collection of mixed states `var : Œ± ‚Üí MState d`, each with their own probability weight
described by `distr : Distribution Œ±`. -/
abbrev MEnsemble (d : Type*) (Œ± : Type*) [Fintype d] [DecidableEq d] [Fintype Œ±] := Distribution.RandVar Œ± (MState d)

/-- A pure-state ensemble is a random variable valued in `Ket d`. That is,
a collection of pure states `var : Œ± ‚Üí Ket d`, each with their own probability weight
described by `distr : Distribution Œ±`. -/
abbrev PEnsemble (d : Type*) (Œ± : Type*) [Fintype d] [Fintype Œ±] := Distribution.RandVar Œ± (Ket d)

variable {Œ± Œ≤ d : Type*} [Fintype Œ±] [Fintype Œ≤] [Fintype d] [DecidableEq d]

/-- Alias for `Distribution.var` for mixed-state ensembles. -/
abbrev MEnsemble.states [Fintype Œ±] : MEnsemble d Œ± ‚Üí (Œ± ‚Üí MState d) := Distribution.RandVar.var

/-- Alias for `Distribution.var` for pure-state ensembles. -/
abbrev PEnsemble.states [Fintype Œ±] : PEnsemble d Œ± ‚Üí (Œ± ‚Üí Ket d) := Distribution.RandVar.var

namespace Ensemble

/-- A pure-state ensemble is a mixed-state ensemble if all kets are interpreted as mixed states. -/
@[coe] def toMEnsemble : PEnsemble d Œ± ‚Üí MEnsemble d Œ± := Functor.map pure

instance : Coe (PEnsemble d Œ±) (MEnsemble d Œ±) := ‚ü®toMEnsemble‚ü©

@[simp]
theorem toMEnsemble_mk : (toMEnsemble ‚ü®ps, distr‚ü© : MEnsemble d Œ±) = ‚ü®pure ‚àò ps, distr‚ü© :=
  rfl

/-- A mixed-state ensemble comes from a pure-state ensemble if and only if all states are pure. -/
theorem coe_PEnsemble_iff_pure_states (me : MEnsemble d Œ±): (‚àÉ pe : PEnsemble d Œ±, ‚Üëpe = me) ‚Üî (‚àÉ œà : Œ± ‚Üí Ket d, me.states = MState.pure ‚àò œà) := by
  constructor
  ¬∑ intro ‚ü®pe, hpe‚ü©
    use pe.states
    ext1 i
    subst hpe
    rfl
  ¬∑ intro ‚ü®œà, hœà‚ü©
    use ‚ü®œà, me.distr‚ü©
    simp only [toMEnsemble_mk]
    congr
    exact hœà.symm

/-- The resulting mixed state after mixing the states in an ensemble with their
respective probability weights. Note that, generically, a single mixed state has infinitely many
ensembles that mixes into it. -/
def mix (e : MEnsemble d Œ±) : MState d := Distribution.expect_val e

@[simp]
theorem mix_of (e : MEnsemble d Œ±) : (mix e).m = ‚àë i, (e.distr i : ‚Ñù) ‚Ä¢ (e.states i).m := by
  apply AddSubgroup.val_finset_sum -- *laughs in defeq*

/-- Two mixed-state ensembles indexed by `\alpha` and `\beta` are equivalent if `Œ± ‚âÉ Œ≤`. -/
def congrMEnsemble (œÉ : Œ± ‚âÉ Œ≤) : MEnsemble d Œ± ‚âÉ MEnsemble d Œ≤ := Distribution.congrRandVar œÉ

/-- Two pure-state ensembles indexed by `\alpha` and `\beta` are equivalent if `Œ± ‚âÉ Œ≤`. -/
def congrPEnsemble (œÉ : Œ± ‚âÉ Œ≤) : PEnsemble d Œ± ‚âÉ PEnsemble d Œ≤ := Distribution.congrRandVar œÉ

/-- Equivalence of mixed-state ensembles leaves the resulting mixed state invariant -/
@[simp]
theorem mix_congrMEnsemble_eq_mix (œÉ : Œ± ‚âÉ Œ≤) (e : MEnsemble d Œ±) : mix (congrMEnsemble œÉ e) = mix e :=
  Distribution.expect_val_congr_eq_expect_val œÉ e

/-- Equivalence of pure-state ensembles leaves the resulting mixed state invariant -/
@[simp]
theorem mix_congrPEnsemble_eq_mix (œÉ : Œ± ‚âÉ Œ≤) (e : PEnsemble d Œ±) : mix (toMEnsemble (congrPEnsemble œÉ e)) = mix (‚Üëe : MEnsemble d Œ±) := by
  unfold toMEnsemble congrPEnsemble mix
  rw [Distribution.map_congr_eq_congr_map MState.pure œÉ e]
  exact Distribution.expect_val_congr_eq_expect_val œÉ (MState.pure <$> e)

/-- The average of a function `f : MState d ‚Üí T`, where `T` is of `Mixable U T` instance, on a mixed-state ensemble `e`
is the expectation value of `f` acting on the states of `e`, with the corresponding probability weights from `e.distr`. -/
def average {T : Type _} {U : Type*} [AddCommGroup U] [Module ‚Ñù U] [inst : Mixable U T] (f : MState d ‚Üí T) (e : MEnsemble d Œ±) : T :=
  Distribution.expect_val <| f <$> e

/-- A version of `average` conveniently specialized for functions `f : MState d ‚Üí ‚Ñù‚â•0` returning nonnegative reals.
Notably, the average is also a nonnegative real number. -/
def average_NNReal {d : Type _} [Fintype d] [DecidableEq d] (f : MState d ‚Üí NNReal) (e : MEnsemble d Œ±) : NNReal :=
  ‚ü®average (NNReal.toReal ‚àò f) e,
    Distribution.zero_le_expect_val e.distr (NNReal.toReal ‚àò f ‚àò e.states) (fun n => (f <| e.states n).2)‚ü©

/-- The average of a function `f : Ket d ‚Üí T`, where `T` is of `Mixable U T` instance, on a pure-state ensemble `e`
is the expectation value of `f` acting on the states of `e`, with the corresponding probability weights from `e.distr`. -/
def pure_average {T : Type _} {U : Type*} [AddCommGroup U] [Module ‚Ñù U] [inst : Mixable U T] (f : Ket d ‚Üí T) (e : PEnsemble d Œ±) : T :=
  Distribution.expect_val <| f <$> e

/-- A version of `average` conveniently specialized for functions `f : Ket d ‚Üí ‚Ñù‚â•0` returning nonnegative reals.
Notably, the average is also a nonnegative real number. -/
def pure_average_NNReal {d : Type _} [Fintype d] (f : Ket d ‚Üí NNReal) (e : PEnsemble d Œ±) : NNReal :=
  ‚ü®pure_average (NNReal.toReal ‚àò f) e,
    Distribution.zero_le_expect_val e.distr (NNReal.toReal ‚àò f ‚àò e.states) (fun n => (f <| e.states n).2)‚ü©

/-- The average of `f : MState d ‚Üí T` on a coerced pure-state ensemble `‚Üëe : MEnsemble d Œ±`
is equal to averaging the restricted function over Kets `f ‚àò pure : Ket d ‚Üí T` on `e`. -/
theorem average_of_pure_ensemble {T : Type _} {U : Type*} [AddCommGroup U] [Module ‚Ñù U] [inst : Mixable U T]
  (f : MState d ‚Üí T) (e : PEnsemble d Œ±) :
  average f (toMEnsemble e) = pure_average (f ‚àò pure) e := by
  simp only [average, pure_average, toMEnsemble, comp_map]

/-- A pure-state ensemble mixes into a pure state if and only if
the only states in the ensemble with nonzero probability are equal to `œà`  -/
theorem mix_pEnsemble_pure_iff_pure {œà : Ket d} {e : PEnsemble d Œ±} :
  mix (toMEnsemble e) = MState.pure œà ‚Üî ‚àÄ i : Œ±, e.distr i ‚â† 0 ‚Üí e.states i = œà := by
  sorry

/-- The average of `f : Ket d ‚Üí T` on an ensemble that mixes to a pure state `œà` is `f œà` -/
theorem mix_pEnsemble_pure_average {œà : Ket d} {e : PEnsemble d Œ±} {T : Type _} {U : Type*} [AddCommGroup U] [Module ‚Ñù U] [inst : Mixable U T] (f : Ket d ‚Üí T) (hmix : mix (toMEnsemble e) = MState.pure œà) :
  pure_average f e = f œà := by
  have hpure := mix_pEnsemble_pure_iff_pure.mp hmix
  simp only [pure_average, Functor.map, Distribution.expect_val]
  apply Mixable.to_U_inj
  rw [PEnsemble.states] at hpure
  simp only [Mixable.to_U_of_mkT, Function.comp_apply, smul_eq_mul, Mixable.mkT_instUniv]
  have h1 : ‚àÄ i ‚àà Finset.univ, (e.distr i : ‚Ñù) ‚Ä¢ (Mixable.to_U (f (e.var i))) ‚â† 0 ‚Üí e.var i = œà := fun i hi ‚Ü¶ by
    have h2 : e.distr i = 0 ‚Üí (e.distr i : ‚Ñù) ‚Ä¢ (Mixable.to_U (f (e.var i))) = 0 := fun h0 ‚Ü¶ by
      simp only [h0, Prob.coe_zero, zero_smul]
    exact (hpure i) ‚àò h2.mt
  classical rw [‚ÜêFinset.sum_filter_of_ne h1, Finset.sum_filter]
  classical conv =>
    enter [1, 2, a]
    rw [‚Üêdite_eq_ite]
    enter [2, hvar]
    rw [hvar]
  classical conv =>
    enter [1, 2, a]
    rw [dite_eq_ite]
    rw [‚Üêite_zero_smul]
  have hpure' : ‚àÄ i ‚àà Finset.univ, (‚Üë(e.distr i) : ‚Ñù) ‚â† 0 ‚Üí e.var i = œà := fun i hi hne0 ‚Ü¶ by
    apply hpure i
    simpa using hne0
  classical rw [‚ÜêFinset.sum_smul, ‚ÜêFinset.sum_filter, Finset.sum_filter_of_ne hpure', Distribution.normalized, one_smul]

/-- A mixed-state ensemble mixes into a pure state if and only if
the only states in the ensemble with nonzero probability are equal to `pure œà`  -/
theorem mix_mEnsemble_pure_iff_pure {œà : Ket d} {e : MEnsemble d Œ±} :
  mix e = pure œà ‚Üî ‚àÄ i : Œ±, e.distr i ‚â† 0 ‚Üí e.states i = MState.pure œà := by
  sorry

/-- The average of `f : MState d ‚Üí T` on an ensemble that mixes to a pure state `œà` is `f (pure œà)` -/
theorem mix_mEnsemble_pure_average {œà : Ket d} {e : MEnsemble d Œ±} {T : Type _} {U : Type*} [AddCommGroup U] [Module ‚Ñù U] [inst : Mixable U T] (f : MState d ‚Üí T) (hmix : mix e = pure œà) :
  average f e = f (pure œà) := by
  have hpure := mix_mEnsemble_pure_iff_pure.mp hmix
  simp only [average, Functor.map, Distribution.expect_val]
  apply Mixable.to_U_inj
  rw [MEnsemble.states] at hpure
  simp only [Mixable.to_U_of_mkT, Function.comp_apply, smul_eq_mul, Mixable.mkT_instUniv]
  have h1 : ‚àÄ i ‚àà Finset.univ, (e.distr i : ‚Ñù) ‚Ä¢ (Mixable.to_U (f (e.var i))) ‚â† 0 ‚Üí e.var i = pure œà := fun i hi ‚Ü¶ by
    have h2 : e.distr i = 0 ‚Üí (e.distr i : ‚Ñù) ‚Ä¢ (Mixable.to_U (f (e.var i))) = 0 := fun h0 ‚Ü¶ by
      simp only [h0, Prob.coe_zero, zero_smul]
    exact (hpure i) ‚àò h2.mt
  classical rw [‚ÜêFinset.sum_filter_of_ne h1, Finset.sum_filter]
  classical conv =>
    enter [1, 2, a]
    rw [‚Üêdite_eq_ite]
    enter [2, hvar]
    rw [hvar]
  classical conv =>
    enter [1, 2, a]
    rw [dite_eq_ite]
    rw [‚Üêite_zero_smul]
  have hpure' : ‚àÄ i ‚àà Finset.univ, (‚Üë(e.distr i) : ‚Ñù) ‚â† 0 ‚Üí e.var i = pure œà := fun i hi hne0 ‚Ü¶ by
    apply hpure i
    simpa using hne0
  classical rw [‚ÜêFinset.sum_smul, ‚ÜêFinset.sum_filter, Finset.sum_filter_of_ne hpure', Distribution.normalized, one_smul]

/-- The trivial mixed-state ensemble of `œÅ` consists of copies of `rho`, with the `i`-th one having
probability 1. -/
def trivial_mEnsemble (œÅ : MState d) (i : Œ±) : MEnsemble d Œ± := ‚ü®fun _ ‚Ü¶ œÅ, Distribution.constant i‚ü©

/-- The trivial mixed-state ensemble of `œÅ` mixes to `œÅ` -/
theorem trivial_mEnsemble_mix (œÅ : MState d) : ‚àÄ i : Œ±, mix (trivial_mEnsemble œÅ i) = œÅ := fun i ‚Ü¶by
  apply MState.ext_m
  classical simp only [trivial_mEnsemble, Distribution.constant, mix_of, DFunLike.coe, apply_ite,
    Prob.coe_one, Prob.coe_zero, ite_smul, one_smul, zero_smul, Finset.sum_ite_eq,
    Finset.mem_univ, ‚ÜìreduceIte]

/-- The average of `f : MState d ‚Üí T` on a trivial ensemble of `œÅ` is `f œÅ`-/
theorem trivial_mEnsemble_average {T : Type _} {U : Type*} [AddCommGroup U] [Module ‚Ñù U] [inst : Mixable U T] (f : MState d ‚Üí T) (œÅ : MState d):
  ‚àÄ i : Œ±, average f (trivial_mEnsemble œÅ i) = f œÅ := fun i ‚Ü¶ by
    simp only [average, Functor.map, Distribution.expect_val, trivial_mEnsemble]
    apply Mixable.to_U_inj
    classical simp [apply_ite]

instance MEnsemble.instInhabited [Nonempty d] [Inhabited Œ±] : Inhabited (MEnsemble d Œ±) where
  default := trivial_mEnsemble default default

/-- The trivial pure-state ensemble of `œà` consists of copies of `œà`, with the `i`-th one having
probability 1. -/
def trivial_pEnsemble (œà : Ket d) (i : Œ±) : PEnsemble d Œ± := ‚ü®fun _ ‚Ü¶ œà, Distribution.constant i‚ü©

/-- The trivial pure-state ensemble of `œà` mixes to `œà` -/
theorem trivial_pEnsemble_mix (œà : Ket d) : ‚àÄ i : Œ±, mix (toMEnsemble (trivial_pEnsemble œà i)) = MState.pure œà := fun i ‚Ü¶ by
  apply MState.ext_m
  classical simp only [trivial_pEnsemble, Distribution.constant, toMEnsemble_mk, mix_of, DFunLike.coe,
    apply_ite, Prob.coe_one, Prob.coe_zero, MEnsemble.states, Function.comp_apply, ite_smul,
    one_smul, zero_smul, Finset.sum_ite_eq, Finset.mem_univ, ‚ÜìreduceIte]

omit [DecidableEq d] in
/-- The average of `f : Ket d ‚Üí T` on a trivial ensemble of `œà` is `f œà`-/
theorem trivial_pEnsemble_average {T : Type _} {U : Type*} [AddCommGroup U] [Module ‚Ñù U] [inst : Mixable U T] (f : Ket d ‚Üí T) (œà : Ket d) :
  ‚àÄ i : Œ±, pure_average f (trivial_pEnsemble œà i) = f œà := fun i ‚Ü¶ by
    simp only [pure_average, Functor.map, Distribution.expect_val, trivial_pEnsemble]
    apply Mixable.to_U_inj
    classical simp [apply_ite]

instance PEnsemble.instInhabited [Nonempty d] [Inhabited Œ±] : Inhabited (PEnsemble d Œ±) where
  default := trivial_pEnsemble default default

/-- The spectral pure-state ensemble of `œÅ`. The states are its eigenvectors, and the probabilities, eigenvalues. -/
def spectral_ensemble (œÅ : MState d) : PEnsemble d d :=
  { var i :=
    { vec := œÅ.Hermitian.eigenvectorBasis i
      normalized' := by
        rw [‚Üêone_pow 2, ‚ÜêœÅ.Hermitian.eigenvectorBasis.orthonormal.1 i]
        have hnonneg : 0 ‚â§ ‚àë x : d, Complex.normSq (œÅ.Hermitian.eigenvectorBasis i x) := by
          simp_rw [Complex.normSq_eq_norm_sq]
          positivity
        simp only [‚Üê Complex.normSq_eq_norm_sq, EuclideanSpace.norm_eq, Real.sq_sqrt hnonneg]
    }
    distr := œÅ.spectrum}

/-- The spectral pure-state ensemble of `œÅ` mixes to `œÅ` -/
theorem spectral_ensemble_mix : mix (‚Üë(spectral_ensemble œÅ) : MEnsemble d d) = œÅ := by
  ext i j
  sorry

end Ensemble


================================================================================
FILE: QuantumInfo/Finite/Entanglement.lean
TYPE: Lean 4
SIZE: 10610 characters
================================================================================

import QuantumInfo.Finite.Braket
import QuantumInfo.Finite.Ensemble
import QuantumInfo.Finite.Entropy
import ClassicalInfo.Entropy

/-!
Entanglement measures. (Mixed) convex roof extensions. Definition of product / separable / entangled states
are in `Braket.lean` and/or `MState.lean`

Important definitions:
 * `convex_roof`: Convex roof extension of `g : Ket d ‚Üí ‚Ñù‚â•0`
 * `mixed_convex_roof`: Mixed convex roof extension of `f : MState d ‚Üí ‚Ñù‚â•0`
 * `EoF`: Entanglement of Formation

TODO:
 - Other entanglement measures (not necessarily based on convex roof extensions). In roughly increasing order of
   difficulty to implement: (Logarithmic) Negativity, Entanglement of Purification, Squashed Entanglement, Relative
   Entropy of Entanglement, Entanglement Cost, Distillable Entanglement.
   For a compendium on the zoo of entanglement measures, see
   [1] Christandl, Matthias. ‚ÄúThe Structure of Bipartite Quantum States - Insights from Group Theory and Cryptography.‚Äù
       https://doi.org/10.48550/arXiv.quant-ph/0604183.
 - Define classes of entanglement measures with good properties, including: monotonicity under LOCC (easier: just LO),
   monotonicity on average under LOCC, convexity (if the latter two are present, it is called an entanglement monotone
   by some), vanishing on separable states, normalized on the maximally entangled state, (sub)additivity, regularisible.
   For other properties, see [1] above and:
   [2] Szalay, Szil√°rd. ‚ÄúMultipartite Entanglement Measures.‚Äù (mainly Sec. IV)
       https://doi.org/10.1103/PhysRevA.92.042329.
   [3] Horodecki, Ryszard, Pawe≈Ç Horodecki, Micha≈Ç Horodecki, and Karol Horodecki. ‚ÄúQuantum Entanglement.‚Äù
       https://doi.org/10.1103/RevModPhys.81.865.
 - Useful properties of convex roof extensions:
   1. If f is monotonically non-increasing under LOCC, so is its convex roof.
   2. If f œà is zero if and only if œà is a product state, then its convex roof is faithful: zero if and only if
      the mixed state is separable
   For other properties, see Sec. IV.F of [2] above.
-/

noncomputable section

open ENNReal
open NNReal
open MState
open Ensemble

/-- Convex roof extension of a function `g : Ket d ‚Üí ‚Ñù‚â•0`, defined as the infimum of all pure-state
ensembles of a given `œÅ` of the average of `g` in that ensemble.

This is valued in the extended nonnegative real numbers `‚Ñù‚â•0‚àû` to have good properties of the infimum, which
come from the fact that `‚Ñù‚â•0‚àû` is a complete lattice. For example, it is necessary for `le_iInf` and `iInf_le_of_le`.
However, it is also proven in `convex_roof_ne_top` that the convex roof is never `‚àû`, so the definition `convex_roof` should
be used in most applications. -/
def convex_roof_ENNReal {d : Type _} [Fintype d] [DecidableEq d] (g : Ket d ‚Üí ‚Ñù‚â•0) : MState d ‚Üí ‚Ñù‚â•0‚àû := fun œÅ =>
  ‚®Ö (n : ‚Ñï+) (e : PEnsemble d (Fin n)) (_ : mix (toMEnsemble e) = œÅ), ‚Üë(pure_average_NNReal g e)

/-- Mixed convex roof extension of a function `f : MState d ‚Üí ‚Ñù‚â•0`, defined as the infimum of all mixed-state
ensembles of a given `œÅ` of the average of `f` on that ensemble.

This is valued in the extended nonnegative real numbers `‚Ñù‚â•0‚àû` to have good properties of the infimum, which
come from the fact that `‚Ñù‚â•0‚àû` is a complete lattice (see `ENNReal.instCompleteLinearOrder`). However,
it is also proven in `mixed_convex_roof_ne_top` that the mixed convex roof is never `‚àû`, so the definition `mixed_convex_roof` should
be used in most applications. -/
def mixed_convex_roof_ENNReal {d : Type _} [Fintype d] [DecidableEq d] (f : MState d ‚Üí ‚Ñù‚â•0) : MState d ‚Üí ‚Ñù‚â•0‚àû := fun œÅ =>
  ‚®Ö (n : ‚Ñï+) (e : MEnsemble d (Fin n)) (_ : mix e = œÅ), ‚Üë(average_NNReal f e)

variable {d d‚ÇÅ d‚ÇÇ : Type _} [Fintype d] [Fintype d‚ÇÅ] [Fintype d‚ÇÇ] [Nonempty d] [Nonempty d‚ÇÅ] [Nonempty d‚ÇÇ]
variable [DecidableEq d] [DecidableEq d‚ÇÅ] [DecidableEq d‚ÇÇ]
variable (f : MState d ‚Üí ‚Ñù‚â•0)
variable (g : Ket d ‚Üí ‚Ñù‚â•0)

/-- The convex roof extension `convex_roof_ENNReal` is never ‚àû. -/
theorem convex_roof_ne_top : ‚àÄ œÅ, convex_roof_ENNReal g œÅ ‚â† ‚àû := fun œÅ => by
  simp only [convex_roof_ENNReal, ne_eq, iInf_eq_top, coe_ne_top, imp_false, not_forall, Decidable.not_not]
  use ‚ü®Fintype.card d, Fintype.card_pos‚ü©
  have ed : d ‚âÉ Fin ‚Üë(‚ü®Fintype.card d, Fintype.card_pos‚ü© : ‚Ñï+) := by
    simp only
    exact Fintype.equivFin d
  use (congrPEnsemble ed) <| spectral_ensemble œÅ
  rw [mix_congrPEnsemble_eq_mix ed]
  push_neg
  convert spectral_ensemble_mix

omit [Nonempty d] in
/-- The convex roof extension `mixed_convex_roof_ENNReal` is never ‚àû. -/
theorem mixed_convex_roof_ne_top : ‚àÄ œÅ, mixed_convex_roof_ENNReal f œÅ ‚â† ‚àû := fun œÅ => by
  simp only [mixed_convex_roof_ENNReal, ne_eq, iInf_eq_top, coe_ne_top, imp_false, not_forall, Decidable.not_not]
  use 1, trivial_mEnsemble œÅ 0
  push_neg
  exact trivial_mEnsemble_mix œÅ 0

/-- Convex roof extension of a function `g : Ket d ‚Üí ‚Ñù‚â•0`, defined as the infimum of all pure-state
ensembles of a given `œÅ` of the average of `g` in that ensemble.

This is valued in the nonnegative real numbers `‚Ñù‚â•0` by applying `ENNReal.toNNReal` to `convex_roof_ENNReal`. Hence,
it should be used in proofs alongside `convex_roof_ne_top`. -/
def convex_roof : MState d ‚Üí ‚Ñù‚â•0 := fun x ‚Ü¶ (convex_roof_ENNReal g x).untop (convex_roof_ne_top g x)

/-- Mixed convex roof extension of a function `f : MState d ‚Üí ‚Ñù‚â•0`, defined as the infimum of all mixed-state
ensembles of a given `œÅ` of the average of `f` on that ensemble.

This is valued in the nonnegative real numbers `‚Ñù‚â•0` by applying `ENNReal.toNNReal` to `mixed_convex_roof_ENNReal`. Hence,
it should be used in proofs alongside `mixed_convex_roof_ne_top`. -/
def mixed_convex_roof : MState d ‚Üí ‚Ñù‚â•0 := fun x ‚Ü¶ (mixed_convex_roof_ENNReal f x).untop (mixed_convex_roof_ne_top f x)

/-- Auxiliary function. Convex roof of a function `f : MState d ‚Üí ‚Ñù‚â•0` defined over mixed states by resctricting `f` to pure states -/
def convex_roof_of_MState_fun : MState d ‚Üí ‚Ñù‚â•0 := convex_roof (f ‚àò pure)

-- TODO: make `le_convex_roof`, `convex_roof_le`, `le_mixed_convex_roof` and `mixed_convex_roof_le` if-and-only-if statements.

omit [Nonempty d] in
theorem le_mixed_convex_roof (œÅ : MState d) :
  (‚àÄ n > 0, ‚àÄ e : MEnsemble d (Fin n), mix e = œÅ ‚Üí c ‚â§ average_NNReal f e) ‚Üí (c ‚â§ mixed_convex_roof f œÅ) := fun h => by
  unfold mixed_convex_roof
  rw [WithTop.le_untop_iff]
  apply le_iInf; intro ‚ü®n, hnpos‚ü©; apply le_iInf; intro e; apply le_iInf; intro hmix
  rw [some_eq_coe', ENNReal.coe_le_coe]
  exact h n hnpos e hmix

theorem le_convex_roof (œÅ : MState d) :
  (‚àÄ n > 0, ‚àÄ e : PEnsemble d (Fin n), mix (toMEnsemble e) = œÅ ‚Üí c ‚â§ pure_average_NNReal g e) ‚Üí (c ‚â§ convex_roof g œÅ) := fun h => by
  unfold convex_roof
  rw [WithTop.le_untop_iff]
  apply le_iInf; intro ‚ü®n, hnpos‚ü©; apply le_iInf; intro e; apply le_iInf; intro hmix
  rw [some_eq_coe', ENNReal.coe_le_coe]
  exact h n hnpos e hmix

theorem convex_roof_le (œÅ : MState d):
(‚àÉ n > 0, ‚àÉ e : PEnsemble d (Fin n), mix (toMEnsemble e) = œÅ ‚àß pure_average_NNReal g e ‚â§ c) ‚Üí (convex_roof g œÅ ‚â§ c) := fun h => by
  obtain ‚ü®n, hnpos, e, hmix, h‚ü© := h
  unfold convex_roof
  rw [WithTop.untop_le_iff]
  apply iInf_le_of_le ‚ü®n, hnpos‚ü©; apply iInf_le_of_le e; apply iInf_le_of_le hmix
  rw [some_eq_coe', ENNReal.coe_le_coe]
  exact h

omit [Nonempty d] in
theorem mixed_convex_roof_le (œÅ : MState d):
(‚àÉ n > 0, ‚àÉ e : MEnsemble d (Fin n), mix e = œÅ ‚àß average_NNReal f e ‚â§ c) ‚Üí (mixed_convex_roof f œÅ ‚â§ c) := fun h => by
  obtain ‚ü®n, hnpos, e, hmix, h‚ü© := h
  unfold mixed_convex_roof
  rw [WithTop.untop_le_iff]
  apply iInf_le_of_le ‚ü®n, hnpos‚ü©; apply iInf_le_of_le e; apply iInf_le_of_le hmix
  rw [some_eq_coe', ENNReal.coe_le_coe]
  exact h

/-- The mixed convex roof extension of `f` is smaller than or equal to its convex roof extension, since
the former minimizes over a larger set of ensembles. -/
theorem mixed_convex_roof_le_convex_roof : mixed_convex_roof f ‚â§ convex_roof_of_MState_fun f := by
  intro œÅ
  apply le_convex_roof (f ‚àò pure) œÅ
  intro n hnpos e hmix
  apply mixed_convex_roof_le
  use n
  apply And.intro hnpos
  use ‚Üëe
  apply And.intro hmix
  exact le_of_eq <| NNReal.coe_inj.mp <| average_of_pure_ensemble (toReal ‚àò f) e

/-- The convex roof extension of `g : Ket d ‚Üí ‚Ñù‚â•0` applied to a pure state `œà` is `g œà`. -/
theorem convex_roof_of_pure (œà : Ket d) : convex_roof g (pure œà) = g œà := by
  rw [le_antisymm_iff]
  constructor
  ¬∑ apply convex_roof_le
    use 1; simp only [gt_iff_lt, zero_lt_one, true_and]; use trivial_pEnsemble œà 0
    constructor
    ¬∑ exact trivial_pEnsemble_mix œà 0
    ¬∑ simp only [pure_average_NNReal, Fin.isValue, ‚Üê NNReal.coe_le_coe, coe_mk]
      rw [trivial_pEnsemble_average _ œà 0]
      rfl
  ¬∑ apply le_convex_roof
    intro n hnpos e hmix
    replace hpure := mix_pEnsemble_pure_iff_pure.mp hmix
    apply le_of_eq
    simp only [pure_average_NNReal, ‚Üê NNReal.coe_inj, coe_mk]
    rw [mix_pEnsemble_pure_average (toReal ‚àò g) hmix, Function.comp_apply]

omit [Nonempty d] in
/-- The mixed convex roof extension of `f : MState d ‚Üí ‚Ñù‚â•0` applied to a pure state `œà` is `f (pure œà)`. -/
theorem mixed_convex_roof_of_pure (œà : Ket d) : mixed_convex_roof f (pure œà) = f (pure œà) := by
  rw [le_antisymm_iff]
  constructor
  ¬∑ apply mixed_convex_roof_le
    use 1; simp only [gt_iff_lt, zero_lt_one, true_and]; use trivial_mEnsemble (pure œà) 0
    constructor
    ¬∑ exact trivial_mEnsemble_mix (pure œà) 0
    ¬∑ simp only [average_NNReal, Fin.isValue, ‚Üê NNReal.coe_le_coe, coe_mk]
      rw [trivial_mEnsemble_average _ (pure œà) 0]
      rfl
  ¬∑ apply le_mixed_convex_roof
    intro n hnpos e hmix
    replace hpure := mix_mEnsemble_pure_iff_pure.mp hmix
    apply le_of_eq
    simp only [average_NNReal, ‚Üê NNReal.coe_inj, coe_mk]
    rw [mix_mEnsemble_pure_average (toReal ‚àò f) hmix, Function.comp_apply]

/-- Entanglement of Formation of bipartite systems. It is the convex roof extension of the
von Neumann entropy of one of the subsystems (here chosen to be the left one, but see `Entropy.S·µ•‚Çô_of_partial_eq`). -/
def EoF : MState (d‚ÇÅ √ó d‚ÇÇ) ‚Üí ‚Ñù‚â•0 := convex_roof (fun œà ‚Ü¶ ‚ü®S·µ•‚Çô (pure œà).traceRight, S·µ•‚Çô_nonneg (pure œà).traceRight‚ü©)

/-- The entanglement of formation of the maximally entangled state with on-site dimension ùïï is log(ùïï). -/
theorem EoF_of_MES : EoF (pure <| Ket.MES d) = Real.log (Finset.card Finset.univ (Œ± := d)) := by
  simp only [EoF, convex_roof_of_pure, coe_mk, Finset.card_univ]
  simp only [traceRight, Matrix.traceRight, MState.pure, Ket.MES, one_div, Matrix.vecMulVec_apply,
    Ket.apply, Bra.eq_conj, apply_ite, map_inv‚ÇÄ, Complex.conj_ofReal, map_zero, ite_mul, zero_mul,
    mul_zero, Finset.sum_ite_eq, Finset.mem_univ, ‚ÜìreduceIte, ‚Üê Matrix.diagonal.eq_1]
  sorry


================================================================================
FILE: QuantumInfo/Finite/Entropy/Defs.lean
TYPE: Lean 4
SIZE: 9510 characters
================================================================================

import ClassicalInfo.Entropy
import QuantumInfo.Finite.MState
import QuantumInfo.Finite.CPTPMap

/-! # Generalized quantum entropy and relative entropy

Here we define a broad notion of entropy axiomatically, `Entropy`, and the Prop
`Entropy f` means that the function `f : MState ‚Üí ‚Ñù` acts like a generalized kind of quantum
entropy. For instance, min-, max-, Œ±-Renyi, and von Neumann entropies all fall
into this category. We prove various properties about the entropy for anything
supporting this type class. Any entropy automatically gets corresponding notions
of conditional entropy, mutual information, and so on.

Similarly, `RelEntropy f` means that `f : MState ‚Üí HermitianMat ‚Üí ENNReal` is a kind of
relative entropy. Every `RelEntropy` leads to a notion of entropy, as well, by
fixing one argument to the fully mixed state.

Of course relative entropies are "usually" used with a pair of (normalized) quantum
states, but it's still very common in literature to specifically let the second
argument be an arbitrary (PSD, Hermitian) matrix, so we do allow this. The behavior
when not a density matrix is left unspecified by the axioms.

In terms of the file structure, we start with `RelEntropy` as the more "general"
function, and then derive much of `Entropy` from it.

## References:

 - [Khinchin‚Äôs Fourth Axiom of Entropy Revisited](https://www.mdpi.com/2571-905X/6/3/49)
 - [Œ±-z Relative Entropies](https://warwick.ac.uk/fac/sci/maths/research/events/2013-2014/statmech/su/Nilanjana-slides.pdf)
 - Watrous's notes, [Max-relative entropy and conditional min-entropy](https://cs.uwaterloo.ca/~watrous/QIT-notes/QIT-notes.02.pdf)
 - [Quantum Relative Entropy - An Axiomatic Approach](https://www.marcotom.info/files/entropy-masterclass2022.pdf)
by Marco Tomamichel
 - [StackExchange](https://quantumcomputing.stackexchange.com/a/12953/10115)

-/

noncomputable section
universe u

open scoped NNReal
open scoped ENNReal

variable (f : ‚àÄ {d : Type u} [Fintype d] [DecidableEq d], MState d ‚Üí HermitianMat d ‚ÑÇ ‚Üí ‚Ñù‚â•0‚àû)

/-- The axioms to be a well-behaved quantum relative entropy, as given by
[Tomamichel](https://www.marcotom.info/files/entropy-masterclass2022.pdf).

This simpler class allows for _trivial_ relative entropies, such as `-log tr(œÅ‚Å∞œÉ)`.
Use mixing `RelEntropy.Nontrivial` to only allow nontrivial relative entropies. -/
class RelEntropy : Prop where
  /-- The data processing inequality -/
  DPI {d‚ÇÅ d‚ÇÇ : Type u} [Fintype d‚ÇÅ] [DecidableEq d‚ÇÅ] [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ]
    (œÅ œÉ : MState d‚ÇÅ) (Œõ : CPTPMap d‚ÇÅ d‚ÇÇ) : f (Œõ œÅ) (Œõ œÉ) ‚â§ f œÅ œÉ
  /-- Entropy is additive under tensor products -/
  of_kron {d‚ÇÅ d‚ÇÇ : Type u} [Fintype d‚ÇÅ] [Fintype d‚ÇÇ] [DecidableEq d‚ÇÅ] [DecidableEq d‚ÇÇ] :
    ‚àÄ (œÅ‚ÇÅ œÉ‚ÇÅ : MState d‚ÇÅ) (œÅ‚ÇÇ œÉ‚ÇÇ : MState d‚ÇÇ), f (œÅ‚ÇÅ ‚äó œÅ‚ÇÇ) (œÉ‚ÇÅ ‚äó œÉ‚ÇÇ) = f œÅ‚ÇÅ œÉ‚ÇÅ + f œÅ‚ÇÇ œÉ‚ÇÇ
  /-- Normalization of entropy to be `ln N` for a pure state vs. uniform on `N` many states. -/
  normalized {d : Type u} [fin : Fintype d] [DecidableEq d] [Nonempty d] (i : d) :
    f (.ofClassical (.constant i)) MState.uniform.M =
      some ‚ü®Real.log fin.card, Real.log_nonneg (mod_cast Fintype.card_pos)‚ü©

/-- The axioms to be a well-behaved quantum relative entropy, as given by
[Tomamichel](https://www.marcotom.info/files/entropy-masterclass2022.pdf). -/
class RelEntropy.Nontrivial [RelEntropy f] where
  /-- Nontriviality condition for a relative entropy. -/
  nontrivial (d) [Fintype d] [DecidableEq d] : ‚àÉ (œÅ œÉ : MState d),
    œÅ.M.support = ‚ä§ ‚àß œÉ.M.support = ‚ä§ ‚àß 0 < f œÅ œÉ

namespace RelEntropy

variable {d : Type u} [Fintype d] [DecidableEq d]
variable {d‚ÇÇ : Type u} [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ]

variable [RelEntropy f]

section possibly_trivial

/-
At some point we might want to offer a different constructor so that `normalized` only checks
it for domains of size 2, which is sufficient (see Tomamichel's proof). In that case, the
fact that it's still zero when `Unique d` has to be proven, and this (now used) chunk of a proof
can be used in part for that:

-- have h_uniq (œÅ') := (Subsingleton.allEq œÅ œÅ').symm
-- have h_kron := of_kron (f := f) œÅ œÅ œÅ œÅ
-- let e : d ‚âÉ (d √ó d) := (Equiv.prodUnique d d).symm
-- rw [‚Üê relabel_eq f e] at h_kron
-- rw [h_uniq ((œÅ‚äóœÅ).relabel e)] at h_kron
-- rw [h_uniq œÉ]

At that point we need the fact that it's not `‚ä§`, and then it must be zero.

-/

/-- Relabelling a state with `CPTPMap.of_equiv` leaves relative entropies unchanged. -/
@[simp]
theorem of_equiv_eq (e : d ‚âÉ d‚ÇÇ) (œÅ œÉ : MState d) :
    f (CPTPMap.of_equiv e œÅ) (CPTPMap.of_equiv e œÉ) = f œÅ œÉ := by
  apply le_antisymm
  ¬∑ apply DPI
  ¬∑ convert DPI (f := f) ((CPTPMap.of_equiv e) œÅ) ((CPTPMap.of_equiv e) œÉ) (CPTPMap.of_equiv e.symm)
    ¬∑ symm
      exact congrFun (CPTPMap.equiv_inverse e.symm) œÅ
    ¬∑ symm
      exact congrFun (CPTPMap.equiv_inverse e.symm) œÉ

/-- Relabelling a state with `MState.relabel` leaves relative entropies unchanged. -/
@[simp]
theorem relabel_eq (e : d‚ÇÇ ‚âÉ d) (œÅ œÉ : MState d) :
    f (œÅ.relabel e) (œÉ.relabel e) = f œÅ œÉ := by
  apply of_equiv_eq

--Tomamichel's "4. Positivity" theorem is implicit true in our description because we
--only allow ENNReals. The only part to prove is that "D(œÅ‚ÄñœÉ) = 0 if œÅ = œÉ".

/-- The relative entropy is zero between any two states on a 1-D Hilbert space. -/
private lemma wrt_self_eq_zero' [Unique d] (œÅ œÉ : MState d) : f œÅ œÉ = 0 := by
  convert normalized (f := f) (d := d) default
  ¬∑ apply Subsingleton.allEq
  ¬∑ apply Subsingleton.allEq
  ¬∑ simp

/-- The relative entropy `D(œÅ‚ÄñœÅ) = 0`. -/
@[simp]
theorem wrt_self_eq_zero (œÅ : MState d) : f œÅ œÅ.M = 0 := by
  rw [‚Üê nonpos_iff_eq_zero, ‚Üê wrt_self_eq_zero' f (d := PUnit) default default]
  convert DPI (f := f) _ _ (CPTPMap.const_state œÅ)
  ¬∑ rw [CPTPMap.const_state_apply]
  ¬∑ rw [CPTPMap.const_state_apply]

end possibly_trivial

section nontrivial
variable [Nontrivial f]

/-- A nontrivial relative entropy is **faithful**, it can distinguish when two states are equal. -/
theorem faithful (œÅ œÉ : MState d) : f œÅ œÉ = 0 ‚Üî œÅ = œÉ := by
  sorry

end nontrivial

section bounds

open Prob in
/-- Quantum relative min-entropy. -/
def min (œÅ : MState d) (œÉ : HermitianMat d ‚ÑÇ) : ENNReal :=
  ‚Äîlog ‚ü®_, œÅ.exp_val_prob ‚ü®proj_le_nonneg 0 œÉ, proj_le_le_one _ _‚ü©‚ü©

@[aesop (rule_sets := [finiteness]) simp]
theorem min_eq_top_iff (œÅ : MState d) (œÉ : HermitianMat d ‚ÑÇ) :
    (min œÅ œÉ) = ‚ä§ ‚Üî œÅ.M.support ‚â§ œÉ.ker := by
  open scoped HermitianMat in
  have h‚ÇÇ : {0 ‚â§‚Çö œÉ}.ker = œÉ.ker := by
    sorry --missing simp lemma
  simp [min, Prob.negLog_eq_top_iff, MState.exp_val_eq_zero_iff, Subtype.ext_iff, proj_le_nonneg, h‚ÇÇ]

open scoped HermitianMat in
protected theorem toReal_min (œÅ : MState d) (œÉ : HermitianMat d ‚ÑÇ) :
    (min œÅ œÉ).toReal = -Real.log (œÅ.exp_val {0 ‚â§‚Çö œÉ}) :=
  Prob.negLog_pos_Real

/-- Min-relative entropy is a valid entropy function, albeit trivial (and not faithful). -/
instance : RelEntropy min where
  DPI := sorry
  of_kron := sorry
  normalized := sorry

theorem not_Nontrivial_min : ¬¨Nontrivial min := by
  rintro ‚ü®h‚ü©
  obtain ‚ü®œÅ, œÉ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := h (ULift (Fin 2))
  replace h‚ÇÇ : proj_le 0 œÉ = (1 : HermitianMat (ULift (Fin 2)) ‚ÑÇ) := by
    sorry--TODO
  simp [min, Subtype.ext_iff, MState.exp_val_eq_one_iff, proj_le_le_one, h‚ÇÅ, h‚ÇÇ] at h‚ÇÉ

/-- The relative min-entropy is a lower bound on all relative entropies. -/
theorem min_le (œÅ œÉ : MState d) : min œÅ œÉ ‚â§ f œÅ œÉ := by
  sorry --Tomamichel, https://www.marcotom.info/files/entropy-masterclass2022.pdf, (1.28)

open Classical in
/-- Quantum relative max-entropy. -/
def max (œÅ : MState d) (œÉ : HermitianMat d ‚ÑÇ) : ENNReal :=
  if ‚àÉ (x : ‚Ñù), œÅ.M ‚â§ Real.exp x ‚Ä¢ œÉ then
    some (sInf { x : NNReal | œÅ.M ‚â§ Real.exp x ‚Ä¢ œÉ })
  else
    ‚ä§

@[aesop (rule_sets := [finiteness]) simp]
protected theorem max_not_top (œÅ : MState d) (œÉ : HermitianMat d ‚ÑÇ) :
    (max œÅ œÉ) ‚â† ‚ä§ ‚Üî œÉ.ker ‚â§ œÅ.M.ker := by
  open ComplexOrder in
  constructor
  ¬∑ intro h
    contrapose! h
    simp only [max, ENNReal.some_eq_coe, ite_eq_right_iff, ENNReal.coe_ne_top, imp_false,
      not_exists]
    intro x
    contrapose! h
    intro v hv
    rw [HermitianMat.ker, LinearMap.mem_ker] at hv ‚ä¢
    replace hv : œÉ.toMat.mulVec v = 0 := sorry --why is this not defeq??
    replace h := h.right v
    rw [Matrix.sub_mulVec] at h
    simp [hv, Matrix.smul_mulVec_assoc] at h
    have := œÅ.pos.right v
    -- have := le_antisymm (œÅ.pos.right v) (by )
    sorry
  ¬∑ intro
    rw [max, if_pos]
    ¬∑ nofun
    sorry --log ("min nonzero eigenvalue of œÉ" / "max eigenvalue of œÅ") should work

protected theorem toReal_max (œÅ : MState d) (œÉ : HermitianMat d ‚ÑÇ) :
    (max œÅ œÉ).toReal = sInf { x : ‚Ñù | œÅ.M ‚â§ Real.exp x ‚Ä¢ œÉ } := by
  rw [max]
  split_ifs with h
  ¬∑ have : { x : ‚Ñù | œÅ.M ‚â§ Real.exp x ‚Ä¢ œÉ }.Nonempty := by
      convert h
    simp
    sorry
  ¬∑ push_neg at h
    simp [h]

/-- The relative max-entropy is a lower bound on all relative entropies. -/
theorem le_max (œÅ œÉ : MState d) : f œÅ œÉ ‚â§ max œÅ œÉ := by
  sorry --Tomamichel, https://www.marcotom.info/files/entropy-masterclass2022.pdf, (1.28)

end bounds

end RelEntropy

class Entropy (f : ‚àÄ {d : Type u} [Fintype d] [DecidableEq d], MState d ‚Üí ‚Ñù‚â•0) where
  /-- The entropy of a pure state is zero -/
  of_const {d : Type u} [Fintype d] [DecidableEq d] (œà : Ket d) : f (.pure œà) = 0
  /-- Entropy is additive under tensor products -/
  of_kron {d‚ÇÅ d‚ÇÇ : Type u} [Fintype d‚ÇÅ] [Fintype d‚ÇÇ] [DecidableEq d‚ÇÅ] [DecidableEq d‚ÇÇ] :
    ‚àÄ (œÅ : MState d‚ÇÅ) (œÉ : MState d‚ÇÇ), f (œÅ ‚äó œÉ) = f œÅ + f œÉ
  -- /-- Entropy is convex. TODO def? Or do we even need this? -/
  -- convex : True := by trivial


================================================================================
FILE: QuantumInfo/Finite/Entropy/Renyi.lean
TYPE: Lean 4
SIZE: 1052 characters
================================================================================

import QuantumInfo.Finite.Entropy.Defs

/-! # Quantum Relative Entropy and Œ±-Renyi Entropy -/

variable {d : Type*} [Fintype d] [DecidableEq d]

/-- The quantum relative entropy S(œÅ‚ÄñœÉ) = Tr[œÅ (log œÅ - log œÉ)]. -/
@[irreducible]
noncomputable def qRelativeEnt (œÅ : MState d) (œÉ : HermitianMat d ‚ÑÇ) : ENNReal :=
  open Classical in (if œÉ.ker ‚â§ œÅ.M.ker then
    some ‚ü®œÅ.exp_val (HermitianMat.log œÅ - HermitianMat.log œÉ),
    /- Quantum relative entropy is nonnegative. This can be proved by an application of
    Klein's inequality. -/
    sorry‚ü©
  else
    ‚ä§)

notation "ùêÉ(" œÅ "‚Äñ" œÉ ")" => qRelativeEnt œÅ œÉ

instance : RelEntropy qRelativeEnt where
  DPI := sorry
  of_kron := sorry
  normalized := sorry

instance : RelEntropy.Nontrivial qRelativeEnt where
  nontrivial := sorry

/-- Quantum relative entropy as `Tr[œÅ (log œÅ - log œÉ)]` when supports are correct. -/
theorem qRelativeEnt_ker {œÅ œÉ : MState d} (h : œÉ.M.ker ‚â§ œÅ.M.ker) :
    (ùêÉ(œÅ‚ÄñœÉ) : EReal) = œÅ.M.inner (HermitianMat.log œÅ - HermitianMat.log œÉ) := by
  simp only [qRelativeEnt, h]
  congr


================================================================================
FILE: QuantumInfo/Finite/Entropy.lean
TYPE: Lean 4
SIZE: 18364 characters


[Repository content continues in next chunk]